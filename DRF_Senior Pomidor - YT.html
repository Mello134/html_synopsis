<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- css bootstrap 5 -->
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x" crossorigin="anonymous">

	<title>Senjor Pomidor Youtube</title>

	<style type="text/css">
		
		pre{
			color: black;
			background: #fcfce8;
			margin-right: 30px;
			margin-left: 15px;
			margin-bottom: 2px;
			margin-top: 5px;
		}
		
		.all{
			background: #1c1c1c;
			color: white;
			#003802
		}
		
		body{
			background: #c0d7d8;
		}
		
		.spec {
			font-size: 18px;
			letter-spacing: .2em;
			font-weight: 500;
/*			text-transform: uppercase;*/
			color: #ff7575;
			margin-top: 15px;
			margin-bottom: 2px;
		}

		.title_text {
			letter-spacing: .1em;
			font-weight: 500;
			color: #f2cb71;
			font-size: 25px;

		}

	</style>


&lt; &lt; &lt;
</head>


<body>

	<p><a href="https://www.youtube.com/playlist?list=PLyaCd9XYVI9ACOnDvyto01CH6dx35PG-t">SPD YT 1</a></p>
	<p><a href="https://www.youtube.com/playlist?list=PLyaCd9XYVI9DiMvYl-8OdZk7ktc6NQWrb">SPD YT 2</a></p>
	<p><a href="https://www.youtube.com/playlist?list=PLyaCd9XYVI9BQXrJU3zw3PGs_vcWw7_CD/">SPD YT 3</a></p>
	
	<p><a href="https://django.fun/ru/articles/tutorials/">Статьи о Django</a></p>

	<p><a href="https://django.fun/ru/docs/">Документация по фреймворку и библиотекам Django</a></p>
	
	<p><a href="https://pypi.org/">pypi.org</a></p>


	<div class="container-md all"><!-- container-md all ОБЩИЙ -->
		<br>
		<h1 class="title_text border">Senjor Pomidor Youtube</h1>
		<hr>
		<br><br><br>


		<!-- <img src="images\avtoblog\host.jpg" class="img-fluid"><br> -->





		<h1 class="title_text border">I. Мини-курс Django</h1>
		<hr>
		<br><br>

		
		<h3 class="title_text">[1]. Установка и старт проекта</h3>
		<hr>

		<ol>

			<li>
				Установка интерпритатора Python
			</li>
			<li>
				Установка редактора кода IDE. PyCharm, SublimeText
			</li>
			<li>
				Создание проекта, в PyCharm
				<br>Выбираю New environment:
				<br>Location<pre>C:\Хранилище\IT\IT Разное\Обучение\Senior Pomidor\venv_spd</pre>
				<br>Base interpreteter<pre>Python 3.11 C:\Users\Александр\AppData\Local\Programs\Python\Python311\python.exe</pre>
				<br>Все остальные галочки пустые.
				<br><span class="spec">Теперь это venv - будет использоваться этим проектом,<br>В нем установлено только: setuptools, pip, wheel</span>
			</li>
			<li>
				Устанавливаем Django через PyCharm - settings - Project:spd-mini - Python Interpreteter - + - Django - Install Packege (Никаких галочек ставить не нужно)
				<br>Теперь в пакеты добавилось: Django, asgiref, sqlparse, tzdate
			</li>
			<li>
				Создаём проект django - в терминале: (venv_spd) PS C:\Хранилище\IT\IT Разное\Обучение\Senior Pomidor\spd-mini> 
				<pre>django-admin startproject mini</pre>
				<br>путь получился такой .../spd-miti/mini[manage.py]/mini[__init__,settings.py, urls.py ..]
			</li>
			<li>
				Запуксаем сервер
				<pre>
(venv_spd) PS C:\Хранилище\IT\IT Разное\Обучение\Senior Pomidor\spd-mini\mini>  

python manage.py runserver
				</pre>
				<br>проверяем в браузере - http://127.0.0.1:8000/
			</li>
			<li>
				Дополнительно в spd\mini - Добавлю .gitignore (в папку где есть manage.py)
			</li>
			<li>
				В settings.py - сделаю русский язык и время по МСК
				<pre>
LANGUAGE_CODE = 'ru-Ru'  # русский язык в admin

TIME_ZONE = 'Europe/Moscow'  # время по МСК</pre>
			</li>
			<li>
				Внешнюю папку mini - маркирую как Source Root
			</li>
		</ol>
	


&lt;
	
		<h3 class="title_text">[2]. Создание и управелние User</h3>
		<hr>
		<ol>

			<li>
				В settings.py - INSTALLED_APPS - 'django.contrib.auth', - это установленное приложение для User
			</li>
			<li>
				Для умного пойска в PyCarm - два раза жмём Shift - Classes - ищем класс User - class User(AbstractUser):
				<br>Открываем нас переносит в models.py - и показывают класс, полей в этом классе нет, потому что они находятся в AbstractUser
			</li>
			<li>
				Переходим в AbstractUser - для этого выделяем родительский класс, жмём Ctrl - и нас перенаправит в нужный класс
				<br>В Этом классе прописаны все поля (username, first_name, email и итд) 
			</li>
			<li>
				Классы по сути это описание таблиц в базе данных
			</li>
			<li>
				Дополнительно стразу, переделаю базу данных на PostgreSQL
				<ul>
					<li>
						Создаём DB в SQL Sell
						<pre>
Server [localhost]:
Database [postgres]:
Port [5432]:
Username [postgres]:
Пароль пользователя postgres:blog1234

psql \! chcp 1251  # для отображении кириллицы
\l смортрим список всех DB
CREATE DATABASE spd_mini;  # создали базу данных - spd_mini
-->CREATE DATABASE
\l - смотрим DB создана</pre>
					</li>
					<li>
						В PyCharm - в наше окружение устанавливаю psycopg2
					</li>
					<li>
						В settings.py переделываю проект под новую БД - DATABASES
						<pre>
DATABASES = {
    'default': {
        # 'ENGINE': 'django.db.backends.sqlite3',  # стандартная БД
        # 'NAME': BASE_DIR / 'db.sqlite3',  # стандартная БД
        'ENGINE': 'django.db.backends.postgresql',  # БД PostrgeSQL
        'NAME': 'spd_mini',  # Имя нашей БД
        'USER': 'postgres',  # пользователь postgres - который создал БД
        'PASSWORD': 'blog1234',  # пароль в PostgreSQL, для пользователя postgres
        'HOST': '127.0.0.1',  # либо просто - 'localhost'
        'PORT': '5432',  # стандартный порт
    }
}</pre>

					</li>
				</ul>
			</li>
			<li>
				Делаю делаю миграцию через терминал PyCharm
				<pre>python manage.py migrate</pre>
			</li>
			<li>
				Создаём суперюзера
				<pre>
python manage.py createsuperuser

Имя пользователя: Mello
Адрес электронной почты: elproject220@yandex.ru
Password:blog1234
Password (again):blog1234</pre>
			</li>
			<li>
				Заходим в админку http://127.0.0.1:8000/admin/ - и смотрим пользователей
			</li>
			<li>
				Создадим нового пользователя - user1
			</li>
			<li>
				Создадим группу пользователей - Web_User
			</li>
			<li>
				Перенесём нашего пользователя в нашу группу пользователей
			</li>
		</ol>
	


&lt;
	
		<h3 class="title_text">[3]. Проект и приложение</h3>
		<hr>
		<ol>
			<li>
				Собственные приложения django - это посути разделение кода (группировка кода по какомуто критерию)
				<br>Например сайт магазина, для него можно сделать приложения:
				<br>-покупки пользователя
				<br>-blilling - интеграция платёжной системы, информацию когда платил
				<br>-доставка (адреса, курьеры)
			</li>
			<li>
				Создаём приложение
				<pre>python manage.py startapp orders</pre>
				<br>Файлы приложение:
				<br>-папка migrations - миграции для передачи базы данных
				<br>-admin.py - для регистриции и настройки отображения наших моделей в админ палене
				<br>-apps.py - конфигурация приложения
				<br>-models.py - создаём собственные модели
				<br>-tests.py - для тестов
				<br>-views.py - представление. Получение запросов c url, логика отображения вэб страницы
				<br>-можем создавать свои файлы (forms.py, utils.py и тд)

			</li>
			<li>
				Регистрируем наше приложение в settings.py в INSTALLED_APPS
				<pre>
'orders',</pre>
		</ol>


&lt;
	
		<h3 class="title_text">[4]. Models Модели</h3>
		<hr>
		<ol>
			<li>
				Назодим - class AbstractUser(AbstractBaseUser, PermissionsMixin):
				<br>Метод класса def get_full_name(self): - он выводит динамический результат, он получает first_name + last_name - и выводит в новую строку
				<br>Метод класс - def email_user  - имеет логику отправки email, где email-  берётся из самой модели User
			</li>
			<li>
				Модель является единственным источником информации о ваших данных. Она содержит основные поля и поведение данных, которые вы храните. Как правило, каждая модель отображается в одну таблицу базы данных.
				<br>У объекта есть свойства, и модели вмещают в себя эти свойства.
			</li>
			<li>
				В models.py - создаём модель SalesOrder
				<pre>
class SalesOrder(models.Model):
    amount = models.IntegerField()
    description = models.CharField(max_length=255)</pre>
			</li>
			<li>
				Создаём миграцию. Миграция это промежуточный файл между Django и Базой данных
				<pre>python manage.py makemigrations</pre>
				Django автоматически создаёт id/pk
			</li>
			<li>
				применяем миграцию (записываем нашу модель в базе данных)
				<pre>python manage.py migrate</pre>
			</li>
			<li>
				Регистрируем модель в админ панеле. В admin.py
				<pre>
from .models import SalesOrder

admin.site.register(SalesOrder)</pre>
			</li>
			<li>
				Запустим django sell
				<pre>python manage.py shell</pre>
				<ul>
					<li>
						Импортируем нашу модель
						<pre>from orders.models import SalesOrder</pre>
					</li>
					<li>
						Выберем все обхекты модели
						<pre>SalesOrder.objects.all()</pre>
					</li>
					<li>
						Присвоим первый элемент списка нашей модели в переменную
						<pre>order = SalesOrder.objects.all()[0]</pre>
					</li>
					<li>
						Обратимся к отельным полям (столбцам) записи
						<pre>
order.id  -->  1
order.amount --> 25
order.description --> 'Книга'</pre>

					</li>
				</ul>
			</li>
		</ol>


&lt;
	
		<h3 class="title_text">[5]. Model Relations</h3>
		<hr>
		<ol>
			<li>
				Связи между моделями.
			</li>
			<li>
				Например <span class="spec">ForeingKey.</span> Многие к одному (много машин к одному производителю)
				<br>Данная связь наиболее частоиспользуемая
				<pre>
class Manufacturer(models.Model):
	name = ...
	pass

class Car(models.Model):
	name = ...
	manufacturer = models.ForeingKey(Manufacturer, on_delete=models.CASCADE)
..</pre>		
				<br>Производитель - у него может быть множество моделей машин
				<br>У каждой машины может быть только один производитель
			</li>
			<li>
				В модель SalesOrder - добавляем поле user - в models.py
				<pre>
class SalesOrder(models.Model):
    amount = models.IntegerField()
    description = models.CharField(max_length=255)
    # null=True - разрешает в поле Null - в старых заказах всем записям будет присвоено Null
    user = models.ForeignKey(User, on_delete=models.CASCADE, null=True)</pre>
				<br>-od_delete=models.SET_NULL - при удалении пользователя, во всех заказах в поле User будет поле Null
				<br>-od_delete=models.SET_DEFAULT - при удалении пользователя, во всех заказах в поле User будет дефолтное значение которое мы укажем
				<br>-od_delete=models.PROTECT - Django запретит удялять пользователя пока у него есть заказы
				<br>-od_delete=models.CASCADE - при удалении пользователя, все заказы связанные с пользователем будут удалены
			</li>
			<li>
				Создадим новую миграцию и применим её
				<pre>
python manage.py makemigrations
python manage.py migrate</pre>
			</li>
			<li>
				Запустим django sell
				<pre>python manage.py shell</pre>
				<ul>
					<li>
						Импортируем нашу модель
						<pre>from orders.models import SalesOrder</pre>
					</li>
					<li>
						<pre>SalesOrder.objects.all()  # все записи модели</pre>
					</li>
					<li>
						Записываем в 2 разные переменные разные записи модели
						<pre>
order1, order2 = SalesOrder.objects.all()</pre>
					</li>
					<li>
						Просмотр поля user
						<pre>
>>> order1.user 
ничего не покажет, так как поле пустое
>>> order2.user 
&lt;User: user1></pre>
					</li>
				</ul>
			</li>
			<li>
				<span class="spec">Связь ManyToManyField</span> - многие ко многим
				<br>Например начинка и пицца. У каждой пиццы может быть много начинок, для каждой начинки может быть много пицц.
				<br>Не особо важно в какой модели прописать связь ManyToMany в поле, можно как в пицце, так и в Начинке
			</li>
			<li>
				Создадим новыое приложение products
				<pre>python manage.py startapp products</pre>
			</li>
			<li>
				Регистрируем приложение в settings.py - INSTALLED_APPS
				<pre>'products',</pre>
			</li>
			<li>
				В приложении product - в models.py -  пишем модель Products
				<pre>
class Product(models.Model):
    name = models.CharField(max_length=100)</pre>
			</li>
			<li>
				Создаём и принимаем миграции
				<pre>
					python manage.py migrate</pre>
			</li>
			<li>
				Регистрируем модель в админпанеле - products/models.py
				<pre>
from products.models import Product

admin.site.register(Product)</pre>
			</li>
			<li>
				В orged/models.py - определяем связь ManyToMany (SalesOrder - Product)
				<br>В SalesOrder - добавляем поле product
				<pre>
from products.models import Product

products = models.ManyToManyField(Product)</pre>
			</li>
			<li>
				Создаём и принимаем миграцию
				<pre>
python manage.py makemigrations
python manage.py migrate</pre>
			</li>
			<li>
				Изучаем связь в админ панеле
				<br>В записях SaleOrders - появилось поле, Products - где будут хранится продукты для конкретного заказа
				<br>Создадим продукты в Products - Мобильный телефон, Ноутбук
				<br>В SaleOrders - в одном из заказе, добавляем наши продукты - и сохраняем
			</li>
			<li>
				Передём в python sell
				<pre>python manage.py shell</pre>
				<ul>
					<li>
						python manage.py shell
					</li>
					<li>
						Смотрим наши записи в модели SalesOrder
						<pre>
from orders.models import SalesOrder 
SalesOrder.objects.all()

order2 = SalesOrder.objects.all()[1]  # присвоили в переменную вторую запись модели

order2.products --> это не сработает, укажет просто ...object at 0x0000018A3A8CA85...
order2.products.all() --> &lt;QuerySet [&lt;Product: Product object (1)>, &lt;Product: Product object (2)>]> 
order2.products.all()[0].name  # вывод имени 1 продукта в нашем заказе (через класс Заказы, имя класса Продукт)</pre>
				</ul>
			</li>
			<li>
				<span class="spec">Связь OneToOneField</span>
				<br>Связь один к одному
				<br>Например у пользователя есть свой аккаунт(где есть данные например о картах) - этот аккаунт может быть привязан только к одному пользователю User
				<br>Связь применяется очень редко
				<br>Ещё один пример  - например нам необходимо к Useru Добавить поле - например номер лицевого счёта, нам не нужно изменять стандартную модель User Django - она не наша, встроенные модели изменять не стоит во избежании проблем, по этому лучше создать новый клас со связью OneToOne - и как бы расширить дополнительными полями модель User
			</li>
		</ol>


&lt;
	
		<h3 class="title_text">[6]. HTML rendering View</h3>
		<hr>
		<ol>
			<li>
				Пишем функцию представления - в orders/views.py
				<br>У render - 2 обязательный параметра (request, 'имя шаблона')
				<pre>
def orders_page(request):
    return render(request, 'index.html')</pre>
			</li>
			<li>
				<span class="">Аатоматическое исправленеи оформления кода в PyCharm (Ctrl + Alt + L)</span>
			</li>
			<li>

				<span class="spec">Во вмнешнем mini! там где manage.py.</span>
				<br>Cоздаём каталог templates!
			</li>
			<li>
				Прописываем созданною дирректирию templates - в settings.py - TEMPLATES - 'DIRS': []
				<pre>
'DIRS': ['templates'],</pre>
			</li>
			<li>
				Создаём шаблон index.html - в дирректории templates
			</li>
			<li>
				Делаем маршрут связанный с нашей функцией представления
				<br>В mini/urls.py
				<pre>path('', orders_page),</pre>
			</li>
			<li>
				<span class="spec">Ctrl+Space - помощь в импортировании чего либо</span>
				<br>Будет выскакивать похожие с именем функции/классы и где они находятся
			</li>
			<li>
				Выведем/передадим данные из модели в шаблон (передадим параметр в render)
				<br>views.py
				<pre>
from orders.models import SalesOrder

def orders_page(request):
    return render(request, 'index.html', {'orders': SalesOrder.objects.all()})
				</pre>
			</li>
			<li>
				Выводим данные модели в шаблоне index.html
				<pre>
{% for order in orders %}
&lt;p>{{ order.amount }}&lt;/p>
{% endfor %}</pre>
			</li>
			<li>
				Подключи bootstrap - в шаблон. В head - html файла вставляем ссылку css из bootstrap
			</li>
			<li>
				Немного оформим шаблон Index.html c помощью классов bootstrap
				<pre>
{% for order in orders %}

&lt;div class="btn btn-success btn-lg">
	&lt;p>Цена: {{ order.amount }}&lt;/p>
	&lt;p>Наименование: {{ order.description }}&lt;/p>
&lt;/div>
&lt;hr>
&lt;br>
&lt;br>
&lt;
{% endfor %}</pre>
			</li>
			<li>
				Метод шаблонов (view - создание HTML стриницы на сервере) устаревает, чаще всего успользуют методы API запросов
				<br>Клиент адресовывает данные как ему хочется - а сервер представляет какието голоые данные.
			</li>
		</ol>



&lt;
	
		<h3 class="title_text">[7]. API View на Django REST Framework</h3>
		<hr>
		<ol>
			<li>
				API запросы - обращение клиента к серверу. Клиент адресовывает данные как ему хочется - а сервер представляет какието голоые данные
			</li>
			<li>
				view по созданию API endpoint, который позволит нам формировать данные на сервере, передавать их на клиент, и на клиенте отрисовывать эти данные - аналогично так же как мы могли отрисовать их на сервере с помощью шаблонов html
			</li>
			<li>
				Для содания view API - необходим DJANGO REST FRAMEWORK
			</li>
			<li>
				В виртуальное окружение добавим библиотеку (пакет) - Django REST Framework.
				<br>Через PyCharm - djangorestframework
			</li>
			<li>
				QuerySet - список объектов класса
				<br>Сериализатор - Сериализаторы позволяют преобразовывать сложные данные, такие как наборы запросов и экземпляры моделей, в собственные типы данных Python, которые затем могут быть легко преобразованы в JSON , XML или другие типы содержимого.
				<br>То есть в методах передачи в шаблон мы отправляли объекты модели в шаблон, и там обращались к полям - то в случае с API это необходимо делать с помощью сериализатора
				<br>В сериализаторе нам необходимо определить какие именно поля необходимо передавать взапросе - точнее из каких полей формируетмя Python словарь
			</li>
			<li>
				Создаём новый py файл в orders (app)
				<br>serializers.py , в нём
				<pre>
from rest_framework.serializers import ModelSerializer  # базовый сериализатор dj rest
from orders.models import SalesOrder  # наш сериализатор


class OrderSerializer(ModelSerializer):  # наш сериализатор
    class Meta:
        model = SalesOrder  # наша модель
        fields = ['amount', 'description']  # поля модели</pre>
			</li>
			<li>
				<span class="spec">Alt + Enter - автоимпорт и PyCHarm</span>
			</li>
			<li>
				Создаём класс представления уже(API) - во views.py
				<pre>
from rest_framework.viewsets import ModelViewSet  # класс представления RESTfw
from orders.serializers import OrderSerializer  # наш сериализатор

# класс представления OrderView
# унаследовать функции из базового класса django REST - ModelViewSet
class OrderView(ModelViewSet):
    queryset = SalesOrder.objects.all()  # все записи модели
    serializer_class = OrderSerializer</pre>
			</li>
			<li>
				Пишем маршрут для нашего класса представления
				<br>Для model view set - маршруты пишутся немного по другому
				<br>В mini/urls.py
				<pre>
from rest_framework.routers import SimpleRouter
from orders.views import ..., OrderView

router = SimpleRouter()

router.register('api/orders', OrderView)
# ('путь url', класс представления rest)

urlpatterns = [
    path('......),
    path(......),
]

# в urlpatterns добавляем маршруты router.urls
urlpatterns += router.urls</pre>
			</li>
			<li>
				Сохраняемся и проверяем в браузере
				<pre>
http://127.0.0.1:8000/api/orders/?format=json</pre>
				<br>?format=json  - djnango rest fw - бдует понимать что необходимо передавать в формате json
				<br><span class="spec">-json - JSON (JavaScript Object Notation) - простой формат обмена данными, удобный для чтения и написания как человеком, так и компьютером. Он основан на подмножестве языка программирования JavaScript, определенного в стандарте</span>
				<br><br>
				-В браузере в вышеуказанном запросе выведет на страцице:
				<pre>-[{"amount":150,"description":"Аудиокнига"},{"amount":25,"description":"Книга"}]</pre>
				<br>-Это объект в формате json - по сути выглядит как словарь python
				<br>-В приложениях программам было бы удобно получать данные в формате json - и расставлять их куда нужно
				<br>-В формате json - данные принимают - модильные приложения, серверы, в том числе и браузеры и браузерные приложения
				<br>
				<br>
				-Способ ренедеринга в шаблоны - обычно уже не используется, он либо совсем заменён на формат json либо комбирируется (rendering + api запросы json)
			</li>
		</ol>



&lt;
	
		<h3 class="title_text">[8]. Фронтенд клиент на vue.js</h3>
		<hr>
		<ol>
			<li>
				Взаимодействие при помощи api с приложением django, чтобы сделать похожий результат который получили с помощью render
			</li>
			<li>
				Будем использовать framework JavaScript - vue JS
			</li>
			<li>
				Создадим шаблон, в который будем отправлять json, а рендерингом уже будет заниматся фронтенд JavaScript (vue JS) - то есть рендеринг будет происходить не на стороне сервера, а на стороне клиента
				<br><br>
				То есть мы отдаём клиенту шаблон и данные которые нужно в него подставить - и клиент сам расставляет эти данные в шаблон
				<br>Чаше всего даже не требуется отдавать шаблон фронтэнд клиенту - а необходимо передавать только данные
				<br>-В любом случае потребуется какаято страница, чтобы увидеть работу JavaScript framework
				<br><br>-По этому создаём новую html страницу, в папке templates - main_app.html
				<br> Делаем Html - разметку, подключаем bootstrap css в head, подключаем библиотеку vue JS - копируя ссылку скрипта из  <a href="https://github.com/translation-gang/ru.vuejs.org/blob/master/src/v2/guide/installation.md">https://github.com/translation-gang/ru.vuejs.org/blob/master/src/v2/guide/installation.md</a> (vue.js)
				Внизу head html
				<br> - добавляем axios cdn <a href="https://cdnjs.com/libraries/axios">https://cdnjs.com/libraries/axios</a> (axios.js) - аналогично vue
				<pre>
&lt;!-- css bootstrap 5 -->
&lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x" crossorigin="anonymous">

&lt;!-- vue.js - vue.cjs.js-->
&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.7.8/dist/vue.js&lt;>&lt;/script>

&lt;!-- axios cdn -->
&lt;script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js">&lt;/script></pre>
			</li>
			<li>
				Делаем функцию представления - который будет отдавать main_app.html - файл
				<br>orders/views.py
				<pre>
# представление main_app.html
def orders_main_app(request):
    return render(request, 'main_app.html')</pre>
			</li>
			<li>
				Делаем маршрут в mini/urls.py
				<pre>
from orders.views import ...., ...., orders_main_app

urlpatterns = [
    ...
    ...
    path('orders_main_app/', orders_main_app),
]</pre>
			</li>
			<li>
				В браузере переходим - http://127.0.0.1:8000/orders_main_app/ - и открываем консоль разработчика  - Network - и смотрим полключились ли файлы bootstrap, vue, axios - всё ок
			</li>
			<li>
				Создаём папку статических файлов в  mini - static, создаём js файл
				<br>spd-mini/mini/static/app.js
			</li>
			<li>
				В settings.py - указываем путь к static файлам
				<pre>STATICFILES_DIRS = [BASE_DIR / 'static']  # путь к папке static</pre>
			</li>


			<li>
				В шаблоне main_app.html - подключаем app.js - до закрывания body
				<pre>
&lt;script src="/static/app.js">&lt;/script></pre>
				В панеле разработчика в Network проверяем подключилмя ли наш app.js
			</li>
			<li>
				Пишем app.js - Java Script - код
				<pre>
//обращаемся к классу который есть в библиотеке Vue.js
new Vue({
    el: '#orders_app',  // 'элементы - Это id в div html
    // data - словарь переменных
    data: {
    orders: []
    },
    // функция - которая не принимает аргументов
    // {} - внутри код на JS когда Vue будет создано
    // Vue будет создано - когда откроется веб страница
    created: function () {
        // константа - имя = vm
        // this - это self в JS
        const vm = this;
        // подключаемся к библиотеке axios
        axios.get('/api/orders/')
        // then - после того как запрос выполнен
        // response - ответ от сервера
        .then(function (response){
        vm.orders = response.data
        })
    }
}
)</pre>
				<br>То же самое без комментариев
				<pre>
new Vue({
    el: "#orders_app",
    data: {
    orders: []
    },
    created: function () {
        const vm = this;
        axios.get("/api/orders/")
        .then(function (response){
        vm.orders = response.data
        })
    }
}

)</pre>
			</li>
			<li>
				main_app.html body
				<pre>	
&lt;!-- внтри verbatim - django рендерить не будет
потому что {{ js }} , такжеделает и djnago {{ django }} -->

{% verbatim %}
&lt;div class="container" id="orders_app">
	

	&lt;!-- v-for="order in orders - это цикл for -->
	&lt;div class="btn btn-success btn-lg" v-for="order in orders">
		
		Наименование: {{ order.description }}
		&lt;br>
		Цена: {{ order.amount }}

	&lt;/div>


&lt;/div>
{% endverbatim %}</pre>
				<br><br>
				<span class="spec">
					-В чём смысл - смысл в том что в первом сулчае (то что обычно делали в шаблонах django) - мы получали записи из БД и выводили в шаблон с помощью джанго, то есть страницу рендерил джанго, на сервере
					<br><br>-В указанном случае рендеринг делал vue JS, для этого мы и создавали api endpoint -  к которому может обращатся какойто клиент, браузер, мобильное приложение и с помощью JS - рендерить уже на стороне клиента
					<br><br>-Они вроде находятся в  маршруте router.register('api/orders', OrderView) - то есть при переходе на path('orders_main_app/', orders_main_app),   -  данные берутся из router.register('api/orders', OrderView).
					<br>При помощи API endpoint - больше возможностей.
				</span>
				<br><br>
			</li>
		</ol>

&lt;
	






		<br><br><br><br><br><br>
		<h1 class="title_text border">II. Бекенд на Django</h1>
		<hr>
		<br><br>

		
		<h3 class="title_text">[1]. Quickstart</h3>
		<hr>

		<ol>

			<li>
				Будем делать новый проект, в Pyharm - создаём Python проект и создаём  виртуальное окружение к нему
				<pre>
Проект - C:\Хранилище\IT\IT Разное\Обучение\Senior Pomidor\Books-project
Venv - C:\Хранилище\IT\IT Разное\Обучение\Senior Pomidor\venv_books</pre>
				<br><br><span class="spec">Никаких 'галочек'' не надо</span>
			</li>
			<li>
				В терминале  - (venv_books) PS C:\Хранилище\IT\IT Разное\Обучение\Senior Pomidor\Books-project>  - устанавливаем django
				<pre>
pip install Django</pre>

			</li>
			<li>
				Создаю новый django проект
				<pre>django-admin startproject books</pre>
			</li>
			<li>
				Внешнюю папку Books - (там где manage.py)  - маркирую как Sources Root - то есть это будет корневой папкой django проекта
			</li>
			<li>
				Дополнительно - сам сделаю новую Базу данных в PostgreSQL - в SQL Shell
				<pre>
Server [localhost]:
Database [postgres]:
Port [5432]:
Username [postgres]:
Пароль пользователя postgres:blog1234

psql \! chcp 1251  # для отображении кириллицы
\l смортрим список всех DB
CREATE DATABASE books;  # создали базу данных - books
-->CREATE DATABASE
\l - смотрим DB создана</pre>
			</li>
			<li>
				Установлю в  - psycopg2 - в виртуальное окружение через терминал, для того чтобы база данных PostrgeSQL работала в проекте
				<pre>pip install psycopg2</pre> 
			</li>
			<li>
				Дополнительно - наструю БД в settings.py, там же сразу сделаю русский язык и время по МСК
				<br>settings.py - База данных
				<pre>
DATABASES = {
    'default': {
        # 'ENGINE': 'django.db.backends.sqlite3',  # стандартная БД
        # 'NAME': BASE_DIR / 'db.sqlite3',  # стандартная БД
        'ENGINE': 'django.db.backends.postgresql',  # БД PostrgeSQL
        'NAME': 'books',  # Имя нашей БД
        'USER': 'postgres',  # пользователь postgres - который создал БД
        'PASSWORD': 'blog1234',  # пароль в PostgreSQL, для пользователя postgres
        'HOST': '127.0.0.1',  # либо просто - 'localhost'
        'PORT': '5432',  # стандартный порт
    }
}</pre>
			<br>settings.py - время и язык
			<pre>
LANGUAGE_CODE = 'ru-Ru'  # русский язык в admin

TIME_ZONE = 'Europe/Moscow'  # время по МСК</pre>
			</li>
			<li>
				В корневой каталог books (там где manage.py) - добавляю .gitignore
			</li>
			<li>
				Создаём новое приложение - в терминале - (venv_books) PS C:\Хранилище\IT\IT Разное\Обучение\Senior Pomidor\Books-project\books> 
				<pre>
python manage.py startapp store</pre>
			</li>
			<li>
				Дополнительно - регистрирую приложение store в settings.py - INSTALLED_APPS
				<br>Информацию берём из store/apps.py - class
				<pre>'store.apps.StoreConfig',</pre>
			</li>
			<li>
				Принимаю первую миграцию (пользователи админки и такдалее) - те таблицы что нужны django изначально
				<pre>python manage.py migrate</pre>
				<br>Через pgAdmin 4 - можно проверить, создались си в нашей базе данных таблицы
			</li>
			<li>
				Создаём супер пользователя
				<pre>
python manage.py createsuperuser

Имя пользователя: Mello
Адрес электронной почты: elproject220@yandex.ru
Password:blog1234
Password (again):blog1234</pre>
			</li>
			<li>
				Проверим работостпособность сервера и войдём в админ панель - под аккаунтом superuser
			</li>
			<li>
				Создадим пользователя user1
			</li>
			<li>
				Создаём первую модель в store/models.py
				<pre>
class Book(models.Model):
    name = models.CharField(verbose_name='Название книги', max_length=255)
    # DecimalField - почти float, но необходимо указать сколько значений будет после запятой
    # max_digits=7 - максимальное количество цифр в числе (вместе с дробной частью)
    # decimal_places=2 - два числа после запятой
    price = models.DecimalField(verbose_name='Цена книги', max_digits=7, decimal_places=2)</pre>
			</li>
			<li>
				Ctrl+Alt+L - PyCharm - автоматически отредактирует код согласно PIP8
			</li>
			<li>
				Создадим и применим миграцию
				<pre>
python manage.py makemigrations
python manage.py migrate</pre>
			</li>
			<li>
				Дополнительно, зарегистрирую и настрою отображение нашей модели в админ панеле
				<br>в store/admin.py
				<pre>
from store.models import Book


class BookAdmin(admin.ModelAdmin):
    # список отображаемых столбцов в админ-панели
    list_display = ('id', 'name', 'price')
    # список полей на которые можно кликнуть - для редактирования
    list_display_links = ('id', 'name', 'price')
    # список полей - ко которым можно вести поиск
    search_fields = ('name',)


# регистрируем в админке - модель Book
# регистрируем класс отображения в админке - BookAdmin
admin.site.register(Book, BookAdmin)</pre>
			</li>
			<li>
				Дополнительно - Изменю отображение названия в админ панели для модели Book, в единственном и множественном числе - на русском языке
				<br>для этого в store/models.py - модели Book, допишем class Meta:
				<pre>
class Meta:
    verbose_name = 'Книги'
    verbose_name_plural = 'Книги'</pre>
			</li>
			<li>
				Дополнительно - отобразим название приложения - STORE - на русском языке
				<br>Для этого в store/apps.py - class StoreConfig(AppConfig): - добавим verbose_name
				<pre>
verbose_name = 'Магазин'</pre>
			</li>
			<li>
				Устанавливаем djangorestframework - через PyCharm
				<br>Теперь мы можем пользоваться классами который предоставляет djangorestframewoek
			</li>
			<li>
				Дополнительно зарегистрирую djangorestframework в settings.py - INSTALLED_APPS
				<pre>
'rest_framework',  # djangorestframework</pre>
			</li>
			<li>
				Сделаем сериализацию модели Book - в store - создаём новый файл - serialuzers.py
				<br>Внутри него делаем сериализатор для нашего класса
				<pre>
from rest_framework.serializers import ModelSerializer
from store.models import Book

# ModelSerializer - родительский класс
class BookSerializer(ModelSerializer):
    class Meta:
        model = Book
        fields = '__all__'  # все поля</pre>
			</li>
			<li>
				Создадим представление для нашего будущего API Endpoint
				<br>в store/views.py
				<pre>
from django.shortcuts import render  # обычный render - нам больше не нужен..

from rest_framework.viewsets import ModelViewSet
from store.models import Book
from store.serializers import BookSerializer

# ModelViewSet - родительский класс
class BookViewSet(ModelViewSet):
    queryset = Book.objects.all()  # объекты нашей модели
    serializer_class = BookSerializer  # наш сериализатор</pre>
			</li>
			<li>
				необходимо пробросить запрос из нашего представления
				<br>В books (проект)/urls.py
				<pre>
from rest_framework.routers import SimpleRouter  # маршрутизатор rest
from store.views import BookViewSet  # наше представление api

# создали переменную роутер
router = SimpleRouter()

# в роутер добавим наше представление
router.register(r'book', BookViewSet)


urlpatterns = [
	...
]

# добавляем в urlpatterns, url-ы нашего роутера
urlpatterns += router.urls</pre>
			</li>
			<li>
				Проверяем работоспособность
				http://127.0.0.1:8000/book/
				<br><span class="spec">Прелесть Django REST framework - в том что он делает всё автоматически - при переходе по указанному url-у http://127.0.0.1:8000/book/  - нам выведется страница со всей информациией от фреймворка, мы можем посмотртеть сухой json (какой он на самом деле) просто нажав кнопку json<br>
				И нас перенесёт по реальному url-у - http://127.0.0.1:8000/book/?format=json</span>
				<br><br>
			</li>
			<li>
				Добавим пару записей в Book через django sell в терминале
				<pre>
python manage.py shell 

# импортируем модель в shell
from store.models import Book 

# создаём пару записей
Book.objects.create(name='Учебник Python', price='1000.00') 
Book.objects.create(name='Документация Django', price='1500.00')

# выход из shell
exit()</pre>
			</li>
			<li>
				Проверим в браузере, всё чётко работает, выводит словарь - словарь как сериальзованная модель ф формате json
				<pre>
[{"id":1,"name":"Учебник Python","price":"1000.00"},{"id":2,"name":"Документация Django","price":"1500.00"}]
				</pre>
			</li>
			<li>
				Дополнительно создам репозиторий на github - отправлю первый коммит
				(.gitignore - уже создавал)
			</li>
		</ol>
	


&lt;





		<h3 class="title_text">[2]. Unit Tests</h3>
		<hr>

		<ol>

			<li>
				Делаем первый unnit test - store/tests.py - удалим файл - и сделаем целую дирректорию
				store/tests  - делаем как Python Package (папка с __init__.py) В этой дирректории бдут тесты для каждого модуля которые мы имеем (models.py views.py serializers.py)
			</li>
			<li>
				В store - создадим python файл - logic.py - в нём делаем пример теста
				<pre>
def operations(a, b, c):
    if c == '+':
        return a + b
    if c == '-':
        return a - b
    if c == '*':
        return a * b</pre>
        		<br>Переходим в Python Console
        		<pre>
from store.logic import operations  # импортируем нашу функцию из logic.py

operations(3, 7, '-')  # вводим значения для a, b, c
-4  # вывела консоль - функция работает

operations(3, 7, '+')
10
operations(3, 7, '*')
21</pre>
			</li>
			<li>
				В store/tests - создаём .py -файл - test_logic.py <strong>Причём нижнее подчёркивание обязательно для создании тестов</strong>
				<br>Как правило тесты пишится классами, для этого есть два самых популярных фреймворка - <strong>unittest, django.test , pytest</strong><br>первый и второй как праивло уже установлены - на данном этапе
			</li>
			<li>
				<span class="spec">В Pithon 3.11 - на данный момент есть проблемы с pydev debugger</span>
				<br>Я решил проблему 1) с помошью установки в виртуальное окружения django-debugger
				<br>2) from <strong>unittest</strong> import TestCase
			</li>
			<li>
				В store/test/logic_test/py - пишем тест:
				<pre>
from unittest import TestCase  # встроенный класс для тестов

# наш тест на основе базового TestCase
class LogicTestCase(TestCase):
    def test_plus(self):  # метод внутри теста
        # подставляем значения abc
        # def operations (a, b, c) - прописана в другой файле
        result = operations(6, 13, '+')
        # (то что мы ожидаем, результат)
        self.assertEqual(19, result)</pre>
        		<br>Делаем тест - на test_plus - ПКМ -Run
        		<br>Вывод в консоле:
        		<pre>
Ran 1 test in 0.002s

OK</pre>
				<br>То есть 6 + 13 = 19 --> OK -  условие выполнено
			</li>
			<li>
				Если мы поменяем значение в условии на result = operations(9, 13, '+')
				<br>Run выведет:
				<pre>
Ran 1 test in 0.004s

FAILED (failures=1)

22 != 19

Expected :19
Actual   :22

AssertionError: 19 != 22
</pre>
				То есть не верно, мы планируем увидить 19, но по факту результат функции = 22
			</li>
			<li>
				Добавим ещё два теста (метод в классе ) - LogicTestCase
				<br>Там же test_logic.py
				<pre>
def test_minus(self):
    result = operations(6, 13, '-')
    # (то что мы ожидаем, результат)
    self.assertEqual(-7, result)

def test_multiply(self):
    result = operations(6, 13, '*')
    # (то что мы ожидаем, результат)
    self.assertEqual(78, result)</pre>
    			Всё работает!
			</li>
			<li>
				То эе самое проделаем в терминале
				<br>В терминле - (venv_books) PS C:\Хранилище\IT\IT Разное\Обучение\Senior Pomidor\Books-project\books>
				<pre>
 python manage.py test store.tests
 # где - store.tests - это дирректория где хранятся наши тесты</pre>
			</li>
			<li>
				Ещё вариант сделать тесты - в терминале просто записать
				<pre>python manage.py test .</pre>
				Будут сделаны все тесты в папке которой мы находимся в терминале
			</li>
			<li>
				В store/test - создаём test_api.py (будем тестировать представления api) - внутри создаём
				<pre>
from django.urls import reverse
from rest_framework.test import APITestCase

# проверка API  - см urls.py router.register(r'book', BookViewSet)
class BooksApiTestCase(APITestCase):
    def test_get(self):
        # book-list - получение всего списка router.register(r'book', BookViewSet)
        # book-detail - если бы необходимо было бы конкретную книгу
        url = reverse('book-list')
        print(url)  # для себя - для проверки что выведет
        # self.client - например клиент/браузер - который делает запрос нашему серверу
        response = self.client.get(url)
        print(response)  # для себя - для проверки что выведет</pre>
			</li>
			<li>
				Делаем проверку BooksApiTestCase  - в терминале (так.как PyCharm PyCharm Community Edition - не поддерживает тесты rest) - чтобы делать кнопочками, необходима платная версия
				<br>Делаем тест только в одном файле
				<pre>
python manage.py test store.tests.test_api</pre>
				<br><br>Терминал выведет
				<pre>
/book/
&lt;Response status_code=200, "application/json">
.
-----------
Ran 1 test in 0.012s

OK</pre>
			</li>
			<li>
				Поменяем print(response) на print(response.data)  и повторим тест
				<pre>
print(response.data)
-->
/book/
[]  # это пустой api - так как в тесте мы не загружали никакие данные
.....</pre>
			</li>
			<li>
				Добавим в тест пару книг, 
				<br><span class="spec">Важно понимать - что книги не записываются в БД - это только текст - не смотря на то что мы импортировали модель из models.py</span>
				<pre>
from store.models import Book

# проверка API  - см urls.py router.register(r'book', BookViewSet)
class BooksApiTestCase(APITestCase):
    def test_get(self):
        # добавили тестовые книги! они не записываются в БД! - это тест!
        book_1 = Book.objects.create(name='Test book 1', price=25)
        book_2 = Book.objects.create(name='Test book 2', price=50)
        # book-list - получение всего списка router.register(r'book', BookViewSet)
        # book-detail - если бы необходимо было бы конкретную книгу
        url = reverse('book-list')
        print(url)  # для себя - для проверки что выведет
        # self.client - например клиент/браузер - который делает запрос нашему серверу
        response = self.client.get(url)
        print(response.data)  # для себя - для проверки что выведет</pre>
        		<br>Делаем тест
        		<pre>
python manage.py test store.tests.test_api
-->
/book/
[OrderedDict([('id', 1), ('name', 'Test book 1'), ('price', '25.00')]), OrderedDict([('id', 2), ('name', 'Test book 2'), ('price', '50.0
0')])]
----
Ran 1 test in 0.014s

OK</pre>
				Всё работает - отлично
			</li>
			<li>
				Подключим сериализатор к тесту
				<pre>
from store.serializers import BookSerializer

# проверка API  - см urls.py router.register(r'book', BookViewSet)
class BooksApiTestCase(APITestCase):
    def test_get(self):
        # вводные данные
        book_1 = Book.objects.create(name='Test book 1', price=25)
        book_2 = Book.objects.create(name='Test book 2', price=50)

        # book-list - получение всего списка router.register(r'book', BookViewSet)
        # book-detail - если бы необходимо было бы конкретную книгу
        url = reverse('book-list')

        # self.client - например клиент/браузер - который делает запрос нашему серверу
        response = self.client.get(url)

        # сравниваем то что вводные данные сходятся с выходными
        serializer_data = BookSerializer([book_1,book_2], many=True).data
        # serializer_data - входные данные, response.data - выходные данные
        # Мы ожидаем что должно быть serializer_data, и проверяем равен ли ей response.data
        self.assertEqual(serializer_data, response.data)


--> 
Ran 1 test in 0.011s

OK</pre>		
				Тест прошёл
			</li>
			<li>
				Необходимо сравнить что код возврата http сервера будет 200 (200 это значит всё хорощо, 404 - значит страница не найдена)
				<br>
				Добавим строчку - self.assertEqual(status.HTTP_200_OK, response.status_code)
				<pre>
test_api.py:

from rest_framework import status


class BooksApiTestCase(APITestCase):
    def test_get(self):
        book_1 = Book.objects.create(name='Test book 1', price=25)
        book_2 = Book.objects.create(name='Test book 2', price=50)
        url = reverse('book-list')
        response = self.client.get(url)

        # Ожидаем страницу статус=200, сравниваем с ответным кодом
        self.assertEqual(status.HTTP_200_OK, response.status_code)

        serializer_data = BookSerializer([book_1,book_2], many=True).data
        self.assertEqual(serializer_data, response.data)


Тест:

python manage.py test store.tests.test_api
-->
Ran 1 test in 0.010s

OK</pre> 
			</li>
			<li>
				Сделаем запланированную ошибку
				<pre>self.assertEqual(status.HTTP_202_ACCEPTED, response.status_code)</pre>
				<br>Тест не пройдёт - так как ошидаемые данные не будут совпадать с выходными
				<br>page code 202 != page code 200
			</li>
			<li>
				<strong>Делаем тест сериализатора</strong><br>
				В tests - создаём  - test_serializers.py, в нём пишем тест
				<pre>
from django.test import TestCase
from django.urls import reverse
from store.models import Book
from store.serializers import BookSerializer


class BookSerializerTestCase(TestCase):
    def test_ok(self):
        # вводные данные
        book_1 = Book.objects.create(name='Test book 1', price=25)
        book_2 = Book.objects.create(name='Test book 2', price=50)
        # проверяемые данные
        data = BookSerializer([book_1, book_2], many=True).data

        # ожидаемые данные
        expected_data =[
            {
                'id': book_1.id,
                'name': 'Test book 1',
                'price': '25.00'
            },
            {
                'id': book_2.id,
                'name': 'Test book 2',
                'price': '50.00'
            },
        ]

        # само тестирование
        # (ожидаемые данные, данные из сериализатора)
        self.assertEqual(expected_data, data)</pre>
        		<br><span class="spec">Обрати внимание - на price - необходимо делать именно с .00 - так как поле в моделе - class Book - price = models.DecimalField(.... decimal_places=2)</span>
        		<br>
        		<br>Делаем тест
        		<pre>
python manage.py test store.tests.test_serializer
-->
Ran 1 test in 0.011s
OK</pre>		
			</li>
			<li>
				Тесты в целом не должны выглядить красиво, с наследованиями, декораторами и так далее, тесты должны быть максимально простыми и понятными, чтобы на тесты не прищлось писать свои тесты
			</li>
			<li>
				<span class="spec">Пакет coverage</span>
				<br>Показывает - на сколько тесты покрывают имеющийся код
				<br>Устанавливаем пакет в окружение
			</li>
			<li>
				Анализируем весь проект в терминали с помощью coverage
				<pre>
coverage run --source='.' ./manage.py test .</pre>
				Покрытие нужно анализировать отностительно корня / анализируем весь проект
			</li>
			<li>
				Смотрим список покрытия, создаём репорт
				<pre>
coverage report</pre>
				На выходе будет таблица py файлов и процент покрытия
			</li>
			<li>
				Для вывода репорта в виде html - в терминале
				<pre>coverage html</pre>
				Будет создан подкаталог htmlcov - и в нём будут нужные html страницы
			</li>
		</ol>
	


&lt;






		<h3 class="title_text">[3]. Filters, Search, Ordering</h3>
		<hr>

		<ol>

			<li>
				Механизм фильтрациии, поиск и сортировка в API
			</li>
			<li>
				Django REST-  предлагает работать с пакетом django-filter  - устанавливаем в окружение
			</li>
			<li>
				Во views.py - добавляем фильтр в представлении (API) - class BookViewSet(ModelViewSet): - 
				<pre>
class BookViewSet(ModelViewSet):
    ....
    filter_backends = [DjangoFilterBackend]  # filter django-filter
    # для фильтра в url  - ?price=1000
    filter_fields = ['price']  # django-filter - возможность фильтровать по price (цене))</pre>
				<br>пробуем запускать в браузере - http://127.0.0.1:8000/book/ / JSON - http://127.0.0.1:8000/book/?format=json
			</li>
			<li>
				Зайдём в консоль manage.py shell
				<pre>
python manage.py shell
from store.models import Book 
Book.objects.all() # посмотрим все записи модели
&lt;QuerySet [&lt;Book: Book object (1)>, &lt;Book: Book object (2)>]> 

Book.objects.all()[0]  # посмотреть Querisetы  первой записи
Book.objects.all()[0]  # посмотреть Querisetы  первой записи

Book.objects.all()[0].price # посмотреть цену первой записи
--> Decimal('1000.00') 

#создадим новую запись модели Book
Book.objects.create(price='500.00', name='Русско-Английский переводчик')
&lt;Book: Book object (3)> 
				</pre>
			</li>
			<li>
				Дополнительно пропишу метод str для модель Book - для того чтобы при обращении к можели нам показывало название кники а не Book object (2)
				<pre>
class Book(models.Model):
	......
    def __str__(self):
    return self.name</pre>
			</li>
			<li>
				Расрурю метод __str__ - чтобы показывалось id + name
				<pre>
def __str__(self):
    return f'Id {self.id}: {self.name}'</pre>
			</li>
			<li>
				Добавим поле - имя автора в модели Book
				<pre>
class Book(models.Model):
	...
    author_name = models.CharField(max_length=255)</pre>
    			Это поле не предполагается быть пустым (то есть у каждой книги есть автор), при создании миграции будет проблема - так как необходимо заполнить поле автор - для всех уже созданных записей. Есть несколько вариантов решения
    			<br>-Временно указать в моделе default=значение
    			<br>-Можно прям в терминале прописать значение которым заполнятся поля
			</li>
			<li>
				Создаём и и принимаем миграцию
				<pre>
python manage.py makemigrations

# Введём в поле author_name  - во всех созданных записях значение Автор
Please select a valid option: 1
"Автор"	

pythin manage.py migrate</pre>
			</li>
			<li>
				Сразу изменим авторов для всех записей на реальные
			</li>
			<li>
				Дополнительно настрою отображение в админке и не только
				<br>models.py - class Book
				<pre>author_name = models.CharField(verbose_name='Автор книги', max_length=255)</pre>
				<br>admin.py
				<pre>
class BookAdmin(admin.ModelAdmin):
    # список отображаемых столбцов в админ-панели
    list_display = ('id', 'name', 'price', 'author_name')
    # список полей на которые можно кликнуть - для редактирования
    list_display_links = ('id', 'name', 'price', 'author_name')
    # список полей - ко которым можно вести поиск
    search_fields = ('name', 'author_name')</pre>
			</li>
			<li>
				Настраиваем посик во view.py - (поиск имеет смысл когда мы ищем по двум полям или более)
				<pre>
from rest_framework.filters import SearchFilter

class BookViewSet(ModelViewSet):
	....
	filter_backends = [DjangoFilterBackend, SearchFilter]  # django-filter
	.....
	search_fields = ['name', 'author_name']	 # для поиска</pre>
			</li>
			<li>
				Для поиска в url пишем
				<pre>
http://127.0.0.1:8000/book/?search=django
-->
[{"id":2,"name":"Документация Django","price":"1500.00","author_name":"Адриан Головатый"}]


http://127.0.0.1:8000/book/?search=докум
-->

[{"id":2,"name":"Документация Django","price":"1500.00","author_name":"Адриан Головатый"}]
</pre>
				Будет выводить любые записи по результатам ?search=поиск - в полях name и author_name
			</li>
			<li>
				Сортировка api - OrderingFilter
				<pre>
from rest_framework.filters import SearchFilter, OrderingFilter

class BookViewSet(ModelViewSet):
	....
    filter_backends = [..., ..., OrderingFilter]  # django-filter
    ...
    # для сортировки
    ordering_fields = ['price', 'author_name']</pre>
			</li>
			<li>
				Используем сортировку, в брузере попробуем всё отсортировать по цене
				<pre>
http://127.0.0.1:8000/book/?ordering=price
--> 
выведет полный отсортированный список

http://127.0.0.1:8000/book/?ordering=-price
-->
сортировка в обратном порядке

http://127.0.0.1:8000/book/?ordering=author_name
-->
сортировка по автору (по алфавиту)
</pre>
			</li>
			<li>
				Полнный класс представления views.py
				<pre>
# ModelViewSet - родительский класс
class BookViewSet(ModelViewSet):
    queryset = Book.objects.all()  # объекты нашей модели
    serializer_class = BookSerializer  # наш сериализатор

    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]  # django-filter
    # для фильтра в url  - ?price=1000
    filter_fields = ['price']  # django-filter - возможность фильтровать по price (цене)
    # для поиска
    search_fields = ['name', 'author_name']
    # для сортировки
    ordering_fields = ['price', 'author_name']</pre>
			</li>
			<li>
				Пишем unit test
				<br>Ищзменяем - test_api.py - class BooksApiTestCase(APITestCase): - добавляем метод - в самом начале
				<pre>
# проверка API  - см urls.py router.register(r'book', BookViewSet)
class BooksApiTestCase(APITestCase):
    # метод будет запускаться перед каждым тестом (методами test_get)
    def setUp(self):
        # вводные данные
        self.book_1 = Book.objects.create(name='Test book 1', price=25, author_name='Автор 1')
        self.book_2 = Book.objects.create(name='Test book 2', price=50, author_name='Автор 2')
        self.book_3 = Book.objects.create(name='Test book 3', price=75, author_name='Автор 3')</pre>
			</li>
			<li>
				Изменим def test_get  (убрали вводные данные в setUp, добавили в serializer_data, к записям self, добавили book_3)
				<pre>
    def test_get(self):
        # book-list - получение всего списка router.register(r'book', BookViewSet)
        # book-detail - если бы необходимо было бы конкретную книгу
        url = reverse('book-list')

        # self.client - например клиент/браузер - который делает запрос нашему серверу
        response = self.client.get(url)

        # Ожидаем страницу статус=200, сравниваем с ответным кодом
        self.assertEqual(status.HTTP_200_OK, response.status_code)

        # сравниваем то что вводные данные сходятся с выходными
        serializer_data = BookSerializer([self.book_1, self.book_2, self.book_3], many=True).data
        # serializer_data - входные данные, response.data - выходные данные
        # Мы ожидаем что должно быть serializer_data, и проверяем равен ли ей response.data
        self.assertEqual(serializer_data, response.data)					
				</pre>
			</li>
			<li>
				Сделаем test_get в терминале - тест api полного списка без каких либо сортировок
				<pre>
python manage.py test  store.tests.test_api.BooksApiTest
Case.test_get</pre>
			</li>
			<li>
				В этот же класс - BooksApiTestCase  - добавим ещё один метод (test_get_filter) - сестируем фильтр, поиск и немного подкорректируем входные данные в setUp
				<pre>
def setUp(self):
    # вводные данные
    self.book_1 = Book.objects.create(name='Test book 1', price=25, author_name='Автор 1')
    self.book_2 = Book.objects.create(name='Test book 2', price=50, author_name='Автор 2')
    self.book_3 = Book.objects.create(name='Test book 3 Автор 1', price=75, author_name='Автор 1')


def test_get_search(self):
    # book-list - получение всего списка router.register(r'book', BookViewSet)
    # book-detail - если бы необходимо было бы конкретную книгу
    url = reverse('book-list')

    # условия поиска
    response = self.client.get(url, data={'search': 'Автор 1'})
    # Ожидаем страницу статус=200, сравниваем с ответным кодом
    self.assertEqual(status.HTTP_200_OK, response.status_code)
    serializer_data = BookSerializer([self.book_1,
                                      self.book_3], many=True).data
    # Мы ожидаем что должно быть serializer_data, и проверяем равен ли ей response.data
    self.assertEqual(serializer_data, response.data)</pre>
				<br>
				Делаем тест test_get_search
				<pre>python manage.py test  store.tests.test_api.BooksApiTestCase.te
st_get_search</pre>
			</li>
		</ol>
	


&lt;





		<h3 class="title_text">[4]. OAuth</h3>
		<hr>

		<ol>

			<li>
				Проверка аутентификации пользователя
			</li>
			<li>
				Выйдем из админки, в views.py - BookViewSet - добавим строчку, что бы запритить это представление не залогиненым пользователям (авторизация) permission
				<pre>
from rest_framework.permissions import IsAuthenticated

# ModelViewSet - родительский класс
class BookViewSet(ModelViewSet):
	...
	# только авторизованные пользователи могут пользоваться представлением
    permission_classes = [IsAuthenticated]</pre>
    			Сохраняем пробуем войти по url
    			<pre>
http://127.0.0.1:8000/book/
-->
"detail": "Учетные данные не были предоставлены."

http://127.0.0.1:8000/book/?format=json
-->
{"detail":"Учетные данные не были предоставлены."}</pre>
				<br>То есть всё работает
			</li>
			<li>
				<span class="spec">
					Аутентифиация и авторизация - это разные вещи
				</span>
				<br>
				Аутентифиация - проверка подлинности пользователя (проверка подлинности эмейла, проверка подлинности аккаунта на facebok)
				<br>
				Авторизация - разрешение.
				<br>Сначала пользователя аутентифецируем, логиним, а вотом запрещаем/разрешаем пользователю что то видеть или делать какието действия
			</li>
			<li>
				Python Social Auth - читай порядок установки с оф докумметации
				<br><a href="https://python-social-auth.readthedocs.io/en/latest/configuration/django.html">https://python-social-auth.readthedocs.io/en/latest/configuration/django.html</a>
				<ul>
					<li>Устанавливаем в виртуальное окружение - social-auth-app-django</li>
					<li>settings.py - INSTALLED_APPS - 
						<pre>
'social_django',  # аутентификация</pre>
						<br><strong>
							Как правило в INSTALLED_APPS - идут приложения джанго, нижу третесторониие приложения, ниже наши приложения, которые создавали сами
						</strong>
					</li>
					<li>Необходимо сделать миграцию
						<pre>python manage.py migrate</pre>
					</li>
					<li>
						Для PostrgeSQL - в settings.py необходимо добавить - Чтобы этот пакет мог пользоваться json форматом  - без нагрузки на базу
						<pre>SOCIAL_AUTH_JSONFIELD_ENABLED = True</pre>

					</li>
					<li>
						В settings.py необходимо добавить то через какие соцсети можно будет залогинится
						<pre>
AUTHENTICATION_BACKENDS = (
    'django.contrib.auth.backends.ModelBackend',
)</pre>
					</li>
					<li>
						Необходимо сделать маршрутизацию
						<br>urls.py
						<pre>
from django.urls import .., include, re_path

re_path('', include('social_django.urls', namespace='social'))</pre>
					</li>
					<li>
						Запускаем сервер - домашняя страница будет ошибка 404 - так как нет домашней странице, но есть список всех маршрутов которые существуют
						<pre>
admin/
login/&lt;str:backend>/ [name='begin']
complete/&lt;str:backend>/ [name='complete']
disconnect/&lt;str:backend>/ [name='disconnect']
disconnect/&lt;str:backend>/&lt;int:association_id>/ [name='disconnect_individual']
^book/$ [name='book-list']
^book/(?P&lt;pk>[^/.]+)/$ [name='book-detail']</pre>
						<br>Как раз login, complete, disconnect - это как раз те эндпойнты которые создал Social Auth
					</li>
					<li>
						Почитай статью <a href="https://www.digitalocean.com/community/tutorials/oauth-2-ru">Введение в OAuth 2</a>
						<br>
						<img src="images\SPD\oauth.png" class="img-fluid">
						<br>

					</li>
					<li>
						Продолжаем настройку для аутентификации по гитхабу - 
						<br><a href="https://python-social-auth.readthedocs.io/en/latest/backends/github.html#github">https://python-social-auth.readthedocs.io/en/latest/backends/github.html#github</a>
						<br>settings.py
						<pre>
AUTHENTICATION_BACKENDS = [
    ...
    'social_core.backends.github.GithubOAuth2',
]</pre>
					</li>	
					<li>
						В settings.py - добавляем ключи
						<pre>
SOCIAL_AUTH_GITHUB_KEY = 'a1b2c3d4'
SOCIAL_AUTH_GITHUB_SECRET = 'e5f6g7h8i9'</pre>
					</li>	
					<li>
						Переходим в настройки на самом гитхабе
						<br><a href="https://github.com/settings/applications/new">https://github.com/settings/applications/new</a>
						<br>Заполняем форму регистрации приложения, с которого можно будет сделать аутентификацию через github
						<br>
						<img src="images\SPD\git_oauth.jpg" class="img-fluid">
						<br>
					</li>	
					<li>
						Далее с самого гита - берём ключ Client ID и Client secrets
 - и добавляем в settings.py
 						<pre>
 SOCIAL_AUTH_GITHUB_KEY = '442aea3aeb0402d9a95b'
SOCIAL_AUTH_GITHUB_SECRET = '90d906e0e4172a9c1eed641e9add54a6c12cbb08'</pre>
						<span class="spec">проверь чтобы не где небыло лишних пробелов!</span>
					</li>
					<li>
						Настройка oauth завершена, можно пользоваться в представлениях, в шаблонах
					</li>				
				</ul>
			</li>
			<li>
				В корневой папке books - создаём папку templates
			</li>
			<li>
				В settings.py - TEMPLATES - DIRS - добавляем
				<pre>'DIRS': ['templates'],</pre>
			</li>
			<li>
				Создаём шаблон oauth.html - делаем изначальный шаблон - добавим bootstrap cdn - В body - добавим ссылку на аутентификацию через github
				<pre>
&lt;a href="{% url "social:begin" "github" %}">GitHub&lt;/a></pre>
			</li>
			<li>
				Сделаем функцию представления для шаблона oauth.html
				<pre>
def my_auth(request):
    return render(request, 'oauth.html')</pre>
			</li>
			<li>
				Добавим маргрут в urlpatterns
				<pre>
from store.views import ..., my_auth	

path('auth/', my_auth, name='my_auth'),</pre>
			</li>
			<li>
				Переходим - http://127.0.0.1:8000/auth/
				<br>При нажатии ссылки нас отправит на github для разрежения аутентификации
				<br>Авторизуемся на github - и нас отправит обратно на нашу домашнюю страницу, тестового веб сервера
			</li>
			<li>
				Зайдём в админ панель - и видим что у нас отображается приложение - PYTHON SOCIAL AUTH - в User social auths - есть пользователь с гитхабом - всё отлично, так же есть user в пользователях
			</li>
		</ol> 
	


&lt;





		<h3 class="title_text">[5].  CRUD через REST Framework</h3>
		<hr>

		<ol>

			<li>
				CRUD - create reade update delete - создание чтение редкатирование удаление
			</li>
			<li>
				СRUD при помощи MoodelViewSet - в нём есть всё из коробки
				<br>Посмотри из каких классов 'смиксирован ' MoodelViewSet (Ctrl+ЛКМ):
				<pre>
class ModelViewSet(mixins.CreateModelMixin,
                   mixins.RetrieveModelMixin,
                   mixins.UpdateModelMixin,
                   mixins.DestroyModelMixin,
                   mixins.ListModelMixin,
                   GenericViewSet):					
				</pre>
				По сути сразу становится  всё понятно
			</li>
			<li>
				Postman - программа для эмуляции запросов (GET, POST, PUT, DELETE..)<br>
				<a href="https://www.postman.com/">https://www.postman.com/</a>
			</li>
			<li>
				Запустим сервер - http://127.0.0.1:8000/book/ - и перейдём в панель разработчика (хром) - Network - book/ - Cookie: копируем полностью и
				<br>Вставляем в postman - Run - Headers - в столбце VALUES
				<br>
				<img src="images\SPD\postman.jpg" class="img-fluid">
				<br>
			</li>
			<li>
				Что бы создать какуюто запись необходим запрос POST, при попытке нам опять дась запрет - для исправления в о второй записи таблицы Header Добавим значения
				<pre>
KEY:
X-CSRFToken

VALUE:
MnjUFIwCRsFNjrzrSjwoN03tTJOjJmsJ
#ЭТО csrf token - из того же Cookie</pre>
			</li>
			<li>
				Запрашиваем POST всё проходит но пишет
				<pre>
"name": [
    "Обязательное поле."
],
"price": [
    "Обязательное поле."
],
"author_name": [
    "Обязательное поле."
]</pre>
				Это рещультат валидиции нашего сериализаторы - BookSerializer - он не допускает создания пкстых записей
			</li>
			<li>
				В postman - Body (POST) - отправим JSON запрос (Body - raw - JSON)
				<pre>
{"name": "Python 3",
"price": "150",
"author_name": "Mark Summerfield"}

-->
	
{
    "id": 4,
    "name": "Python 3",
    "price": "150.00",
    "author_name": "Mark Summerfield"
}</pre>
				Всё отлично сработало, запись сделана, валидацию мы прошли

			</li>
			<li>
				Попробуем сделать ошибку в заполнении
				<pre>
{"name": "Python 4",
"price": "1500000000000",
"author_name": "Mark"}

--->
{
    "price": [
        "Убедитесь, что вы ввели не более 7 цифры."
    ]
}</pre>
				Валидацию не прошли - так как неправильно заполнили одно поле (не прошли условие поля которое прописывали в модели Book)
			</li>
			<li>
				PUT - изменение данных, для того что бы пут был разрешёл, в urle необходимо добавить id обхекта, иначе будет -     "detail": "Метод \"PUT\" не разрешен."
				<br>url
				<pre>127.0.0.1:8000/book/4/</pre>
				<br>Body
				<pre>
{"name": "Пайтон 3",
"price": "150.00",
"author_name": "Марк Шумерфилд"
}</pre>
				Всё отлично сработало
			</li>
			<li>
				DELETE - удалмть - аналогично в PUT - указать ID - удалится запись
			</li>
			<li>
				Переходим во Views.py - переделаем так чтобы получать книги можно было всем - а изменять удалять возможно только авторизованные пользователи.
				<br>class BookViewSet(ModelViewSet): - меняем permission_classes
				<pre>
from rest_framework.permissions import ..., IsAuthenticatedOrReadOnly	

class BookViewSet(ModelViewSet):
	...
    # только авторизованные пользователи могут изменять записи - а смотреть могут все
    permission_classes = [IsAuthenticatedOrReadOnly]
	...</pre>
			</li>
			<li>
				Прогоним тесты которые уже есть, и тест сериализатора не пройдёт, так как не подкорректировали его.
				<br>store/tests/test_serializers.py - корректируем
				<pre>
# тест сериализатора
class BookSerializerTestCase(TestCase):
    def test_ok(self):
        # вводные данные
        book_1 = Book.objects.create(name='Test book 1', price=25,
                                     author_name='Author 1')
        book_2 = Book.objects.create(name='Test book 2', price=50,
                                     author_name='Author 2')
        # проверяемые данные
        data = BookSerializer([book_1, book_2], many=True).data

        # ожидаемые данные
        expected_data = [
            {
                'id': book_1.id,
                'name': 'Test book 1',
                'price': '25.00',
                'author_name': 'Author 1',
            },
            {
                'id': book_2.id,
                'name': 'Test book 2',
                'price': '50.00',
                'author_name': 'Author 2',
            },
        ]

        # само тестирование
        # (ожидаемые данные, данные из сериализатора)
        self.assertEqual(expected_data, data)</pre>
			</li>
			<li>
				Прогоним все тесты в приложении
				<pre>python manage.py test</pre>
				Всё должно работать
			</li>
			<li>
				В test_api.py - BooksApiTestCase - делаем post - тест (def test_post_create)
				<pre>
# проверка API  - см urls.py router.register(r'book', BookViewSet)
class BooksApiTestCase(APITestCase):
    # метод будет запускаться перед каждым тестом (методами test_get)
    def setUp(self):
        self.user = User.objects.create(username='test_username')
        ........

        ........

    def test_post_create(self):
        # book-list - получение всего списка router.register(r'book', BookViewSet)
        # book-detail - если бы необходимо было бы конкретную книгу
        url = reverse('book-list')

        # Данные которые попытаемся записать
        data = {"name": "Пайтон 3",
                "price": "150.00",
                "author_name": "Марк Шумерфилд"
                }

        # преобразуем наши данные в формат json
        json_data = json.dumps(data)

        # сделаем авторизацию, так как сейчас мы ограничели доступ
        self.client.force_login(self.user)

        # проверяемые данные, post запрос
        response = self.client.post(url, data=json_data,
                                    content_type='application/json')

        # Ожидаем страницу статус=201, сравниваем с ответным кодом
        self.assertEqual(status.HTTP_201_CREATED, response.status_code)</pre>
        		сделаем тест
        		<pre>python manage.py test store.tests.test_api.Book
sApiTestCase.test_post_create</pre>
				Должен пройти
			</li>
			<li>
				Усилим проверку в том же тесте - test_post_create (сравнивая количество книг/объектов до добавления и после добавления)
				<pre>
def test_get_search(self):

	# сравниваем в самом начале
    # количество книг до добавления - ожидаем 3
    self.assertEqual(3, Book.objects.all().count())

    .....

    # сравниваем в самом конце
    # сравниваем количество книг, ожидаем 4
        self.assertEqual(4, Book.objects.all().count())</pre>
        		<br>Делаем тест
        		<pre>python manage.py test store.tests.test_api.Book
sApiTestCase.test_post_create</pre>
			</li>
			<li>
				Пишем ещё один post - тест - проверка изменения записи (update)
				<br>Там же tests/test_api - BooksApiTestCase - добавляем def test_put_update(self):
				<pre>
def test_put_update(self):
    # book-list - получение всего списка router.register(r'book', BookViewSet)
    # book-detail - если бы необходимо было бы конкретную книгу
    # нам обязательно необходимо получить id - чтобы понять какую книгу менять, получаем в args
    url = reverse('book-detail', args=(self.book_1.id,))

    # Данные которые попытаемся записать / поменять цену
    data = {"name": self.book_1.name,
            "price": 1500,
            "author_name": self.book_1.author_name
            }

    # преобразуем наши данные в формат json
    json_data = json.dumps(data)

    # сделаем авторизацию, так как сейчас мы ограничели доступ
    self.client.force_login(self.user)

    # проверяемые данные, post запрос
    response = self.client.put(url, data=json_data,
                                content_type='application/json')

    # Ожидаем страницу статус=200, сравниваем с ответным кодом
    self.assertEqual(status.HTTP_200_OK, response.status_code)

    # перезаписываем данные изменённой книги 1
    self.book_1 = Book.objects.get(id=self.book_1.id)

    # проверяем изменилась ли цена
    self.assertEqual(1500, self.book_1.price)</pre>
    			Делаем тест
    			<pre>python manage.py test store.tests.test_api.Book
sApiTestCase.test_put_update</pre>
			</li>
			<li>
				Можно упрастить перезапись объекта, для этого есть специальный метод - refresh_from_db()
				<pre>
self.book_1 = Book.objects.get(id=self.book_1.id) - ЗАМЕНЯЯЕМ
НА --> это равносильные строчки (т.е одно и тоже)
# перезаписываем данные изменённой книги 1
self.book_1.refresh_from_db()</pre>
				Делаем тест
    			<pre>python manage.py test store.tests.test_api.Book
sApiTestCase.test_put_update</pre>
			</li>
		</ol>
	


&lt;





		<h3 class="title_text">[6]. Permissions</h3>
		<hr>

		<ol>

			<li>
				permission классы. Зайдем в базовый класс - IsAuthenticatedOrReadOnly (ctrl+лкм) - посмотрим как он устроен
				<pre>
# получаем из реквеста метод
# есть ли этот метод в SAFE_METHODS = ('GET', 'HEAD', 'OPTIONS')
request.method in SAFE_METHODS or
request.user and # получаем инфу о пользователе
request.user.is_authenticated	# проверяем авторизован ли пользователь

# полный код
        return bool(
            request.method in SAFE_METHODS or
            request.user and
            request.user.is_authenticated
        )

#Если метод ('GET', 'HEAD', 'OPTIONS') - будет True - и запрещать пользователю ничего не будеи
# или берем инфу о пользователе и он зарегестрирован  - тогда и метод PUT DELET сработает -True
# иначе будет False</pre>
			</li>
			<li>
				В допишем в модели Book - поле владельца книги
				<pre>
from django.contrib.auth.models import User

class Book(models.Model):
	....
    # owner - владелец
    owner = models.ForeignKey(User, on_delete=models.SET_NULL,
                              null=True)</pre>
			</li>
			<li>
				Создадим и применим миграцию
			</li>
			<li>
				Cделаем так чтобы владелец книги создавался автоматичеки (брал из request.user и записывал в таблицу Book)
				<br>Посмотрим базовые классы - views.py - class BookViewSet (это наш)  -> class ModelViewSet -> class CreateModelMixin:
				<br>Оттуда возьмём метод def perform_create(self, serializer): - добавим его в наш class BookViewSet и немного изменим повидение (добавим)
				<br>views.py -  class BookViewSe:
				<pre>
# ModelViewSet - родительский класс
class BookViewSet(ModelViewSet):
	....
	# дополняем поведение при создании книги
    def perform_create(self, serializer):
        # В модель Book - в поле owner - присвоим инфу о пользователе
        serializer.validated_data['owner'] = self.request.user
        serializer.save()  # сохраняем</pre>
			</li>
			<li>
				Проверим работочпособность в тесте
				<br>tests/test_api.py - BooksApiTestCase - test_post_create - снизу добавим строчку print
				<pre>
# Вывод инфы о пользователе (из модели Book - поля owner - последней записи)
print(Book.objects.last().owner)</pre>
				Сделаем тест - наш пользователь по условию выше должен быть 'tets_username'
				<pre>python manage.py test store.tests.test_api.BooksApiTestCase.test_post_create</pre>
				<br>Заменим наш принт на проверку
				<pre>
# сравниваем поле owner (инфа владельца)
# сравниваем текущий пользователь = запись о владельце модели Book
self.assertEqual(self.user, Book.objects.last().owner)</pre>
			</li>
			<li>
				В store создадим permissions.py - в нём будет всё о разрешении пользователям что то делать
				<pre>
from rest_framework.permissions import BasePermission, SAFE_METHODS


Копируем базовый класс IsAuthenticatedOrReadOnly - переиминую его в наш, чтобы не запутаться
class MyIsOwnerOrReadOnly(BasePermission):

    def has_object_permission(self, request, view, obj):
        return bool(
            request.method in SAFE_METHODS or
            request.user and
            request.user.is_authenticated
        )

def has_object_permission(self, request, view, obj): # мы заменили
# просто поменяли 1 строчку - её взяли из базового BasePermission</pre>
				<br>has_permission 	- привязан к спику книг
				<br>has_object_permission - привязан к определённой записи у которой есть id, конкретной книги
			</li>
			<li>
				В наш новый класс MyIsOwnerOrReadOnly - добавим ещё одну проверку (что пользователь который хочет удалить или редактировать кингу является её владельцем) - в нижней строчке
				<pre>request.user.is_authenticated and obj.owner == request.user</pre>
				Полный класс
				<br>
				<pre>
class MyIsOwnerOrReadOnly(BasePermission):
    def has_object_permission(self, request, view, obj):
        return bool(
            request.method in SAFE_METHODS or
            request.user and
            request.user.is_authenticated and obj.owner == request.user
        )</pre>

			</li>
			<li>
				views.py - изменим в представлении BookViewSet - permission_classes - на свой класс
				<pre>
from store.permissions import MyIsOwnerOrReadOnly

class BookViewSet(ModelViewSet):
	...
    # только авторизованные пользователи и владельцы могут изменять записи - а смотреть могут все
    permission_classes = [MyIsOwnerOrReadOnly]</pre>
			</li>
			<li>
				Сделаем тесты test_api и будет ошибка в тесте tets_put_update
				<br>Для того что бы он прошёл необходимо добавить owner в setUp - в книге 1
				<pre>
class BooksApiTestCase(APITestCase):
    def setUp(self):
    ...
    self.book_1 = Book.objects.create(name='Test book 1', price=25,
                                      author_name='Автор 1', owner=self.user)
    ....</pre>
			</li>
			<li>
				Необходимо сделать негативный тест - class BooksApiTestCase(APITestCase):
				<pre>
# сценарий когда не владелец книги пытается изменить данные книги
def test_put_update_not_owner(self):
    # это будет не владелец книги
    self.user2 = User.objects.create(username='test_username2')
    url = reverse('book-detail', args=(self.book_1.id,))
    data = {"name": self.book_1.name,
            "price": 1500,
            "author_name": self.book_1.author_name
            }
    json_data = json.dumps(data)
    # авторизация не владельца книги
    self.client.force_login(self.user2)
    # проверяемые данные, post запрос
    response = self.client.put(url, data=json_data,
                               content_type='application/json')
    # Ожидаем страницу статус=403 - запрет доступа, сравниваем с ответным кодом
    self.assertEqual(status.HTTP_403_FORBIDDEN, response.status_code)
    # перезаписываем данные изменённой книги 1
    self.book_1.refresh_from_db()
    # проверяем изменилась ли цена - ожидаем что изменения не произойдёт
    self.assertEqual(25, self.book_1.price)
				</pre>
				Сделаем тест
				<pre>python manage.py test store.tests.test_api.BooksApiTestCase.test_put_update_not_owner</pre>
				Тест должен пройти
			</li>
			<li>
				В MyIsOwnerOrReadOnly - добавим ещё одну проверку, чтобы разрешать или удалять книги можно было ещё и админу
				<br>Во первых изменим название на MyIsOwnerOrStaffOrReadOnly, Saff - это по сути администратор/персонал сайта, переимоновывай в PyCharm - чтобы он переименовался во всех файлах включая views.py
				<br>Перейдём в базовый класс - class IsAdminUser(BasePermission): - и скопируем от туда - request.user.is_staff (то есть входные данные о пользователи = пользователь пресонал сайта)
				<br><br>Итого изменяем одну нижнюю строчку в permissions.py - MyIsOwnerOrStaffOrReadOnly - has_object_permission - добавив ещё одно сравнение данных о пользователе
				<pre>
class MyIsOwnerOrStaffOrReadOnly(BasePermission):
    def has_object_permission(self, request, view, obj):
    ......
    request.user.is_authenticated and 
	(obj.owner == request.user or request.user.is_staff)</pre>
			</li>
			<li>
				Сделаем все тесты BooksApiTestCase - проверим что ничего не поламалось
				<pre>
python manage.py test store.tests.test_api.BooksApiTestCase</pre>
			</li>
			<li>
				Добавим проверку but_staff
				<pre>
# сценарий когда не владелец книги пытается изменить данные книги
def test_put_update_not_owner_but_staff(self):
    # это будет не владелец книги, но админ
    self.user2 = User.objects.create(username='test_username2',
                                     is_staff=True)
    url = reverse('book-detail', args=(self.book_1.id,))
    data = {"name": self.book_1.name,
            "price": 1500,
            "author_name": self.book_1.author_name
            }
    json_data = json.dumps(data)
    # авторизация не владельца книги
    self.client.force_login(self.user2)
    # проверяемые данные, post запрос
    response = self.client.put(url, data=json_data,
                               content_type='application/json')
    # Ожидаем страницу статус=200 - всё ок, сравниваем с ответным кодом
    # 200 - потому что изменяет админ и должно получится
    self.assertEqual(status.HTTP_200_OK, response.status_code)
    # перезаписываем данные изменённой книги 1
    self.book_1.refresh_from_db()
    # проверяем изменилась ли цена - ожидаем что изменилось
    self.assertEqual(1500, self.book_1.price)</pre>
    			Всё тесты test_api - проходят
			</li>
		</ol>
	


&lt;





		<h3 class="title_text">[7]. Like, Bookmarks, Rating</h3>
		<hr>

		<ol>

			<li>
				Лайти, закладки, рейтинг
			</li>
			<li>
				В models.py  создадим модель, которая и будет хранить отношение между пользоваетлем и книгой
				<pre>
# Пользователь - книга
class UserBookRelation(models.Model):
    # оценка рейтинга - варианты выбора
    # 1 - то что хранится в базе, 2 - то что будет отображаться *на фронте, в админке)
    RATE_CHOICES = (
        (1, 'Очень плохо'),
        (2, 'Плохо'),
        (3, 'Средне'),
        (4, 'Хорошо'),
        (5, 'Отлично'),
    )

    # связь с пользователем
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='Пользователь')
    # связь с книгой
    book = models.ForeignKey(Book, on_delete=models.CASCADE, verbose_name='Кинга')
    # учёт лайков (True - +1, False = нет дайка)
    like = models.BooleanField(default=False, verbose_name='Лайк')
    # добавлена в закладки (избранное)
    is_bookmarks = models.BooleanField(default=False, verbose_name='Закладка')
    # рейтинг (оценка пользователя для книги)
    rate = models.PositiveSmallIntegerField(choices=RATE_CHOICES, null=True, verbose_name='Оценка')

    class Meta:
        verbose_name = 'Отношение пользователя к книге'
        verbose_name_plural = 'Отношения пользователей к книгам'</pre>
			</li>
			<li>
				Сделаем и применим миграцию
			</li>
			<li>


			</li>
			<li>
				Зарегистрирую модель в админке (и сразу настрою):
				<br>admin.py
				<pre>
from store.models import ..., UserBookRelation

class UserBookRelationAdmin(admin.ModelAdmin):
    list_display = ('id', 'user', 'book', 'like', 'is_bookmarks', 'rate')
    list_display_links = ('like', 'is_bookmarks', 'rate')
    search_fields = ('user', 'book')

admin.site.register(UserBookRelation, UserBookRelationAdmin)
</pre>
			</li>
			<li>
				Изменим метод str - для отношении - models.py - UserBookRelation
				<pre>
def __str__(self):
    return f'Пользователь:{self.user.username} - Книга:{self.book.name}, Рейтинг:{self.rate}'</pre>
			</li>
			<li>
				Сделаем так чтобы через ORM мы могли добраться до книги через пользователя (например к тем книгам к которые он лайкал) "Book - покажи мне кто где лайкал"<br>
				Для этого в Book - добавим поле с отношением ManyToMany
				<pre>
class Book(models.Model):
	...					
	# owner - владелец -один
    owner = models.ForeignKey(User, on_delete=models.SET_NULL,
                              null=True, related_name='my_books', verbose_name='Владелец')
    # читатель - много читателей
    readers = models.ManyToManyField(User, through='UserBookRelation',
                                     related_name='read_books', verbose_name='Читатели')</pre>
				<span class="spec">
					related_name = он необходим так как к User у нас 2 отношения (owner и readers)
					through= (англ. - через)
				</span>
			</li>
			<li>
				Сделаем и применим миграцию
			</li>
			<li>
				Подкорректируем - отображение в админке для модели Book - добавиви полe owner
				<br>В admin.py
				<pre>
class BookAdmin(admin.ModelAdmin):
    list_display = ('id', 'name', 'price', 'author_name', 'owner')
    list_display_links = ('id', 'name', 'price', 'author_name', 'owner')
...</pre>
			</li>
			<li>
				Зайдём в Django shell
				<pre>
python manage.py shell
from django.contrib.auth.models import User
user = User.objects.get(id=2)
user.username --> 'user1'
user.reas_books.all() --> &lt;QuerySet []>  # Book.readers (related_name='read_books')
user.my_books.all()  --> &lt;Book: Id 2: Документация Django>]> # # Book.owner (related_name='my_books')</pre>
				<br>
				<span class="spec">
					user.reas_books.all() - обращение через пользователя к полю Book - readers - по related_name='read_books' 
					<br>
					user.my_books.all() - обращение через пользователя к полю Book - owner - по related_name='my_books' 
				</span>
				<br>
			</li>
			<li>
				Создаём сериализатор для будущего представления рейтинга
				<br>serializers.py
				<pre>
from store.models import ..., UserBookRelation

class UserBookRelationSerializer(ModelSerializer):
    class Meta:
        model = UserBookRelation
        fields = ('book', 'like', 'is_bookmarks', 'rate')  # поля
        # 'user' - не будем добавлять, так как его можно взять из request.user.username</pre>
			</li>
			<li>
				Создаём предстаелние при помощи которого сможем всё это делать (лайкать, ставить рейтинг, добавлять закладки)
				<br>Во views.py - пишем класс представления (api)
				<pre>
class UserBooksRelationView(UpdateModelMixin,
                            GenericViewSet):
    # права
    permission_classes = [IsAuthenticated]  # только авторизованный
    # данные
    queryset = UserBookRelation.objects.all()
    serializer_class = UserBookRelationSerializer
    lookup_field = 'book'  # id книги

    # переопределим метод
    def get_object(self):
        # get_or_create (получить отношение если есть,
        #                создать его если нету)
        # obj - это объект
        # _ - created (создан или найден)
        # book_id - пришёл через lookup_field в виде словаря
        # Мы получаем доступ к модели UserBookRelation - через переданный параметр книги, и пользователя из request
        # если такой связи нет мы создадим её - get_or_create
        obj, _ = UserBookRelation.objects.get_or_create(user=self.request.user,
                                                        book_id=self.kwargs['book'])
        return obj</pre>
				lookup_field и get_object. Для каждого отношения (лайк+закладка+рейтинг) есть id, но оно бессмысленно, в отдельности, фронтенду, клиенту нет необходимости знать это id - для этого есть необходимость указывать id книги где будет обобщённая информация?
				<br>
				<span class="spec">
					Разберись с get objects
				</span>
			</li>
			<li>
				Добавим маршнут api для представления UserBooksRelationView
				<br>books/urls.py
				<pre>
from store.views import ..., .., UserBooksRelationView

router.register(r'book_relation', UserBooksRelationView)</pre>
			</li>
			<li>
				Разрабатываем функционал через тест
				<br>store/tests/test_api.py - буддем создавать новый класс тестов - BooksRelationTestCase(APITestCase)
				<pre>
from store.models import Book, UserBookRelation

class BooksRelationTestCase(APITestCase):
    # метод будет запускаться перед каждым тестом (методами test_get)
    def setUp(self):
        self.user = User.objects.create(username='test_username')
        self.user2 = User.objects.create(username='test_username2')
        # вводные данные
        self.book_1 = Book.objects.create(name='Test book 1', price=25,
                                          author_name='Автор 1', owner=self.user)
        self.book_2 = Book.objects.create(name='Test book 2', price=50, author_name='Автор 2')

    def test_patch_like(self):
        # reverse - смотри в 404 странице в браузере, по name=''
        # там же смотри что нам нужно id книги
        url = reverse('userbookrelation-detail', args=(self.book_1.id,))
        # по дефолту лайк = False
        data = {"like": True,

                }
        json_data = json.dumps(data)

        # авторизуем пользователя 1
        self.client.force_login(self.user)
        # self.client - например клиент/браузер - который делает запрос нашему серверу
        response = self.client.patch(url, data=json_data,
                                     content_type='application/json')

        # Ожидаем страницу статус=200, сравниваем с ответным кодом
        self.assertEqual(status.HTTP_200_OK, response.status_code)

        # отношение каким  пользователем какая книга пролайкана
        relation = UserBookRelation.objects.get(user=self.user,
                                                book=self.book_1)

        # ожидаем что лайк будет True
        self.assertEqual(True, relation.like)
    	# self.assertTrue(relation.like)</pre>
				<span class="spec">
					patch - запрост. то же что и put (обновление данных модели) только передавать можно не всю запись(обьект) а отдельное поле лайк/нелайк, закладка/незакалдка, рейтинг1/2/3/4/5
				</span>
			</li>
			<li>
				Добавим тест - закладки - test_api.py - class BooksRelationTestCase(APITestCase):
				<pre>
def test_patch_is_bookmarks(self):
    # reverse - смотри в 404 странице в браузере, по name=''
    # там же смотри что нам нужно id книги
    url = reverse('userbookrelation-detail', args=(self.book_1.id,))
    # по дефолту лайк = False
    data = {
        "is_bookmarks": True,
            }
    json_data = json.dumps(data)

    # авторизуем пользователя 1
    self.client.force_login(self.user)
    # self.client - например клиент/браузер - который делает запрос нашему серверу
    response = self.client.patch(url, data=json_data,
                                 content_type='application/json')

    # Ожидаем страницу статус=200, сравниваем с ответным кодом
    self.assertEqual(status.HTTP_200_OK, response.status_code)

    # отношение каким пользователем какая книга добавлена в закладки
    relation = UserBookRelation.objects.get(user=self.user,
                                            book=self.book_1)

    # ожидаем что добавится в закладки
    self.assertEqual(True, relation.is_bookmarks)
    # self.assertTrue(relation.is_bookmarks)</pre>
			</li>
			<li>
				Сделаем тест на рейтинг
				<pre>
def test_patch_rate(self):
    # reverse - смотри в 404 странице в браузере, по name=''
    # там же смотри что нам нужно id книги
    url = reverse('userbookrelation-detail', args=(self.book_1.id,))
    # по дефолту рейтинг = null
    data = {
        "rate": 5,
            }
    json_data = json.dumps(data)

    # авторизуем пользователя 1
    self.client.force_login(self.user)
    # self.client - например клиент/браузер - который делает запрос нашему серверу
    response = self.client.patch(url, data=json_data,
                                 content_type='application/json')

    # Ожидаем страницу статус=200, сравниваем с ответным кодом
    self.assertEqual(status.HTTP_200_OK, response.status_code)

    # отношение каким пользователем какой книге поставит рейтинг
    relation = UserBookRelation.objects.get(user=self.user,
                                            book=self.book_1)

    # ожидаем что рейтинг будет 5
    self.assertEqual(5, relation.rate)</pre>
    			Все тесты - проходят
			</li>
			<li>
				Сделаем негативный сценарий для рейтенга в тестах (если например поставили рейтинг 6 а у нас может быть только  от 1 до 5  включительно +null по дефолту)
				<pre>
def test_patch_rate_wrong(self):
    # reverse - смотри в 404 странице в браузере, по name=''
    # там же смотри что нам нужно id книги
    url = reverse('userbookrelation-detail', args=(self.book_1.id,))
    # по дефолту рейтинг = null
    # 6 - может быть по условию модели
    data = {
        "rate": 6,
            }
    json_data = json.dumps(data)

    # авторизуем пользователя 1
    self.client.force_login(self.user)
    # self.client - например клиент/браузер - который делает запрос нашему серверу
    response = self.client.patch(url, data=json_data,
                                 content_type='application/json')

    # Ожидаем страницу статус=200, сравниваем с ответным кодом
    <span class="spec">
    # третий аргумент - если что-то не сошлось (какой сделать принт)
    # то есть 3-й аргумент скажет, почему не вышло получить 200
    self.assertEqual(status.HTTP_200_OK, response.status_code, response.data)</span>

    # отношение каким пользователем какой книге поставит рейтинг
    relation = UserBookRelation.objects.get(user=self.user,
                                            book=self.book_1)

    # ожидаем что рейтинг будет 5 (то есть он не изменится с прошлого теста, так как 6 не может быть)
    self.assertEqual(5, relation.rate)
				</pre>
				Сделаем тест
				<pre>python manage.py test store.tests.test_api.BooksRelationTestCase</pre>
				<br>Третий аргумент - response.data - нам выдаст в консоле
				<pre>
AssertionError: 200 != 400 : {'rate': [ErrorDetail(string='Значения 6 нет среди допустимых вариантов.', code='invalid_choice')]}</pre>
				<br>Мы даже не писали никакой валидации, всё есть из коробки классов представления, сериализаторов..
			</li>
		</ol>
	


&lt;





		<h3 class="title_text">[8]. Annotate и агрегация</h3>
		<hr>

		<ol>
			<li>
				Будем выводить количество лайков при помощи annotate. Нужно понимать что это один из способов вывода и не обязательно самый хороший в том или ином случае, но он точно поможет сократить количество SQL запросов в базу
			</li>
			<li>
				изменим сериализатор - BookSerializer  -и укажем какие поля мы будем выводить (на данный момент __all__ - все поля), так же сделаем вывод количества лайков через сериализатор
				<pre>
from rest_framework.serializers import ModelSerializer

# ModelSerializer - родительский класс
class BookSerializer(ModelSerializer):
    # поле количество лайков
    likes_count = serializers.SerializerMethodField()

    class Meta:
        model = Book
        fields = ('id', 'name', 'price', 'author_name', 'likes_count')  # поля

    # считаем количество лайков - ручным способом
    # instance - та самая книга, которую в данный момент сериализуем
    def get_likes_count(self, instance):
        # считаем объекты - выбранная книга, у которой есть отношение like=True
        return UserBookRelation.objects.filter(book=instance, like=True).count()</pre>
			</li>
			<li>
				Корректируем тест сериализатора BookSerializer  - добавив поле likes_count в expected_data( то что будем ожидать)
				<br>test_serializers.py - class BookSerializerTestCase(TestCase):
				<pre>
# тест сериализатора
class BookSerializerTestCase(TestCase):
    def test_ok(self):
        # вводные данные
        book_1 = Book.objects.create(name='Test book 1', price=25,
                                     author_name='Author 1')
        book_2 = Book.objects.create(name='Test book 2', price=50,
                                     author_name='Author 2')
        # проверяемые данные
        data = BookSerializer([book_1, book_2], many=True).data

        # ожидаемые данные
        expected_data = [
            {
                'id': book_1.id,
                'name': 'Test book 1',
                'price': '25.00',
                'author_name': 'Author 1',
                'likes_count': 0
            },
            {
                'id': book_2.id,
                'name': 'Test book 2',
                'price': '50.00',
                'author_name': 'Author 2',
                'likes_count': 0
            },
        ]

        # само тестирование
        # (ожидаемые данные, данные из сериализатора)
        self.assertEqual(expected_data, data)</pre>
				Сделаем тест - должно всё работать
				<pre>python manage.py test store.tests.test_serializ
ers</pre>
			</li>
			<li>
				В этот же тест сериальзатора добавим пользователей
				<br>test_serializers.py - class BookSerializerTestCase(TestCase):
				<pre>
from django.contrib.auth.models import User
from store.models import ..., UserBookRelation

# тест сериализатора
class BookSerializerTestCase(TestCase):
    def test_ok(self):
        # вводные данные
        user1 = User.objects.create(username='username1')
        user2 = User.objects.create(username='username2')
        user3 = User.objects.create(username='username3')
        book_1 = Book.objects.create(name='Test book 1', price=25,
                                     author_name='Author 1')
        book_2 = Book.objects.create(name='Test book 2', price=50,
                                     author_name='Author 2')

        # все пользователи поставили лайк на первую книгу
        UserBookRelation.objects.create(user=user1, book=book_1, like=True)
        UserBookRelation.objects.create(user=user2, book=book_1, like=True)
        UserBookRelation.objects.create(user=user3, book=book_1, like=True)

        # 2 пользователя поставили лайк на вторую книгу
        UserBookRelation.objects.create(user=user1, book=book_2, like=True)
        UserBookRelation.objects.create(user=user2, book=book_2, like=False)
        UserBookRelation.objects.create(user=user3, book=book_2, like=True)

        # проверяемые данные
        data = BookSerializer([book_1, book_2], many=True).data

        # ожидаемые данные
        expected_data = [
            {
                'id': book_1.id,
                'name': 'Test book 1',
                'price': '25.00',
                'author_name': 'Author 1',
                'likes_count': 3  # будем ожидать 3 лайка
            },
            {
                'id': book_2.id,
                'name': 'Test book 2',
                'price': '50.00',
                'author_name': 'Author 2',
                'likes_count': 2  # будем ожидать 3 лайка
            },
        ]

        # само тестирование
        # (ожидаемые данные, данные из сериализатора)
        self.assertEqual(expected_data, data)</pre>
			</li>
			<li>
				В сериализатор - BookSerializer - добавим поле которое будет получать количество лайков через annotate
				<br>serializers.py - class BookSerializer(ModelSerializer):
				<pre>
class BookSerializer(ModelSerializer):
	....					
    # поле количество лайков через annotated
    annotated_likes=serializers.IntegerField(read_only=True)
    
    class Meta:
        model = Book
        fields = (....., 'annotated_likes')  # поля</pre>
			</li>
			<li>
				Делаем annotated queryset через тесты
				<br>test_serializers.py - class BookSerializerTestCase(TestCase):
				<pre>
from django.db.models import Count, Case, When

# тест сериализатора
class BookSerializerTestCase(TestCase):
    def test_ok(self):
        # вводные данные
        user1 = User.objects.create(username='username1')
        user2 = User.objects.create(username='username2')
        user3 = User.objects.create(username='username3')
        book_1 = Book.objects.create(name='Test book 1', price=25,
                                     author_name='Author 1')
        book_2 = Book.objects.create(name='Test book 2', price=50,
                                     author_name='Author 2')

        # все пользователи поставили лайк на первую книгу
        UserBookRelation.objects.create(user=user1, book=book_1, like=True)
        UserBookRelation.objects.create(user=user2, book=book_1, like=True)
        UserBookRelation.objects.create(user=user3, book=book_1, like=True)

        # 2 пользователя поставили лайк на вторую книгу
        UserBookRelation.objects.create(user=user1, book=book_2, like=True)
        UserBookRelation.objects.create(user=user2, book=book_2, like=False)
        UserBookRelation.objects.create(user=user3, book=book_2, like=True)

        # проверяемые данные
        books = Book.objects.all().annotate(
            # annotated_likes(Считаем лайки(Case(когда будет работать(Если стоит лайк, возвращаем 1)
            # userbookrelation__like - через книгу пробираемся к relation, через relation к лайку, then=1)
            annotated_likes=Count(Case(When(userbookrelation__like=True, then=1)))
        ).order_by('id')  # без сортировки работать не будет
        data = BookSerializer(books, many=True).data

        # ожидаемые данные
        expected_data = [
            {
                'id': book_1.id,
                'name': 'Test book 1',
                'price': '25.00',
                'author_name': 'Author 1',
                'likes_count': 3,  # будем ожидать 3 лайка
                'annotated_likes': 3  # будем ожидать 3 лайка
            },
            {
                'id': book_2.id,
                'name': 'Test book 2',
                'price': '50.00',
                'author_name': 'Author 2',
                'likes_count': 2,  # будем ожидать 2 лайка
                'annotated_likes': 2,  # будем ожидать 2 лайка
            },
        ]

        # само тестирование
        # (ожидаемые данные, данные из сериализатора)
        self.assertEqual(expected_data, data)</pre>
			</li>
			<li>
				Во views.py в представление - BookViewSet - добавим изменим queryset, чтобы отображались количество лайков (обрати внимание количество лайков не будет в модели Book они хранятся в другой модели, плюч ко всему количество лайков там хранится только для каждого пользователя, а нам необходимо вывести общее количество лайков от всех пользователей)
				<pre>
from django.db.models import Count, Case, When

class BookViewSet(ModelViewSet):
    # объекты
    queryset = Book.objects.all().annotate(
            # annotated_likes(Считаем лайки(Case(когда будет работать(Если стоит лайк, возвращаем 1)
            # userbookrelation__like - через книгу пробираемся к relation, через relation к лайку, then=1)
            annotated_likes=Count(Case(When(userbookrelation__like=True, then=1)))
        )	
	....</pre>
			</li>
			<li>
				сделаем все тесты - есть множестов ошибок
				правим тесты 
				<br>def test_patch_rate_wrong(self): - изменяем на 404
				<br>read_only=True - в сериализатори - BookSerializer - annotated_likes
				<br>def test_get(self): - необходимо создать books = Book.obkects.all().annotate...вся для лайков
				<pre>
def test_get(self):
    # book-list - получение всего списка router.register(r'book', BookViewSet)
    # book-detail - если бы необходимо было бы конкретную книгу
    url = reverse('book-list')

    # self.client - например клиент/браузер - который делает запрос нашему серверу
    response = self.client.get(url)

    # проверяемые данные
    books = Book.objects.all().annotate(
        # annotated_likes(Считаем лайки(Case(когда будет работать(Если стоит лайк, возвращаем 1)
        # userbookrelation__like - через книгу пробираемся к relation, через relation к лайку, then=1)
        annotated_likes=Count(Case(When(userbookrelation__like=True, then=1)))
    )

    # сравниваем то что вводные данные сходятся с выходными
    serializer_data = BookSerializer(books, many=True).data

    # Ожидаем страницу статус=200, сравниваем с ответным кодом
    self.assertEqual(status.HTTP_200_OK, response.status_code)

    # serializer_data - входные данные, response.data - выходные данные
    # Мы ожидаем что должно быть serializer_data, и проверяем равен ли ей response.data
    self.assertEqual(serializer_data, response.data)</pre>
				<br>def test_get_search(self): - необходимо создать books = Book.obkects.filter(id__in=[]).annotate...вся для лайков
				<pre>
def test_get_search(self):
    # количество книг до добавления - ожидаем 3
    self.assertEqual(3, Book.objects.all().count())

    # book-list - получение всего списка router.register(r'book', BookViewSet)
    # book-detail - если бы необходимо было бы конкретную книгу
    url = reverse('book-list')

    # условия поиска
    response = self.client.get(url, data={'search': 'Автор 1'})

    # проверяемые данные
    books = Book.objects.filter(id__in=[self.book_1.id, self.book_3.id]).annotate(
        # annotated_likes(Считаем лайки(Case(когда будет работать(Если стоит лайк, возвращаем 1)
        # userbookrelation__like - через книгу пробираемся к relation, через relation к лайку, then=1)
        annotated_likes=Count(Case(When(userbookrelation__like=True, then=1)))
    )

    serializer_data = BookSerializer(books, many=True).data

    # Ожидаем страницу статус=200, сравниваем с ответным кодом
    self.assertEqual(status.HTTP_200_OK, response.status_code)
    # Мы ожидаем что должно быть serializer_data, и проверяем равен ли ей response.data
    self.assertEqual(serializer_data, response.data)</pre>

			</li>
			<li>
				Будем выводить средний рейтинг книги
				<br>serializers.py - class BookSerializer - добавляем поле raiting
				<pre>
class BookSerializer(ModelSerializer):
	....
    # рейтинг по типу 1.77, 4,50, 3,93
    rating = serializers.DecimalField(max_digits=3, decimal_places=2, read_only=True)

    class Meta:
        model = Book
        fields = (..., 'rating')  # поля					
				</pre>

			</li>
			<li>
				Изменяем тесты, добавич поле rating - и добавив аннотацию в books queriset, так же расставим рейтинг пользователями
				<br>test_serializers.py
				<pre>
from django.db.models import ..., Avg

# тест сериализатора
class BookSerializerTestCase(TestCase):
    def test_ok(self):
        # вводные данные
        user1 = User.objects.create(username='username1')
        user2 = User.objects.create(username='username2')
        user3 = User.objects.create(username='username3')
        book_1 = Book.objects.create(name='Test book 1', price=25,
                                     author_name='Author 1')
        book_2 = Book.objects.create(name='Test book 2', price=50,
                                     author_name='Author 2')

        # все пользователи поставили лайк на первую книгу, и поставили рейтинг 5
        UserBookRelation.objects.create(user=user1, book=book_1, like=True,
                                        rate=5)
        UserBookRelation.objects.create(user=user2, book=book_1, like=True,
                                        rate=5)
        UserBookRelation.objects.create(user=user3, book=book_1, like=True,
                                        rate=5)

        # 2 пользователя поставили лайк на вторую книгу, и поставили разный рейтинг
        UserBookRelation.objects.create(user=user1, book=book_2, like=True,
                                        rate=3)
        UserBookRelation.objects.create(user=user2, book=book_2, like=False)
        UserBookRelation.objects.create(user=user3, book=book_2, like=True,
                                        rate=4)

        # проверяемые данные
        books = Book.objects.all().annotate(
            # annotated_likes(Считаем лайки(Case(когда будет работать(Если стоит лайк, возвращаем 1)
            # userbookrelation__like - через книгу пробираемся к relation, через relation к лайку, then=1)
            annotated_likes=Count(Case(When(userbookrelation__like=True, then=1))),
            # аннотация рейтинга
            # Avg - average - среднее значение
            rating=Avg('userbookrelation__rate'),
        ).order_by('id')
        data = BookSerializer(books, many=True).data

        # ожидаемые данные
        expected_data = [
            {
                'id': book_1.id,
                'name': 'Test book 1',
                'price': '25.00',
                'author_name': 'Author 1',
                'likes_count': 3,  # будем ожидать 3 лайка
                'annotated_likes': 3,  # будем ожидать 3 лайка
                'rating': '5.00',
            },
            {
                'id': book_2.id,
                'name': 'Test book 2',
                'price': '50.00',
                'author_name': 'Author 2',
                'likes_count': 2,  # будем ожидать 2 лайка
                'annotated_likes': 2,  # будем ожидать 2 лайка
                'rating': '3.50',
            },
        ]

        # само тестирование
        # (ожидаемые данные, данные из сериализатора)
        self.assertEqual(expected_data, data)</pre>
			</li>
			<li>
				Проверим все тесты - все 14 тестов должны пройти
				<pre>python manage.py test</pre>
			</li>
			<li>
				В представление - BookViewSet - копируем books (с аннотациями рейтинга и лайков)
				<pre>
class BookViewSet(ModelViewSet):
    # объекты
    queryset = Book.objects.all().annotate(
            annotated_likes=Count(Case(When(userbookrelation__like=True, then=1))),
            rating=Avg('userbookrelation__rate'),
        ).order_by('id')
    	.....</pre>
			</li>
			<li>
				Запустим все тесты - теперь будет две ошибки тестов api - так как мы изменили представление api - необходимо добавить аннотацию рейтинга в тесты api
				<br>test_api.py - test_get, test_get_search
				<pre>
....
......annotate(
            annotated_likes=Count(Case(When(userbookrelation__like=True, then=1))),
            rating=Avg('userbookrelation__rate'),
        ).order_by('id')
.....</pre>
				Сделаем все тесты и всё должно пройти
			</li>
		</ol>
	


&lt;






		<h3 class="title_text">[9]. Оптимизация SQL запросов в ORM</h3>
		<hr>

		<ol>

			<li>
				Будем оптимизировать SQL запросы, в нашм случае ORM (так как к базе данных мы обращаемся через django ORM)
				<br>Оптимизация в том смысле чтобы сократить количество SQL запросов к базе данных, путём удаления дубликатов этиъ запросов
			</li>
			<li>
				<ul>
					<span class="spec">
						Установка Django Debub Toolbar
					</span>
					<br><a href="https://django-debug-toolbar.readthedocs.io/en/latest/">Документация</a>
					<br><a href="https://github.com/jazzband/django-debug-toolbar">github</a>
					<li>
						В PyCharm - в окружени устанавливаем пакет - django-debug-toolbar
						<br>На данный момент полседняя версия 3.8.1
						<br><br>Через командную строку
						<pre>python -m pip install django-debug-toolbar</pre>
					</li>
					<li>
						Добавляем django-debug-toolbar в INSTALLED_APPS - settings.py
						<pre>
INSTALLED_APPS = [
	....
    'django.contrib.staticfiles',

    "debug_toolbar",  # debug_toolbar
    ...
]</pre>
					</li>
					<li>
						settings.py  - проверим STATIC_URL - должно быть по стандарту
						<pre>STATIC_URL = 'static/'</pre>
					</li>
					<li>
						urls.py - необходимо добавить:
						<pre>
from django.conf import settings

if settings.DEBUG:
    import debug_toolbar
    urlpatterns = [
        path('__debug__/', include('debug_toolbar.urls')),
    ] + urlpatterns</pre>
					</li>
					<li>
						settings.py - доабвим INTERNAL_IPS 
						<pre>
INTERNAL_IPS = [
    "127.0.0.1",
]</pre>
					</li>
					<li>
						settings.py - debug - 
					</li>
					<li>
						Пробуем запустить отладочный django web сервер (runserver) - Должна появится кнопка - DjDT
					</li>
				</ul>
			</li>
			<li>
				Самое важное для нас это SQL - смотрим количество запросов и видим что много дублигатов для получения лайков, подкорректируем сериализатор - class BookSerializer(ModelSerializer): - уберём - likes_count и def get_likes_count(self, instance): - так как лайки мы получаем через анотацию
				<br>serializers.py - BookSerializer
				<pre>
# ModelSerializer - родительский класс
class BookSerializer(ModelSerializer):
	# поле количество лайков через annotated
    annotated_likes = serializers.IntegerField(read_only=True)
    # рейтинг по типу 1.77, 4,50, 3,93
    rating = serializers.DecimalField(max_digits=3, decimal_places=2, )

    class Meta:
        model = Book
        fields = ('id', 'name', 'price', 'author_name', 'annotated_likes', 'rating')  # поля</pre>
        		По итогу смотрим вместо 5 SQL - остался 1 запрос!
			</li>
			<li>
				сделаем все тесты и посмотрим какие упали
				<br>Везде удаляем поле likes_count - так как мы им больше не пользуемся
			</li>
			<li>
				<span class="spec">
					read_only=True - поле только для чтения
				</span>
			</li>
			<li>
				Добавим в сериализатор BookSerializer - ещё поле - имя владельца книги
				<pre>
# ModelSerializer - родительский класс
class BookSerializer(ModelSerializer):
    # поле количество лайков через annotated
    annotated_likes = serializers.IntegerField(read_only=True)
    # рейтинг по типу 1.77, 4,50, 3,93
    rating = serializers.DecimalField(max_digits=3, decimal_places=2, )
    # имя владельца
    # read_only=True - поле только для чтение
    owner_name = serializers.CharField(source='owner.username', default='',
                                       read_only=True)

    class Meta:
        model = Book
        fields = ('id', 'name', 'price', 'author_name',
                  'annotated_likes', 'rating', 'owner_name')  # поля</pre>
			</li>
			<li>
				Обновим страницу - http://127.0.0.1:8000/book/  - в DEBUG TULLBAR - SQL  - видич что когличество запросов увеличилось в разы, как раз для каждой записи, там где есть влдаелец, каждый раз будет отдельный SQL запрос в базу
			</li>
			<li>
				<span class="spec">
					secect_related('поле') - для увеличения производительности, необходимо в том случае когда записей много
				</span>
				<br>select_related(*fields)¶
Возвращает QuerySet, который будет «следовать» отношениям внешнего ключа, выбирая дополнительные данные связанного объекта при выполнении своего запроса. Это повышение производительности, которое приводит к одному более сложному запросу, но означает, что дальнейшее использование отношений внешнего ключа не потребует запросов к базе данных.
			</li>
			<li>
				Изменим одну строчку предатсвления - BookViewSet, добавив select_related
				<br>views.py - BookViewSet - queryset
				<pre>
class BookViewSet(ModelViewSet):
    # объекты
    queryset = Book.objects.all().annotate(
            annotated_likes=Count(Case(When(userbookrelation__like=True, then=1))),
            rating=Avg('userbookrelation__rate'),
        ).select_related('owner').order_by('id')					
	....</pre>
				<br>Пробуем обновить и видим всего один SQL (он стал немного медленней, но в общем с учётом того что раньше запросы были отдельно для каждой записи, это сильно сократит время на обработку и нагрузку на sql бызы)
			</li>
			<li>
				Вложенные словари json, напишем ещё один сериализатор BookReaderSerializer
				<br>serializers.py
				<pre>
from django.contrib.auth.models import User

class BookReaderSerializer(ModelSerializer):
    class Meta:
        model = User
        fields = ('first_name', 'last_name')</pre>
			</li>
			<li>
				В сериализатор BookSerializer - добавим поле readers
				<br>serializers.py - BookSerializer
				<pre>
class BookSerializer(ModelSerializer):
	....
	# читатели
    readers = BookReaderSerializer(many=True, read_only=True)

    class Meta:
    ....
    fields = (...,
              'readers', )  # поля</pre>
              <br>Пробуем обновить и увидем куча запросов
			</li>
			<li>
				В адинке добавлю last_name, first_name  к пользователям
			</li>
			<li>
				В админке добавим рейтинги лайки закладки к разным книгам
			</li>
			<li>
				http://127.0.0.1:8000/book/ -  смотрим запросы, для каждой записи Book - идёт отдельный запрос - по информации о пользователе
			</li>
			<li>
				<span class="spec">
					prefetch_related - почти тоже самое что и select_related - только используется там может быть много обхектов
				</span>
				<br>
				select_related - поле owner - ForeignKey
				<br>
				prefetch_related - поле readers - ManyToManyField
			</li>
			<li>
				В views.py - BookViewSet - queryset - добавлю prefetch_related - поля readers
				<pre>
class BookViewSet(ModelViewSet):
    queryset = Book.objects.all().annotate(
            annotated_likes=Count(Case(When(userbookrelation__like=True, then=1))),
            rating=Avg('userbookrelation__rate'),
        ).select_related('owner').prefetch_related('readers').order_by('id')
        ...</pre>
        		Количество запросово и время SQL запросов в разы меньше

			</li>
			<li>
				Тестируем - исправляем тест
				<br>test_serializers.py
				<pre>
# тест сериализатора
class BookSerializerTestCase(TestCase):
    def test_ok(self):
        # вводные данные
        user1 = User.objects.create(username='user1',
                                    first_name='Ivan', last_name='Petrov')
        user2 = User.objects.create(username='user2',
                                    first_name='Alex', last_name='Morozov')
        user3 = User.objects.create(username='user13',
                                    first_name='Oleg', last_name='Oleg')
        book_1 = Book.objects.create(name='Test book 1', price=25,
                                     author_name='Author 1',
                                     owner=user1)
        book_2 = Book.objects.create(name='Test book 2', price=50,
                                     author_name='Author 2',
                                     owner=user2)

        # все пользователи поставили лайк на первую книгу, и поставили рейтинг 5
        UserBookRelation.objects.create(user=user1, book=book_1, like=True,
                                        rate=5)
        UserBookRelation.objects.create(user=user2, book=book_1, like=True,
                                        rate=5)
        UserBookRelation.objects.create(user=user3, book=book_1, like=True,
                                        rate=5)

        # 2 пользователя поставили лайк на вторую книгу, и поставили разный рейтинг
        UserBookRelation.objects.create(user=user1, book=book_2, like=True,
                                        rate=3)
        UserBookRelation.objects.create(user=user2, book=book_2, like=False)
        UserBookRelation.objects.create(user=user3, book=book_2, like=True,
                                        rate=4)

        # проверяемые данные
        books = Book.objects.all().annotate(
            # annotated_likes(Считаем лайки(Case(когда будет работать(Если стоит лайк, возвращаем 1)
            # userbookrelation__like - через книгу пробираемся к relation, через relation к лайку, then=1)
            annotated_likes=Count(Case(When(userbookrelation__like=True, then=1))),
            # аннотация рейтинга
            # Avg - average - среднее значение
            rating=Avg('userbookrelation__rate'),
        ).order_by('id')
        data = BookSerializer(books, many=True).data

        # ожидаемые данные
        expected_data = [
            {
                'id': book_1.id,
                'name': 'Test book 1',
                'price': '25.00',
                'author_name': 'Author 1',
                'annotated_likes': 3,  # будем ожидать 3 лайка
                'rating': '5.00',
                'owner_name': 'user1',
                'readers': [
                    {
                        'first_name': 'Ivan',
                        'last_name': 'Petrov',
                    },
                    {
                        'first_name': 'Alex',
                        'last_name': 'Morozov',
                    },
                    {
                        'first_name': 'Oleg',
                        'last_name': 'Oleg',
                    },
                ]
            },
            {
                'id': book_2.id,
                'name': 'Test book 2',
                'price': '50.00',
                'author_name': 'Author 2',
                'annotated_likes': 2,  # будем ожидать 2 лайка
                'rating': '3.50',
                'owner_name': 'user2',
                'readers': [
                    {
                        'first_name': 'Ivan',
                        'last_name': 'Petrov',
                    },
                    {
                        'first_name': 'Alex',
                        'last_name': 'Morozov',
                    },
                    {
                        'first_name': 'Oleg',
                        'last_name': 'Oleg',
                    },
                ]
            },
        ]

        # само тестирование
        # (ожидаемые данные, данные из сериализатора)
        self.assertEqual(expected_data, data)</pre>
        		тест должен пройти
			</li>
			<li>
				<span class="spec">
					Есть проблемы с api тестами - реши позже
				</span>
		</ol>
	


&lt;






		<h3 class="title_text">[10]. Кеширующие поля</h3>
		<hr>

		<ol>

			<li>
				Кэширующие поля - будем делать кэш рейтинга, чтобы при каждом запросе н было вычислений из базы данных
			</li>
			<li>
				В models  - Book - добавим поле рейтинга. models.py
				<pre>
class Book(models.Model):
	# рейтинг 3.68/4.17/5.00
    rating = models.DecimalField(max_digits=3, decimal_places=2, default=None, null=True)</pre>
			</li>
			<li>
				Что бы поле можно было добавить необходимо - убрать аннотацию rating - во view.py -  rating=Avg('userbookrelation__rate'),
				<pre>
class BookViewSet(ModelViewSet):
    queryset = Book.objects.all().annotate(
            annotated_likes=Count(Case(When(userbookrelation__like=True, then=1)))
        ).select_related('owner').prefetch_related('readers').order_by('id')
        ....</pre>
			</li>
			<li>
# рейтинг 3.68
    rating = models.DecimalField(max_digits=3, decimal_places=2, default=None, null=True)</li>
    		<li>
    			добавим логику в logic.py - предварительно удвалив всё заранее в нём
    			<pre>
from store.models import UserBookRelation

from django.db.models import Avg
from store.models import UserBookRelation


# получение рейтинга
def set_rating(book):
    # book - это определённая книга
    # aggregate - сами расчёты
    # class(models.py) UserBookRelation/ rate это поле - UserBookRelation
    rating = UserBookRelation.objects.filter(book=book).aggregate(rating=Avg('rate')).get('rating')
    # записываем в поле rating- переменную rating
    book.rating = rating
    book.save()  # сохраняем книгу</pre>
    		</li>
    		<li>
    			Напришем тесты для logic.py
    		</li>
    		<li>
    			В models.py  - class UserBookRelation - добавим def save - в самом низу
    			<pre>
from store.logic import set_rating

class UserBookRelation(models.Model):
	.....
    def save(self, *args, **kwargs):
	    # через super - мы обращаемся к родительскому элементу Models
	    # чтобы не сломать стандартные поля
	    # делаем super -чтобы наш def save тоже вызвался
	    super().save(*args, **kwargs)
	    set_rating(self.book)</pre>
    		</li>
    		<li>
    			Отслеживаем изменение полей, сравнение self.pk
    			<br>
    			Там же в def save - добавим old_rating/nen rating
    			<pre>
def save(self, *args, **kwargs):
    # локальный импорт
    from store.logic import set_rating

    old_rating = self.rate

    # через super - мы обращаемся к родительскому элементу Models
    # чтобы не сломать стандартные поля
    # делаем super -чтобы наш def save тоже вызвался
    super().save(*args, **kwargs)

    new_rating = self.rate

    # если old - не как - new, будем делать пересчёт
    if old_rating != new_rating:
        set_rating(self.book)</pre>
    		</li>
    		<li>
    			там же добави сравнение pk записи
    			<pre>
def save(self, *args, **kwargs):
    # локальный импорт
    from store.logic import set_rating

    creating = not self.pk
    old_rating = self.rate

    # через super - мы обращаемся к родительскому элементу Models
    # чтобы не сломать стандартные поля
    # делаем super -чтобы наш def save тоже вызвался
    super().save(*args, **kwargs)

    new_rating = self.rate

    # если old - не как - new, будем делать пересчёт
    if old_rating != new_rating or creating:
        set_rating(self.book)</pre>
    		</li>
    		<li>
    			Корректируем все тесты
    		</li>
    		<li>
    			Чтобы всё заработало необходимо сделать миграции
    		</li>
		</ol>
	


&lt;










		<h3 class="title_text">[0]. Название</h3>
		<hr>

		<ol>

			<li>

			</li>
			<li>

			</li>
			<li>

			</li>
			<li>

			</li>
		</ol>
	


&lt;


		



	</div><!-- container-md all -->
&lt; &lt; &lt;

<!-- # Ctrl + Alt + L  -->





<!-- JS Bootstrap 5 -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-gtEjrD/SeCtmISkJkNUaaKMoLD0//ElJ19smozuHV6z3Iehds+3Ulb9Bn9Plx0x4" crossorigin="anonymous"></script>


</body>
</html>


