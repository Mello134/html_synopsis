<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- css bootstrap 5 -->
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x" crossorigin="anonymous">

	<title>Senjor Pomidor Youtube</title>

	<style type="text/css">
		
		pre{
			color: black;
			background: #fcfce8;
			margin-right: 30px;
			margin-left: 15px;
			margin-bottom: 2px;
			margin-top: 5px;
		}
		
		.all{
			background: #1c1c1c;
			color: white;
			#003802
		}
		
		body{
			background: #c0d7d8;
		}
		
		.spec {
			font-size: 18px;
			letter-spacing: .2em;
			font-weight: 500;
/*			text-transform: uppercase;*/
			color: #ff7575;
			margin-top: 15px;
			margin-bottom: 2px;
		}

		.title_text {
			letter-spacing: .1em;
			font-weight: 500;
			color: #f2cb71;
			font-size: 25px;

		}

	</style>


&lt; &lt; &lt;
</head>


<body>

	<p><a href="https://www.youtube.com/playlist?list=PLyaCd9XYVI9ACOnDvyto01CH6dx35PG-t">SPD YT 1</a></p>
	<p><a href="https://www.youtube.com/playlist?list=PLyaCd9XYVI9DiMvYl-8OdZk7ktc6NQWrb">SPD YT 2</a></p>
	<p><a href="https://www.youtube.com/playlist?list=PLyaCd9XYVI9BQXrJU3zw3PGs_vcWw7_CD/">SPD YT 3</a></p>
	
	<p><a href="https://django.fun/ru/articles/tutorials/">Статьи о Django</a></p>

	<p><a href="https://django.fun/ru/docs/">Документация по фреймворку и библиотекам Django</a></p>
	
	<p><a href="https://pypi.org/">pypi.org</a></p>


	<div class="container-md all"><!-- container-md all ОБЩИЙ -->
		<br>
		<h1 class="title_text border">Senjor Pomidor Youtube</h1>
		<hr>
		<br><br><br>


		<!-- <img src="images\avtoblog\host.jpg" class="img-fluid"><br> -->





		<h1 class="title_text border">I. Мини-курс Django</h1>
		<hr>
		<br><br>

		
		<h3 class="title_text">[1]. Установка и старт проекта</h3>
		<hr>

		<ol>

			<li>
				Установка интерпритатора Python
			</li>
			<li>
				Установка редактора кода IDE. PyCharm, SublimeText
			</li>
			<li>
				Создание проекта, в PyCharm
				<br>Выбираю New environment:
				<br>Location<pre>C:\Хранилище\IT\IT Разное\Обучение\Senior Pomidor\venv_spd</pre>
				<br>Base interpreteter<pre>Python 3.11 C:\Users\Александр\AppData\Local\Programs\Python\Python311\python.exe</pre>
				<br>Все остальные галочки пустые.
				<br><span class="spec">Теперь это venv - будет использоваться этим проектом,<br>В нем установлено только: setuptools, pip, wheel</span>
			</li>
			<li>
				Устанавливаем Django через PyCharm - settings - Project:spd-mini - Python Interpreteter - + - Django - Install Packege (Никаких галочек ставить не нужно)
				<br>Теперь в пакеты добавилось: Django, asgiref, sqlparse, tzdate
			</li>
			<li>
				Создаём проект django - в терминале: (venv_spd) PS C:\Хранилище\IT\IT Разное\Обучение\Senior Pomidor\spd-mini> 
				<pre>django-admin startproject mini</pre>
				<br>путь получился такой .../spd-miti/mini[manage.py]/mini[__init__,settings.py, urls.py ..]
			</li>
			<li>
				Запуксаем сервер
				<pre>
(venv_spd) PS C:\Хранилище\IT\IT Разное\Обучение\Senior Pomidor\spd-mini\mini>  

python manage.py runserver
				</pre>
				<br>проверяем в браузере - http://127.0.0.1:8000/
			</li>
			<li>
				Дополнительно в spd\mini - Добавлю .gitignore (в папку где есть manage.py)
			</li>
			<li>
				В settings.py - сделаю русский язык и время по МСК
				<pre>
LANGUAGE_CODE = 'ru-Ru'  # русский язык в admin

TIME_ZONE = 'Europe/Moscow'  # время по МСК</pre>
			</li>
			<li>
				Внешнюю папку mini - маркирую как Source Root
			</li>
		</ol>
	


&lt;
	
		<h3 class="title_text">[2]. Создание и управелние User</h3>
		<hr>
		<ol>

			<li>
				В settings.py - INSTALLED_APPS - 'django.contrib.auth', - это установленное приложение для User
			</li>
			<li>
				Для умного пойска в PyCarm - два раза жмём Shift - Classes - ищем класс User - class User(AbstractUser):
				<br>Открываем нас переносит в models.py - и показывают класс, полей в этом классе нет, потому что они находятся в AbstractUser
			</li>
			<li>
				Переходим в AbstractUser - для этого выделяем родительский класс, жмём Ctrl - и нас перенаправит в нужный класс
				<br>В Этом классе прописаны все поля (username, first_name, email и итд) 
			</li>
			<li>
				Классы по сути это описание таблиц в базе данных
			</li>
			<li>
				Дополнительно стразу, переделаю базу данных на PostgreSQL
				<ul>
					<li>
						Создаём DB в SQL Sell
						<pre>
Server [localhost]:
Database [postgres]:
Port [5432]:
Username [postgres]:
Пароль пользователя postgres:blog1234

psql \! chcp 1251  # для отображении кириллицы
\l смортрим список всех DB
CREATE DATABASE spd_mini;  # создали базу данных - spd_mini
-->CREATE DATABASE
\l - смотрим DB создана</pre>
					</li>
					<li>
						В PyCharm - в наше окружение устанавливаю psycopg2
					</li>
					<li>
						В settings.py переделываю проект под новую БД - DATABASES
						<pre>
DATABASES = {
    'default': {
        # 'ENGINE': 'django.db.backends.sqlite3',  # стандартная БД
        # 'NAME': BASE_DIR / 'db.sqlite3',  # стандартная БД
        'ENGINE': 'django.db.backends.postgresql',  # БД PostrgeSQL
        'NAME': 'spd_mini',  # Имя нашей БД
        'USER': 'postgres',  # пользователь postgres - который создал БД
        'PASSWORD': 'blog1234',  # пароль в PostgreSQL, для пользователя postgres
        'HOST': '127.0.0.1',  # либо просто - 'localhost'
        'PORT': '5432',  # стандартный порт
    }
}</pre>

					</li>
				</ul>
			</li>
			<li>
				Делаю делаю миграцию через терминал PyCharm
				<pre>python manage.py migrate</pre>
			</li>
			<li>
				Создаём суперюзера
				<pre>
python manage.py createsuperuser

Имя пользователя: Mello
Адрес электронной почты: elproject220@yandex.ru
Password:blog1234
Password (again):blog1234</pre>
			</li>
			<li>
				Заходим в админку http://127.0.0.1:8000/admin/ - и смотрим пользователей
			</li>
			<li>
				Создадим нового пользователя - user1
			</li>
			<li>
				Создадим группу пользователей - Web_User
			</li>
			<li>
				Перенесём нашего пользователя в нашу группу пользователей
			</li>
		</ol>
	


&lt;
	
		<h3 class="title_text">[3]. Проект и приложение</h3>
		<hr>
		<ol>
			<li>
				Собственные приложения django - это посути разделение кода (группировка кода по какомуто критерию)
				<br>Например сайт магазина, для него можно сделать приложения:
				<br>-покупки пользователя
				<br>-blilling - интеграция платёжной системы, информацию когда платил
				<br>-доставка (адреса, курьеры)
			</li>
			<li>
				Создаём приложение
				<pre>python manage.py startapp orders</pre>
				<br>Файлы приложение:
				<br>-папка migrations - миграции для передачи базы данных
				<br>-admin.py - для регистриции и настройки отображения наших моделей в админ палене
				<br>-apps.py - конфигурация приложения
				<br>-models.py - создаём собственные модели
				<br>-tests.py - для тестов
				<br>-views.py - представление. Получение запросов c url, логика отображения вэб страницы
				<br>-можем создавать свои файлы (forms.py, utils.py и тд)

			</li>
			<li>
				Регистрируем наше приложение в settings.py в INSTALLED_APPS
				<pre>
'orders',</pre>
		</ol>


&lt;
	
		<h3 class="title_text">[4]. Models Модели</h3>
		<hr>
		<ol>
			<li>
				Назодим - class AbstractUser(AbstractBaseUser, PermissionsMixin):
				<br>Метод класса def get_full_name(self): - он выводит динамический результат, он получает first_name + last_name - и выводит в новую строку
				<br>Метод класс - def email_user  - имеет логику отправки email, где email-  берётся из самой модели User
			</li>
			<li>
				Модель является единственным источником информации о ваших данных. Она содержит основные поля и поведение данных, которые вы храните. Как правило, каждая модель отображается в одну таблицу базы данных.
				<br>У объекта есть свойства, и модели вмещают в себя эти свойства.
			</li>
			<li>
				В models.py - создаём модель SalesOrder
				<pre>
class SalesOrder(models.Model):
    amount = models.IntegerField()
    description = models.CharField(max_length=255)</pre>
			</li>
			<li>
				Создаём миграцию. Миграция это промежуточный файл между Django и Базой данных
				<pre>python manage.py makemigrations</pre>
				Django автоматически создаёт id/pk
			</li>
			<li>
				применяем миграцию (записываем нашу модель в базе данных)
				<pre>python manage.py migrate</pre>
			</li>
			<li>
				Регистрируем модель в админ панеле. В admin.py
				<pre>
from .models import SalesOrder

admin.site.register(SalesOrder)</pre>
			</li>
			<li>
				Запустим django sell
				<pre>python manage.py shell</pre>
				<ul>
					<li>
						Импортируем нашу модель
						<pre>from orders.models import SalesOrder</pre>
					</li>
					<li>
						Выберем все обхекты модели
						<pre>SalesOrder.objects.all()</pre>
					</li>
					<li>
						Присвоим первый элемент списка нашей модели в переменную
						<pre>order = SalesOrder.objects.all()[0]</pre>
					</li>
					<li>
						Обратимся к отельным полям (столбцам) записи
						<pre>
order.id  -->  1
order.amount --> 25
order.description --> 'Книга'</pre>

					</li>
				</ul>
			</li>
		</ol>


&lt;
	
		<h3 class="title_text">[5]. Model Relations</h3>
		<hr>
		<ol>
			<li>
				Связи между моделями.
			</li>
			<li>
				Например <span class="spec">ForeingKey.</span> Многие к одному (много машин к одному производителю)
				<br>Данная связь наиболее частоиспользуемая
				<pre>
class Manufacturer(models.Model):
	name = ...
	pass

class Car(models.Model):
	name = ...
	manufacturer = models.ForeingKey(Manufacturer, on_delete=models.CASCADE)
..</pre>		
				<br>Производитель - у него может быть множество моделей машин
				<br>У каждой машины может быть только один производитель
			</li>
			<li>
				В модель SalesOrder - добавляем поле user - в models.py
				<pre>
class SalesOrder(models.Model):
    amount = models.IntegerField()
    description = models.CharField(max_length=255)
    # null=True - разрешает в поле Null - в старых заказах всем записям будет присвоено Null
    user = models.ForeignKey(User, on_delete=models.CASCADE, null=True)</pre>
				<br>-od_delete=models.SET_NULL - при удалении пользователя, во всех заказах в поле User будет поле Null
				<br>-od_delete=models.SET_DEFAULT - при удалении пользователя, во всех заказах в поле User будет дефолтное значение которое мы укажем
				<br>-od_delete=models.PROTECT - Django запретит удялять пользователя пока у него есть заказы
				<br>-od_delete=models.CASCADE - при удалении пользователя, все заказы связанные с пользователем будут удалены
			</li>
			<li>
				Создадим новую миграцию и применим её
				<pre>
python manage.py makemigrations
python manage.py migrate</pre>
			</li>
			<li>
				Запустим django sell
				<pre>python manage.py shell</pre>
				<ul>
					<li>
						Импортируем нашу модель
						<pre>from orders.models import SalesOrder</pre>
					</li>
					<li>
						<pre>SalesOrder.objects.all()  # все записи модели</pre>
					</li>
					<li>
						Записываем в 2 разные переменные разные записи модели
						<pre>
order1, order2 = SalesOrder.objects.all()</pre>
					</li>
					<li>
						Просмотр поля user
						<pre>
>>> order1.user 
ничего не покажет, так как поле пустое
>>> order2.user 
&lt;User: user1></pre>
					</li>
				</ul>
			</li>
			<li>
				<span class="spec">Связь ManyToManyField</span> - многие ко многим
				<br>Например начинка и пицца. У каждой пиццы может быть много начинок, для каждой начинки может быть много пицц.
				<br>Не особо важно в какой модели прописать связь ManyToMany в поле, можно как в пицце, так и в Начинке
			</li>
			<li>
				Создадим новыое приложение products
				<pre>python manage.py startapp products</pre>
			</li>
			<li>
				Регистрируем приложение в settings.py - INSTALLED_APPS
				<pre>'products',</pre>
			</li>
			<li>
				В приложении product - в models.py -  пишем модель Products
				<pre>
class Product(models.Model):
    name = models.CharField(max_length=100)</pre>
			</li>
			<li>
				Создаём и принимаем миграции
				<pre>
					python manage.py migrate</pre>
			</li>
			<li>
				Регистрируем модель в админпанеле - products/models.py
				<pre>
from products.models import Product

admin.site.register(Product)</pre>
			</li>
			<li>
				В orged/models.py - определяем связь ManyToMany (SalesOrder - Product)
				<br>В SalesOrder - добавляем поле product
				<pre>
from products.models import Product

products = models.ManyToManyField(Product)</pre>
			</li>
			<li>
				Создаём и принимаем миграцию
				<pre>
python manage.py makemigrations
python manage.py migrate</pre>
			</li>
			<li>
				Изучаем связь в админ панеле
				<br>В записях SaleOrders - появилось поле, Products - где будут хранится продукты для конкретного заказа
				<br>Создадим продукты в Products - Мобильный телефон, Ноутбук
				<br>В SaleOrders - в одном из заказе, добавляем наши продукты - и сохраняем
			</li>
			<li>
				Передём в python sell
				<pre>python manage.py shell</pre>
				<ul>
					<li>
						python manage.py shell
					</li>
					<li>
						Смотрим наши записи в модели SalesOrder
						<pre>
from orders.models import SalesOrder 
SalesOrder.objects.all()

order2 = SalesOrder.objects.all()[1]  # присвоили в переменную вторую запись модели

order2.products --> это не сработает, укажет просто ...object at 0x0000018A3A8CA85...
order2.products.all() --> &lt;QuerySet [&lt;Product: Product object (1)>, &lt;Product: Product object (2)>]> 
order2.products.all()[0].name  # вывод имени 1 продукта в нашем заказе (через класс Заказы, имя класса Продукт)</pre>
				</ul>
			</li>
			<li>
				<span class="spec">Связь OneToOneField</span>
				<br>Связь один к одному
				<br>Например у пользователя есть свой аккаунт(где есть данные например о картах) - этот аккаунт может быть привязан только к одному пользователю User
				<br>Связь применяется очень редко
				<br>Ещё один пример  - например нам необходимо к Useru Добавить поле - например номер лицевого счёта, нам не нужно изменять стандартную модель User Django - она не наша, встроенные модели изменять не стоит во избежании проблем, по этому лучше создать новый клас со связью OneToOne - и как бы расширить дополнительными полями модель User
			</li>
		</ol>


&lt;
	
		<h3 class="title_text">[6]. HTML rendering View</h3>
		<hr>
		<ol>
			<li>
				Пишем функцию представления - в orders/views.py
				<br>У render - 2 обязательный параметра (request, 'имя шаблона')
				<pre>
def orders_page(request):
    return render(request, 'index.html')</pre>
			</li>
			<li>
				<span class="">Аатоматическое исправленеи оформления кода в PyCharm (Ctrl + Alt + L)</span>
			</li>
			<li>

				<span class="spec">Во вмнешнем mini! там где manage.py.</span>
				<br>Cоздаём каталог templates!
			</li>
			<li>
				Прописываем созданною дирректирию templates - в settings.py - TEMPLATES - 'DIRS': []
				<pre>
'DIRS': ['templates'],</pre>
			</li>
			<li>
				Создаём шаблон index.html - в дирректории templates
			</li>
			<li>
				Делаем маршрут связанный с нашей функцией представления
				<br>В mini/urls.py
				<pre>path('', orders_page),</pre>
			</li>
			<li>
				<span class="spec">Ctrl+Space - помощь в импортировании чего либо</span>
				<br>Будет выскакивать похожие с именем функции/классы и где они находятся
			</li>
			<li>
				Выведем/передадим данные из модели в шаблон (передадим параметр в render)
				<br>views.py
				<pre>
from orders.models import SalesOrder

def orders_page(request):
    return render(request, 'index.html', {'orders': SalesOrder.objects.all()})
				</pre>
			</li>
			<li>
				Выводим данные модели в шаблоне index.html
				<pre>
{% for order in orders %}
&lt;p>{{ order.amount }}&lt;/p>
{% endfor %}</pre>
			</li>
			<li>
				Подключи bootstrap - в шаблон. В head - html файла вставляем ссылку css из bootstrap
			</li>
			<li>
				Немного оформим шаблон Index.html c помощью классов bootstrap
				<pre>
{% for order in orders %}

&lt;div class="btn btn-success btn-lg">
	&lt;p>Цена: {{ order.amount }}&lt;/p>
	&lt;p>Наименование: {{ order.description }}&lt;/p>
&lt;/div>
&lt;hr>
&lt;br>
&lt;br>
&lt;
{% endfor %}</pre>
			</li>
			<li>
				Метод шаблонов (view - создание HTML стриницы на сервере) устаревает, чаще всего успользуют методы API запросов
				<br>Клиент адресовывает данные как ему хочется - а сервер представляет какието голоые данные.
			</li>
		</ol>



&lt;
	
		<h3 class="title_text">[7]. API View на Django REST Framework</h3>
		<hr>
		<ol>
			<li>
				API запросы - обращение клиента к серверу. Клиент адресовывает данные как ему хочется - а сервер представляет какието голоые данные
			</li>
			<li>
				view по созданию API endpoint, который позволит нам формировать данные на сервере, передавать их на клиент, и на клиенте отрисовывать эти данные - аналогично так же как мы могли отрисовать их на сервере с помощью шаблонов html
			</li>
			<li>
				Для содания view API - необходим DJANGO REST FRAMEWORK
			</li>
			<li>
				В виртуальное окружение добавим библиотеку (пакет) - Django REST Framework.
				<br>Через PyCharm - djangorestframework
			</li>
			<li>
				QuerySet - список объектов класса
				<br>Сериализатор - Сериализаторы позволяют преобразовывать сложные данные, такие как наборы запросов и экземпляры моделей, в собственные типы данных Python, которые затем могут быть легко преобразованы в JSON , XML или другие типы содержимого.
				<br>То есть в методах передачи в шаблон мы отправляли объекты модели в шаблон, и там обращались к полям - то в случае с API это необходимо делать с помощью сериализатора
				<br>В сериализаторе нам необходимо определить какие именно поля необходимо передавать взапросе - точнее из каких полей формируетмя Python словарь
			</li>
			<li>
				Создаём новый py файл в orders (app)
				<br>serializers.py , в нём
				<pre>
from rest_framework.serializers import ModelSerializer  # базовый сериализатор dj rest
from orders.models import SalesOrder  # наш сериализатор


class OrderSerializer(ModelSerializer):  # наш сериализатор
    class Meta:
        model = SalesOrder  # наша модель
        fields = ['amount', 'description']  # поля модели</pre>
			</li>
			<li>
				<span class="spec">Alt + Enter - автоимпорт и PyCHarm</span>
			</li>
			<li>
				Создаём класс представления уже(API) - во views.py
				<pre>
from rest_framework.viewsets import ModelViewSet  # класс представления RESTfw
from orders.serializers import OrderSerializer  # наш сериализатор

# класс представления OrderView
# унаследовать функции из базового класса django REST - ModelViewSet
class OrderView(ModelViewSet):
    queryset = SalesOrder.objects.all()  # все записи модели
    serializer_class = OrderSerializer</pre>
			</li>
			<li>
				Пишем маршрут для нашего класса представления
				<br>Для model view set - маршруты пишутся немного по другому
				<br>В mini/urls.py
				<pre>
from rest_framework.routers import SimpleRouter
from orders.views import ..., OrderView

router = SimpleRouter()

router.register('api/orders', OrderView)
# ('путь url', класс представления rest)

urlpatterns = [
    path('......),
    path(......),
]

# в urlpatterns добавляем маршруты router.urls
urlpatterns += router.urls</pre>
			</li>
			<li>
				Сохраняемся и проверяем в браузере
				<pre>
http://127.0.0.1:8000/api/orders/?format=json</pre>
				<br>?format=json  - djnango rest fw - бдует понимать что необходимо передавать в формате json
				<br><span class="spec">-json - JSON (JavaScript Object Notation) - простой формат обмена данными, удобный для чтения и написания как человеком, так и компьютером. Он основан на подмножестве языка программирования JavaScript, определенного в стандарте</span>
				<br><br>
				-В браузере в вышеуказанном запросе выведет на страцице:
				<pre>-[{"amount":150,"description":"Аудиокнига"},{"amount":25,"description":"Книга"}]</pre>
				<br>-Это объект в формате json - по сути выглядит как словарь python
				<br>-В приложениях программам было бы удобно получать данные в формате json - и расставлять их куда нужно
				<br>-В формате json - данные принимают - модильные приложения, серверы, в том числе и браузеры и браузерные приложения
				<br>
				<br>
				-Способ ренедеринга в шаблоны - обычно уже не используется, он либо совсем заменён на формат json либо комбирируется (rendering + api запросы json)
			</li>
		</ol>



&lt;
	
		<h3 class="title_text">[8]. Фронтенд клиент на vue.js</h3>
		<hr>
		<ol>
			<li>
				Взаимодействие при помощи api с приложением django, чтобы сделать похожий результат который получили с помощью render
			</li>
			<li>
				Будем использовать framework JavaScript - vue JS
			</li>
			<li>
				Создадим шаблон, в который будем отправлять json, а рендерингом уже будет заниматся фронтенд JavaScript (vue JS) - то есть рендеринг будет происходить не на стороне сервера, а на стороне клиента
				<br><br>
				То есть мы отдаём клиенту шаблон и данные которые нужно в него подставить - и клиент сам расставляет эти данные в шаблон
				<br>Чаше всего даже не требуется отдавать шаблон фронтэнд клиенту - а необходимо передавать только данные
				<br>-В любом случае потребуется какаято страница, чтобы увидеть работу JavaScript framework
				<br><br>-По этому создаём новую html страницу, в папке templates - main_app.html
				<br> Делаем Html - разметку, подключаем bootstrap css в head, подключаем библиотеку vue JS - копируя ссылку скрипта из  <a href="https://github.com/translation-gang/ru.vuejs.org/blob/master/src/v2/guide/installation.md">https://github.com/translation-gang/ru.vuejs.org/blob/master/src/v2/guide/installation.md</a> (vue.js)
				Внизу head html
				<br> - добавляем axios cdn <a href="https://cdnjs.com/libraries/axios">https://cdnjs.com/libraries/axios</a> (axios.js) - аналогично vue
				<pre>
&lt;!-- css bootstrap 5 -->
&lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x" crossorigin="anonymous">

&lt;!-- vue.js - vue.cjs.js-->
&lt;script src="https://cdn.jsdelivr.net/npm/vue@2.7.8/dist/vue.js&lt;>&lt;/script>

&lt;!-- axios cdn -->
&lt;script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js">&lt;/script></pre>
			</li>
			<li>
				Делаем функцию представления - который будет отдавать main_app.html - файл
				<br>orders/views.py
				<pre>
# представление main_app.html
def orders_main_app(request):
    return render(request, 'main_app.html')</pre>
			</li>
			<li>
				Делаем маршрут в mini/urls.py
				<pre>
from orders.views import ...., ...., orders_main_app

urlpatterns = [
    ...
    ...
    path('orders_main_app/', orders_main_app),
]</pre>
			</li>
			<li>
				В браузере переходим - http://127.0.0.1:8000/orders_main_app/ - и открываем консоль разработчика  - Network - и смотрим полключились ли файлы bootstrap, vue, axios - всё ок
			</li>
			<li>
				Создаём папку статических файлов в  mini - static, создаём js файл
				<br>spd-mini/mini/static/app.js
			</li>
			<li>
				В settings.py - указываем путь к static файлам
				<pre>STATICFILES_DIRS = [BASE_DIR / 'static']  # путь к папке static</pre>
			</li>


			<li>
				В шаблоне main_app.html - подключаем app.js - до закрывания body
				<pre>
&lt;script src="/static/app.js">&lt;/script></pre>
				В панеле разработчика в Network проверяем подключилмя ли наш app.js
			</li>
			<li>
				Пишем app.js - Java Script - код
				<pre>
//обращаемся к классу который есть в библиотеке Vue.js
new Vue({
    el: '#orders_app',  // 'элементы - Это id в div html
    // data - словарь переменных
    data: {
    orders: []
    },
    // функция - которая не принимает аргументов
    // {} - внутри код на JS когда Vue будет создано
    // Vue будет создано - когда откроется веб страница
    created: function () {
        // константа - имя = vm
        // this - это self в JS
        const vm = this;
        // подключаемся к библиотеке axios
        axios.get('/api/orders/')
        // then - после того как запрос выполнен
        // response - ответ от сервера
        .then(function (response){
        vm.orders = response.data
        })
    }
}
)</pre>
				<br>То же самое без комментариев
				<pre>
new Vue({
    el: "#orders_app",
    data: {
    orders: []
    },
    created: function () {
        const vm = this;
        axios.get("/api/orders/")
        .then(function (response){
        vm.orders = response.data
        })
    }
}

)</pre>
			</li>
			<li>
				main_app.html body
				<pre>	
&lt;!-- внтри verbatim - django рендерить не будет
потому что {{ js }} , такжеделает и djnago {{ django }} -->

{% verbatim %}
&lt;div class="container" id="orders_app">
	

	&lt;!-- v-for="order in orders - это цикл for -->
	&lt;div class="btn btn-success btn-lg" v-for="order in orders">
		
		Наименование: {{ order.description }}
		&lt;br>
		Цена: {{ order.amount }}

	&lt;/div>


&lt;/div>
{% endverbatim %}</pre>
				<br><br>
				<span class="spec">
					-В чём смысл - смысл в том что в первом сулчае (то что обычно делали в шаблонах django) - мы получали записи из БД и выводили в шаблон с помощью джанго, то есть страницу рендерил джанго, на сервере
					<br><br>-В указанном случае рендеринг делал vue JS, для этого мы и создавали api endpoint -  к которому может обращатся какойто клиент, браузер, мобильное приложение и с помощью JS - рендерить уже на стороне клиента
					<br><br>-Они вроде находятся в  маршруте router.register('api/orders', OrderView) - то есть при переходе на path('orders_main_app/', orders_main_app),   -  данные берутся из router.register('api/orders', OrderView).
					<br>При помощи API endpoint - больше возможностей.
				</span>
				<br><br>
			</li>
		</ol>

&lt;
	






		<br><br><br><br><br><br>
		<h1 class="title_text border">II. Бекенд на Django</h1>
		<hr>
		<br><br>

		
		<h3 class="title_text">[1]. Quickstart</h3>
		<hr>

		<ol>

			<li>
				Будем делать новый проект, в Pyharm - создаём Python проект и создаём  виртуальное окружение к нему
				<pre>
Проект - C:\Хранилище\IT\IT Разное\Обучение\Senior Pomidor\Books-project
Venv - C:\Хранилище\IT\IT Разное\Обучение\Senior Pomidor\venv_books</pre>
				<br><br><span class="spec">Никаких 'галочек'' не надо</span>
			</li>
			<li>
				В терминале  - (venv_books) PS C:\Хранилище\IT\IT Разное\Обучение\Senior Pomidor\Books-project>  - устанавливаем django
				<pre>
pip install Django</pre>

			</li>
			<li>
				Создаю новый django проект
				<pre>django-admin startproject books</pre>
			</li>
			<li>
				Внешнюю папку Books - (там где manage.py)  - маркирую как Sources Root - то есть это будет корневой папкой django проекта
			</li>
			<li>
				Дополнительно - сам сделаю новую Базу данных в PostgreSQL - в SQL Shell
				<pre>
Server [localhost]:
Database [postgres]:
Port [5432]:
Username [postgres]:
Пароль пользователя postgres:blog1234

psql \! chcp 1251  # для отображении кириллицы
\l смортрим список всех DB
CREATE DATABASE books;  # создали базу данных - books
-->CREATE DATABASE
\l - смотрим DB создана</pre>
			</li>
			<li>
				Установлю в  - psycopg2 - в виртуальное окружение через терминал, для того чтобы база данных PostrgeSQL работала в проекте
				<pre>pip install psycopg2</pre> 
			</li>
			<li>
				Дополнительно - наструю БД в settings.py, там же сразу сделаю русский язык и время по МСК
				<br>settings.py - База данных
				<pre>
DATABASES = {
    'default': {
        # 'ENGINE': 'django.db.backends.sqlite3',  # стандартная БД
        # 'NAME': BASE_DIR / 'db.sqlite3',  # стандартная БД
        'ENGINE': 'django.db.backends.postgresql',  # БД PostrgeSQL
        'NAME': 'books',  # Имя нашей БД
        'USER': 'postgres',  # пользователь postgres - который создал БД
        'PASSWORD': 'blog1234',  # пароль в PostgreSQL, для пользователя postgres
        'HOST': '127.0.0.1',  # либо просто - 'localhost'
        'PORT': '5432',  # стандартный порт
    }
}</pre>
			<br>settings.py - время и язык
			<pre>
LANGUAGE_CODE = 'ru-Ru'  # русский язык в admin

TIME_ZONE = 'Europe/Moscow'  # время по МСК</pre>
			</li>
			<li>
				В корневой каталог books (там где manage.py) - добавляю .gitignore
			</li>
			<li>
				Создаём новое приложение - в терминале - (venv_books) PS C:\Хранилище\IT\IT Разное\Обучение\Senior Pomidor\Books-project\books> 
				<pre>
python manage.py startapp store</pre>
			</li>
			<li>
				Дополнительно - регистрирую приложение store в settings.py - INSTALLED_APPS
				<br>Информацию берём из store/apps.py - class
				<pre>'store.apps.StoreConfig',</pre>
			</li>
			<li>
				Принимаю первую миграцию (пользователи админки и такдалее) - те таблицы что нужны django изначально
				<pre>python manage.py migrate</pre>
				<br>Через pgAdmin 4 - можно проверить, создались си в нашей базе данных таблицы
			</li>
			<li>
				Создаём супер пользователя
				<pre>
python manage.py createsuperuser

Имя пользователя: Mello
Адрес электронной почты: elproject220@yandex.ru
Password:blog1234
Password (again):blog1234</pre>
			</li>
			<li>
				Проверим работостпособность сервера и войдём в админ панель - под аккаунтом superuser
			</li>
			<li>
				Создадим пользователя user1
			</li>
			<li>
				Создаём первую модель в store/models.py
				<pre>
class Book(models.Model):
    name = models.CharField(verbose_name='Название книги', max_length=255)
    # DecimalField - почти float, но необходимо указать сколько значений будет после запятой
    # max_digits=7 - максимальное количество цифр в числе (вместе с дробной частью)
    # decimal_places=2 - два числа после запятой
    price = models.DecimalField(verbose_name='Цена книги', max_digits=7, decimal_places=2)</pre>
			</li>
			<li>
				Ctrl+Alt+L - PyCharm - автоматически отредактирует код согласно PIP8
			</li>
			<li>
				Создадим и применим миграцию
				<pre>
python manage.py makemigrations
python manage.py migrate</pre>
			</li>
			<li>
				Дополнительно, зарегистрирую и настрою отображение нашей модели в админ панеле
				<br>в store/admin.py
				<pre>
from store.models import Book


class BookAdmin(admin.ModelAdmin):
    # список отображаемых столбцов в админ-панели
    list_display = ('id', 'name', 'price')
    # список полей на которые можно кликнуть - для редактирования
    list_display_links = ('id', 'name', 'price')
    # список полей - ко которым можно вести поиск
    search_fields = ('name',)


# регистрируем в админке - модель Book
# регистрируем класс отображения в админке - BookAdmin
admin.site.register(Book, BookAdmin)</pre>
			</li>
			<li>
				Дополнительно - Изменю отображение названия в админ панели для модели Book, в единственном и множественном числе - на русском языке
				<br>для этого в store/models.py - модели Book, допишем class Meta:
				<pre>
class Meta:
    verbose_name = 'Книги'
    verbose_name_plural = 'Книги'</pre>
			</li>
			<li>
				Дополнительно - отобразим название приложения - STORE - на русском языке
				<br>Для этого в store/apps.py - class StoreConfig(AppConfig): - добавим verbose_name
				<pre>
verbose_name = 'Магазин'</pre>
			</li>
			<li>
				Устанавливаем djangorestframework - через PyCharm
				<br>Теперь мы можем пользоваться классами который предоставляет djangorestframewoek
			</li>
			<li>
				Дополнительно зарегистрирую djangorestframework в settings.py - INSTALLED_APPS
				<pre>
'rest_framework',  # djangorestframework</pre>
			</li>
			<li>
				Сделаем сериализацию модели Book - в store - создаём новый файл - serialuzers.py
				<br>Внутри него делаем сериализатор для нашего класса
				<pre>
from rest_framework.serializers import ModelSerializer
from store.models import Book

# ModelSerializer - родительский класс
class BookSerializer(ModelSerializer):
    class Meta:
        model = Book
        fields = '__all__'  # все поля</pre>
			</li>
			<li>
				Создадим представление для нашего будущего API Endpoint
				<br>в store/views.py
				<pre>
from django.shortcuts import render  # обычный render - нам больше не нужен..

from rest_framework.viewsets import ModelViewSet
from store.models import Book
from store.serializers import BookSerializer

# ModelViewSet - родительский класс
class BookViewSet(ModelViewSet):
    queryset = Book.objects.all()  # объекты нашей модели
    serializer_class = BookSerializer  # наш сериализатор</pre>
			</li>
			<li>
				необходимо пробросить запрос из нашего представления
				<br>В books (проект)/urls.py
				<pre>
from rest_framework.routers import SimpleRouter  # маршрутизатор rest
from store.views import BookViewSet  # наше представление api

# создали переменную роутер
router = SimpleRouter()

# в роутер добавим наше представление
router.register(r'book', BookViewSet)


urlpatterns = [
	...
]

# добавляем в urlpatterns, url-ы нашего роутера
urlpatterns += router.urls</pre>
			</li>
			<li>
				Проверяем работоспособность
				http://127.0.0.1:8000/book/
				<br><span class="spec">Прелесть Django REST framework - в том что он делает всё автоматически - при переходе по указанному url-у http://127.0.0.1:8000/book/  - нам выведется страница со всей информациией от фреймворка, мы можем посмотртеть сухой json (какой он на самом деле) просто нажав кнопку json<br>
				И нас перенесёт по реальному url-у - http://127.0.0.1:8000/book/?format=json</span>
				<br><br>
			</li>
			<li>
				Добавим пару записей в Book через django sell в терминале
				<pre>
python manage.py shell 

# импортируем модель в shell
from store.models import Book 

# создаём пару записей
Book.objects.create(name='Учебник Python', price='1000.00') 
Book.objects.create(name='Документация Django', price='1500.00')

# выход из shell
exit()</pre>
			</li>
			<li>
				Проверим в браузере, всё чётко работает, выводит словарь - словарь как сериальзованная модель ф формате json
				<pre>
[{"id":1,"name":"Учебник Python","price":"1000.00"},{"id":2,"name":"Документация Django","price":"1500.00"}]
				</pre>
			</li>
			<li>
				Дополнительно создам репозиторий на github - отправлю первый коммит
				(.gitignore - уже создавал)
			</li>
		</ol>
	


&lt;





		<h3 class="title_text">[2]. Unit Tests</h3>
		<hr>

		<ol>

			<li>
				Делаем первый unnit test - store/tests.py - удалим файл - и сделаем целую дирректорию
				store/tests  - делаем как Python Package (папка с __init__.py) В этой дирректории бдут тесты для каждого модуля которые мы имеем (models.py views.py serializers.py)
			</li>
			<li>
				В store - создадим python файл - logic.py - в нём делаем пример теста
				<pre>
def operations(a, b, c):
    if c == '+':
        return a + b
    if c == '-':
        return a - b
    if c == '*':
        return a * b</pre>
        		<br>Переходим в Python Console
        		<pre>
from store.logic import operations  # импортируем нашу функцию из logic.py

operations(3, 7, '-')  # вводим значения для a, b, c
-4  # вывела консоль - функция работает

operations(3, 7, '+')
10
operations(3, 7, '*')
21</pre>
			</li>
			<li>
				В store/tests - создаём .py -файл - test_logic.py <strong>Причём нижнее подчёркивание обязательно для создании тестов</strong>
				<br>Как правило тесты пишится классами, для этого есть два самых популярных фреймворка - <strong>unittest, django.test , pytest</strong><br>первый и второй как праивло уже установлены - на данном этапе
			</li>
			<li>
				<span class="spec">В Pithon 3.11 - на данный момент есть проблемы с pydev debugger</span>
				<br>Я решил проблему 1) с помошью установки в виртуальное окружения django-debugger
				<br>2) from <strong>unittest</strong> import TestCase
			</li>
			<li>
				В store/test/logic_test/py - пишем тест:
				<pre>
from unittest import TestCase  # встроенный класс для тестов

# наш тест на основе базового TestCase
class LogicTestCase(TestCase):
    def test_plus(self):  # метод внутри теста
        # подставляем значения abc
        # def operations (a, b, c) - прописана в другой файле
        result = operations(6, 13, '+')
        # (то что мы ожидаем, результат)
        self.assertEqual(19, result)</pre>
        		<br>Делаем тест - на test_plus - ПКМ -Run
        		<br>Вывод в консоле:
        		<pre>
Ran 1 test in 0.002s

OK</pre>
				<br>То есть 6 + 13 = 19 --> OK -  условие выполнено
			</li>
			<li>
				Если мы поменяем значение в условии на result = operations(9, 13, '+')
				<br>Run выведет:
				<pre>
Ran 1 test in 0.004s

FAILED (failures=1)

22 != 19

Expected :19
Actual   :22

AssertionError: 19 != 22
</pre>
				То есть не верно, мы планируем увидить 19, но по факту результат функции = 22
			</li>
			<li>
				Добавим ещё два теста (метод в классе ) - LogicTestCase
				<br>Там же test_logic.py
				<pre>
def test_minus(self):
    result = operations(6, 13, '-')
    # (то что мы ожидаем, результат)
    self.assertEqual(-7, result)

def test_multiply(self):
    result = operations(6, 13, '*')
    # (то что мы ожидаем, результат)
    self.assertEqual(78, result)</pre>
    			Всё работает!
			</li>
			<li>
				То эе самое проделаем в терминале
				<br>В терминле - (venv_books) PS C:\Хранилище\IT\IT Разное\Обучение\Senior Pomidor\Books-project\books>
				<pre>
 python manage.py test store.tests
 # где - store.tests - это дирректория где хранятся наши тесты</pre>
			</li>
			<li>
				Ещё вариант сделать тесты - в терминале просто записать
				<pre>python manage.py test .</pre>
				Будут сделаны все тесты в папке которой мы находимся в терминале
			</li>
			<li>
				В store/test - создаём test_api.py (будем тестировать представления api) - внутри создаём
				<pre>
from django.urls import reverse
from rest_framework.test import APITestCase

# проверка API  - см urls.py router.register(r'book', BookViewSet)
class BooksApiTestCase(APITestCase):
    def test_get(self):
        # book-list - получение всего списка router.register(r'book', BookViewSet)
        # book-detail - если бы необходимо было бы конкретную книгу
        url = reverse('book-list')
        print(url)  # для себя - для проверки что выведет
        # self.client - например клиент/браузер - который делает запрос нашему серверу
        response = self.client.get(url)
        print(response)  # для себя - для проверки что выведет</pre>
			</li>
			<li>
				Делаем проверку BooksApiTestCase  - в терминале (так.как PyCharm PyCharm Community Edition - не поддерживает тесты rest) - чтобы делать кнопочками, необходима платная версия
				<br>Делаем тест только в одном файле
				<pre>
python manage.py test store.tests.test_api</pre>
				<br><br>Терминал выведет
				<pre>
/book/
&lt;Response status_code=200, "application/json">
.
-----------
Ran 1 test in 0.012s

OK</pre>
			</li>
			<li>
				Поменяем print(response) на print(response.data)  и повторим тест
				<pre>
print(response.data)
-->
/book/
[]  # это пустой api - так как в тесте мы не загружали никакие данные
.....</pre>
			</li>
			<li>
				Добавим в тест пару книг, 
				<br><span class="spec">Важно понимать - что книги не записываются в БД - это только текст - не смотря на то что мы импортировали модель из models.py</span>
				<pre>
from store.models import Book

# проверка API  - см urls.py router.register(r'book', BookViewSet)
class BooksApiTestCase(APITestCase):
    def test_get(self):
        # добавили тестовые книги! они не записываются в БД! - это тест!
        book_1 = Book.objects.create(name='Test book 1', price=25)
        book_2 = Book.objects.create(name='Test book 2', price=50)
        # book-list - получение всего списка router.register(r'book', BookViewSet)
        # book-detail - если бы необходимо было бы конкретную книгу
        url = reverse('book-list')
        print(url)  # для себя - для проверки что выведет
        # self.client - например клиент/браузер - который делает запрос нашему серверу
        response = self.client.get(url)
        print(response.data)  # для себя - для проверки что выведет</pre>
        		<br>Делаем тест
        		<pre>
python manage.py test store.tests.test_api
-->
/book/
[OrderedDict([('id', 1), ('name', 'Test book 1'), ('price', '25.00')]), OrderedDict([('id', 2), ('name', 'Test book 2'), ('price', '50.0
0')])]
----
Ran 1 test in 0.014s

OK</pre>
				Всё работает - отлично
			</li>
			<li>
				Подключим сериализатор к тесту
				<pre>
from store.serializers import BookSerializer

# проверка API  - см urls.py router.register(r'book', BookViewSet)
class BooksApiTestCase(APITestCase):
    def test_get(self):
        # вводные данные
        book_1 = Book.objects.create(name='Test book 1', price=25)
        book_2 = Book.objects.create(name='Test book 2', price=50)

        # book-list - получение всего списка router.register(r'book', BookViewSet)
        # book-detail - если бы необходимо было бы конкретную книгу
        url = reverse('book-list')

        # self.client - например клиент/браузер - который делает запрос нашему серверу
        response = self.client.get(url)

        # сравниваем то что вводные данные сходятся с выходными
        serializer_data = BookSerializer([book_1,book_2], many=True).data
        # serializer_data - входные данные, response.data - выходные данные
        # Мы ожидаем что должно быть serializer_data, и проверяем равен ли ей response.data
        self.assertEqual(serializer_data, response.data)


--> 
Ran 1 test in 0.011s

OK</pre>		
				Тест прошёл
			</li>
			<li>
				Необходимо сравнить что код возврата http сервера будет 200 (200 это значит всё хорощо, 404 - значит страница не найдена)
				<br>
				Добавим строчку - self.assertEqual(status.HTTP_200_OK, response.status_code)
				<pre>
test_api.py:

from rest_framework import status


class BooksApiTestCase(APITestCase):
    def test_get(self):
        book_1 = Book.objects.create(name='Test book 1', price=25)
        book_2 = Book.objects.create(name='Test book 2', price=50)
        url = reverse('book-list')
        response = self.client.get(url)

        # Ожидаем страницу статус=200, сравниваем с ответным кодом
        self.assertEqual(status.HTTP_200_OK, response.status_code)

        serializer_data = BookSerializer([book_1,book_2], many=True).data
        self.assertEqual(serializer_data, response.data)


Тест:

python manage.py test store.tests.test_api
-->
Ran 1 test in 0.010s

OK</pre> 
			</li>
			<li>
				Сделаем запланированную ошибку
				<pre>self.assertEqual(status.HTTP_202_ACCEPTED, response.status_code)</pre>
				<br>Тест не пройдёт - так как ошидаемые данные не будут совпадать с выходными
				<br>page code 202 != page code 200
			</li>
			<li>
				<strong>Делаем тест сериализатора</strong><br>
				В tests - создаём  - test_serializers.py, в нём пишем тест
				<pre>
from django.test import TestCase
from django.urls import reverse
from store.models import Book
from store.serializers import BookSerializer


class BookSerializerTestCase(TestCase):
    def test_ok(self):
        # вводные данные
        book_1 = Book.objects.create(name='Test book 1', price=25)
        book_2 = Book.objects.create(name='Test book 2', price=50)
        # проверяемые данные
        data = BookSerializer([book_1, book_2], many=True).data

        # ожидаемые данные
        expected_data =[
            {
                'id': book_1.id,
                'name': 'Test book 1',
                'price': '25.00'
            },
            {
                'id': book_2.id,
                'name': 'Test book 2',
                'price': '50.00'
            },
        ]

        # само тестирование
        # (ожидаемые данные, данные из сериализатора)
        self.assertEqual(expected_data, data)</pre>
        		<br><span class="spec">Обрати внимание - на price - необходимо делать именно с .00 - так как поле в моделе - class Book - price = models.DecimalField(.... decimal_places=2)</span>
        		<br>
        		<br>Делаем тест
        		<pre>
python manage.py test store.tests.test_serializer
-->
Ran 1 test in 0.011s
OK</pre>		
			</li>
			<li>
				Тесты в целом не должны выглядить красиво, с наследованиями, декораторами и так далее, тесты должны быть максимально простыми и понятными, чтобы на тесты не прищлось писать свои тесты
			</li>
			<li>
				<span class="spec">Пакет coverage</span>
				<br>Показывает - на сколько тесты покрывают имеющийся код
				<br>Устанавливаем пакет в окружение
			</li>
			<li>
				Анализируем весь проект в терминали с помощью coverage
				<pre>
coverage run --source='.' ./manage.py test .</pre>
				Покрытие нужно анализировать отностительно корня / анализируем весь проект
			</li>
			<li>
				Смотрим список покрытия, создаём репорт
				<pre>
coverage report</pre>
				На выходе будет таблица py файлов и процент покрытия
			</li>
			<li>
				Для вывода репорта в виде html - в терминале
				<pre>coverage html</pre>
				Будет создан подкаталог htmlcov - и в нём будут нужные html страницы
			</li>
		</ol>
	


&lt;






		<h3 class="title_text">[3]. Filters, Search, Ordering</h3>
		<hr>

		<ol>

			<li>
				Механизм фильтрациии, поиск и сортировка в API
			</li>
			<li>
				Django REST-  предлагает работать с пакетом django-filter  - устанавливаем в окружение
			</li>
			<li>
				Во views.py - добавляем фильтр в представлении (API) - class BookViewSet(ModelViewSet): - 
				<pre>
class BookViewSet(ModelViewSet):
    ....
    filter_backends = [DjangoFilterBackend]  # filter django-filter
    # для фильтра в url  - ?price=1000
    filter_fields = ['price']  # django-filter - возможность фильтровать по price (цене))</pre>
				<br>пробуем запускать в браузере - http://127.0.0.1:8000/book/ / JSON - http://127.0.0.1:8000/book/?format=json
			</li>
			<li>
				Зайдём в консоль manage.py shell
				<pre>
python manage.py shell
from store.models import Book 
Book.objects.all() # посмотрим все записи модели
&lt;QuerySet [&lt;Book: Book object (1)>, &lt;Book: Book object (2)>]> 

Book.objects.all()[0]  # посмотреть Querisetы  первой записи
Book.objects.all()[0]  # посмотреть Querisetы  первой записи

Book.objects.all()[0].price # посмотреть цену первой записи
--> Decimal('1000.00') 

#создадим новую запись модели Book
Book.objects.create(price='500.00', name='Русско-Английский переводчик')
&lt;Book: Book object (3)> 
				</pre>
			</li>
			<li>
				Дополнительно пропишу метод str для модель Book - для того чтобы при обращении к можели нам показывало название кники а не Book object (2)
				<pre>
class Book(models.Model):
	......
    def __str__(self):
    return self.name</pre>
			</li>
			<li>
				Расрурю метод __str__ - чтобы показывалось id + name
				<pre>
def __str__(self):
    return f'Id {self.id}: {self.name}'</pre>
			</li>
			<li>
				Добавим поле - имя автора в модели Book
				<pre>
class Book(models.Model):
	...
    author_name = models.CharField(max_length=255)</pre>
    			Это поле не предполагается быть пустым (то есть у каждой книги есть автор), при создании миграции будет проблема - так как необходимо заполнить поле автор - для всех уже созданных записей. Есть несколько вариантов решения
    			<br>-Временно указать в моделе default=значение
    			<br>-Можно прям в терминале прописать значение которым заполнятся поля
			</li>
			<li>
				Создаём и и принимаем миграцию
				<pre>
python manage.py makemigrations

# Введём в поле author_name  - во всех созданных записях значение Автор
Please select a valid option: 1
"Автор"	

pythin manage.py migrate</pre>
			</li>
			<li>
				Сразу изменим авторов для всех записей на реальные
			</li>
			<li>
				Дополнительно настрою отображение в админке и не только
				<br>models.py - class Book
				<pre>author_name = models.CharField(verbose_name='Автор книги', max_length=255)</pre>
				<br>admin.py
				<pre>
class BookAdmin(admin.ModelAdmin):
    # список отображаемых столбцов в админ-панели
    list_display = ('id', 'name', 'price', 'author_name')
    # список полей на которые можно кликнуть - для редактирования
    list_display_links = ('id', 'name', 'price', 'author_name')
    # список полей - ко которым можно вести поиск
    search_fields = ('name', 'author_name')</pre>
			</li>
			<li>
				Настраиваем посик во view.py - (поиск имеет смысл когда мы ищем по двум полям или более)
				<pre>
from rest_framework.filters import SearchFilter

class BookViewSet(ModelViewSet):
	....
	filter_backends = [DjangoFilterBackend, SearchFilter]  # django-filter
	.....
	search_fields = ['name', 'author_name']	 # для поиска</pre>
			</li>
			<li>
				Для поиска в url пишем
				<pre>
http://127.0.0.1:8000/book/?search=django
-->
[{"id":2,"name":"Документация Django","price":"1500.00","author_name":"Адриан Головатый"}]


http://127.0.0.1:8000/book/?search=докум
-->

[{"id":2,"name":"Документация Django","price":"1500.00","author_name":"Адриан Головатый"}]
</pre>
				Будет выводить любые записи по результатам ?search=поиск - в полях name и author_name
			</li>
			<li>
				Сортировка api - OrderingFilter
				<pre>
from rest_framework.filters import SearchFilter, OrderingFilter

class BookViewSet(ModelViewSet):
	....
    filter_backends = [..., ..., OrderingFilter]  # django-filter
    ...
    # для сортировки
    ordering_fields = ['price', 'author_name']</pre>
			</li>
			<li>
				Используем сортировку, в брузере попробуем всё отсортировать по цене
				<pre>
http://127.0.0.1:8000/book/?ordering=price
--> 
выведет полный отсортированный список

http://127.0.0.1:8000/book/?ordering=-price
-->
сортировка в обратном порядке

http://127.0.0.1:8000/book/?ordering=author_name
-->
сортировка по автору (по алфавиту)
</pre>
			</li>
			<li>
				Полнный класс представления views.py
				<pre>
# ModelViewSet - родительский класс
class BookViewSet(ModelViewSet):
    queryset = Book.objects.all()  # объекты нашей модели
    serializer_class = BookSerializer  # наш сериализатор

    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]  # django-filter
    # для фильтра в url  - ?price=1000
    filter_fields = ['price']  # django-filter - возможность фильтровать по price (цене)
    # для поиска
    search_fields = ['name', 'author_name']
    # для сортировки
    ordering_fields = ['price', 'author_name']</pre>
			</li>
			<li>
				Пишем unit test
				<br>Ищзменяем - test_api.py - class BooksApiTestCase(APITestCase): - добавляем метод - в самом начале
				<pre>
# проверка API  - см urls.py router.register(r'book', BookViewSet)
class BooksApiTestCase(APITestCase):
    # метод будет запускаться перед каждым тестом (методами test_get)
    def setUp(self):
        # вводные данные
        self.book_1 = Book.objects.create(name='Test book 1', price=25, author_name='Автор 1')
        self.book_2 = Book.objects.create(name='Test book 2', price=50, author_name='Автор 2')
        self.book_3 = Book.objects.create(name='Test book 3', price=75, author_name='Автор 3')</pre>
			</li>
			<li>
				Изменим def test_get  (убрали вводные данные в setUp, добавили в serializer_data, к записям self, добавили book_3)
				<pre>
    def test_get(self):
        # book-list - получение всего списка router.register(r'book', BookViewSet)
        # book-detail - если бы необходимо было бы конкретную книгу
        url = reverse('book-list')

        # self.client - например клиент/браузер - который делает запрос нашему серверу
        response = self.client.get(url)

        # Ожидаем страницу статус=200, сравниваем с ответным кодом
        self.assertEqual(status.HTTP_200_OK, response.status_code)

        # сравниваем то что вводные данные сходятся с выходными
        serializer_data = BookSerializer([self.book_1, self.book_2, self.book_3], many=True).data
        # serializer_data - входные данные, response.data - выходные данные
        # Мы ожидаем что должно быть serializer_data, и проверяем равен ли ей response.data
        self.assertEqual(serializer_data, response.data)					
				</pre>
			</li>
			<li>
				Сделаем test_get в терминале - тест api полного списка без каких либо сортировок
				<pre>
python manage.py test  store.tests.test_api.BooksApiTest
Case.test_get</pre>
			</li>
			<li>
				В этот же класс - BooksApiTestCase  - добавим ещё один метод (test_get_filter) - сестируем фильтр, поиск и немного подкорректируем входные данные в setUp
				<pre>
def setUp(self):
    # вводные данные
    self.book_1 = Book.objects.create(name='Test book 1', price=25, author_name='Автор 1')
    self.book_2 = Book.objects.create(name='Test book 2', price=50, author_name='Автор 2')
    self.book_3 = Book.objects.create(name='Test book 3 Автор 1', price=75, author_name='Автор 1')


def test_get_search(self):
    # book-list - получение всего списка router.register(r'book', BookViewSet)
    # book-detail - если бы необходимо было бы конкретную книгу
    url = reverse('book-list')

    # условия поиска
    response = self.client.get(url, data={'search': 'Автор 1'})
    # Ожидаем страницу статус=200, сравниваем с ответным кодом
    self.assertEqual(status.HTTP_200_OK, response.status_code)
    serializer_data = BookSerializer([self.book_1,
                                      self.book_3], many=True).data
    # Мы ожидаем что должно быть serializer_data, и проверяем равен ли ей response.data
    self.assertEqual(serializer_data, response.data)</pre>
				<br>
				Делаем тест test_get_search
				<pre>python manage.py test  store.tests.test_api.BooksApiTestCase.te
st_get_search</pre>
			</li>
		</ol>
	


&lt;





		<h3 class="title_text">[4]. OAuth</h3>
		<hr>

		<ol>

			<li>
				Проверка аутентификации пользователя
			</li>
			<li>
				Выйдем из админки, в views.py - BookViewSet - добавим строчку, что бы запритить это представление не залогиненым пользователям (авторизация) permission
				<pre>
from rest_framework.permissions import IsAuthenticated

# ModelViewSet - родительский класс
class BookViewSet(ModelViewSet):
	...
	# только авторизованные пользователи могут пользоваться представлением
    permission_classes = [IsAuthenticated]</pre>
    			Сохраняем пробуем войти по url
    			<pre>
http://127.0.0.1:8000/book/
-->
"detail": "Учетные данные не были предоставлены."

http://127.0.0.1:8000/book/?format=json
-->
{"detail":"Учетные данные не были предоставлены."}</pre>
				<br>То есть всё работает
			</li>
			<li>
				<span class="spec">
					Аутентифиация и авторизация - это разные вещи
				</span>
				<br>
				Аутентифиация - проверка подлинности пользователя (проверка подлинности эмейла, проверка подлинности аккаунта на facebok)
				<br>
				Авторизация - разрешение.
				<br>Сначала пользователя аутентифецируем, логиним, а вотом запрещаем/разрешаем пользователю что то видеть или делать какието действия
			</li>
			<li>
				Python Social Auth - читай порядок установки с оф докумметации
				<br><a href="https://python-social-auth.readthedocs.io/en/latest/configuration/django.html">https://python-social-auth.readthedocs.io/en/latest/configuration/django.html</a>
				<ul>
					<li>Устанавливаем в виртуальное окружение - social-auth-app-django</li>
					<li>settings.py - INSTALLED_APPS - 
						<pre>
'social_django',  # аутентификация</pre>
						<br><strong>
							Как правило в INSTALLED_APPS - идут приложения джанго, нижу третесторониие приложения, ниже наши приложения, которые создавали сами
						</strong>
					</li>
					<li>Необходимо сделать миграцию
						<pre>python manage.py migrate</pre>
					</li>
					<li>
						Для PostrgeSQL - в settings.py необходимо добавить - Чтобы этот пакет мог пользоваться json форматом  - без нагрузки на базу
						<pre>SOCIAL_AUTH_JSONFIELD_ENABLED = True</pre>

					</li>
					<li>
						В settings.py необходимо добавить то через какие соцсети можно будет залогинится
						<pre>
AUTHENTICATION_BACKENDS = (
    'django.contrib.auth.backends.ModelBackend',
)</pre>
					</li>
					<li>
						Необходимо сделать маршрутизацию
						<br>urls.py
						<pre>
from django.urls import .., include, re_path

re_path('', include('social_django.urls', namespace='social'))</pre>
					</li>
					<li>
						Запускаем сервер - домашняя страница будет ошибка 404 - так как нет домашней странице, но есть список всех маршрутов которые существуют
						<pre>
admin/
login/&lt;str:backend>/ [name='begin']
complete/&lt;str:backend>/ [name='complete']
disconnect/&lt;str:backend>/ [name='disconnect']
disconnect/&lt;str:backend>/&lt;int:association_id>/ [name='disconnect_individual']
^book/$ [name='book-list']
^book/(?P&lt;pk>[^/.]+)/$ [name='book-detail']</pre>
						<br>Как раз login, complete, disconnect - это как раз те эндпойнты которые создал Social Auth
					</li>
					<li>
						Почитай статью <a href="https://www.digitalocean.com/community/tutorials/oauth-2-ru">Введение в OAuth 2</a>
						<br>
						<img src="images\SPD\oauth.png" class="img-fluid">
						<br>

					</li>
					<li>
						Продолжаем настройку для аутентификации по гитхабу - 
						<br><a href="https://python-social-auth.readthedocs.io/en/latest/backends/github.html#github">https://python-social-auth.readthedocs.io/en/latest/backends/github.html#github</a>
						<br>settings.py
						<pre>
AUTHENTICATION_BACKENDS = [
    ...
    'social_core.backends.github.GithubOAuth2',
]</pre>
					</li>	
					<li>
						В settings.py - добавляем ключи
						<pre>
SOCIAL_AUTH_GITHUB_KEY = 'a1b2c3d4'
SOCIAL_AUTH_GITHUB_SECRET = 'e5f6g7h8i9'</pre>
					</li>	
					<li>
						Переходим в настройки на самом гитхабе
						<br><a href="https://github.com/settings/applications/new">https://github.com/settings/applications/new</a>
						<br>Заполняем форму регистрации приложения, с которого можно будет сделать аутентификацию через github
						<br>
						<img src="images\SPD\git_oauth.jpg" class="img-fluid">
						<br>
					</li>	
					<li>
						Далее с самого гита - берём ключ Client ID и Client secrets
 - и добавляем в settings.py
 						<pre>
 SOCIAL_AUTH_GITHUB_KEY = '442aea3aeb0402d9a95b'
SOCIAL_AUTH_GITHUB_SECRET = '90d906e0e4172a9c1eed641e9add54a6c12cbb08'</pre>
						<span class="spec">проверь чтобы не где небыло лишних пробелов!</span>
					</li>
					<li>
						Настройка oauth завершена, можно пользоваться в представлениях, в шаблонах
					</li>				
				</ul>
			</li>
			<li>
				В корневой папке books - создаём папку templates
			</li>
			<li>
				В settings.py - TEMPLATES - DIRS - добавляем
				<pre>'DIRS': ['templates'],</pre>
			</li>
			<li>
				Создаём шаблон oauth.html - делаем изначальный шаблон - добавим bootstrap cdn - В body - добавим ссылку на аутентификацию через github
				<pre>
&lt;a href="{% url "social:begin" "github" %}">GitHub&lt;/a></pre>
			</li>
			<li>
				Сделаем функцию представления для шаблона oauth.html
				<pre>
def my_auth(request):
    return render(request, 'oauth.html')</pre>
			</li>
			<li>
				Добавим маргрут в urlpatterns
				<pre>
from store.views import ..., my_auth	

path('auth/', my_auth, name='my_auth'),</pre>
			</li>
			<li>
				Переходим - http://127.0.0.1:8000/auth/
				<br>При нажатии ссылки нас отправит на github для разрежения аутентификации
				<br>Авторизуемся на github - и нас отправит обратно на нашу домашнюю страницу, тестового веб сервера
			</li>
			<li>
				Зайдём в админ панель - и видим что у нас отображается приложение - PYTHON SOCIAL AUTH - в User social auths - есть пользователь с гитхабом - всё отлично, так же есть user в пользователях
			</li>
		</ol> 
	


&lt;





		<h3 class="title_text">[5].  CRUD через REST Framework</h3>
		<hr>

		<ol>

			<li>
				CRUD - create reade update delete - создание чтение редкатирование удаление
			</li>
			<li>
				СRUD при помощи MoodelViewSet - в нём есть всё из коробки
				<br>Посмотри из каких классов 'смиксирован ' MoodelViewSet (Ctrl+ЛКМ):
				<pre>
class ModelViewSet(mixins.CreateModelMixin,
                   mixins.RetrieveModelMixin,
                   mixins.UpdateModelMixin,
                   mixins.DestroyModelMixin,
                   mixins.ListModelMixin,
                   GenericViewSet):					
				</pre>
				По сути сразу становится  всё понятно
			</li>
			<li>
				Postman - программа для эмуляции запросов (GET, POST, PUT, DELETE..)<br>
				<a href="https://www.postman.com/">https://www.postman.com/</a>
			</li>
			<li>
				Запустим сервер - http://127.0.0.1:8000/book/ - и перейдём в панель разработчика (хром) - Network - book/ - Cookie: копируем полностью и
				<br>Вставляем в postman - Run - Headers - в столбце VALUES
				<br>
				<img src="images\SPD\postman.jpg" class="img-fluid">
				<br>
			</li>
			<li>
				Что бы создать какуюто запись необходим запрос POST, при попытке нам опять дась запрет - для исправления в о второй записи таблицы Header Добавим значения
				<pre>
KEY:
X-CSRFToken

VALUE:
MnjUFIwCRsFNjrzrSjwoN03tTJOjJmsJ
#ЭТО csrf token - из того же Cookie</pre>
			</li>
			<li>
				Запрашиваем POST всё проходит но пишет
				<pre>
"name": [
    "Обязательное поле."
],
"price": [
    "Обязательное поле."
],
"author_name": [
    "Обязательное поле."
]</pre>
				Это рещультат валидиции нашего сериализаторы - BookSerializer - он не допускает создания пкстых записей
			</li>
			<li>
				В postman - Body (POST) - отправим JSON запрос (Body - raw - JSON)
				<pre>
{"name": "Python 3",
"price": "150",
"author_name": "Mark Summerfield"}

-->
	
{
    "id": 4,
    "name": "Python 3",
    "price": "150.00",
    "author_name": "Mark Summerfield"
}</pre>
				Всё отлично сработало, запись сделана, валидацию мы прошли

			</li>
			<li>
				Попробуем сделать ошибку в заполнении
				<pre>
{"name": "Python 4",
"price": "1500000000000",
"author_name": "Mark"}

--->
{
    "price": [
        "Убедитесь, что вы ввели не более 7 цифры."
    ]
}</pre>
				Валидацию не прошли - так как неправильно заполнили одно поле (не прошли условие поля которое прописывали в модели Book)
			</li>
			<li>
				PUT - изменение данных, для того что бы пут был разрешёл, в urle необходимо добавить id обхекта, иначе будет -     "detail": "Метод \"PUT\" не разрешен."
				<br>url
				<pre>127.0.0.1:8000/book/4/</pre>
				<br>Body
				<pre>
{"name": "Пайтон 3",
"price": "150.00",
"author_name": "Марк Шумерфилд"
}</pre>
				Всё отлично сработало
			</li>
			<li>
				DELETE - удалмть - аналогично в PUT - указать ID - удалится запись
			</li>
			<li>
				Переходим во Views.py - переделаем так чтобы получать книги можно было всем - а изменять удалять возможно только авторизованные пользователи.
				<br>class BookViewSet(ModelViewSet): - меняем permission_classes
				<pre>
from rest_framework.permissions import ..., IsAuthenticatedOrReadOnly	

class BookViewSet(ModelViewSet):
	...
    # только авторизованные пользователи могут изменять записи - а смотреть могут все
    permission_classes = [IsAuthenticatedOrReadOnly]
	...</pre>
			</li>
			<li>
				23:00 видео <a href="https://www.youtube.com/watch?v=Q18WTrnK3e8&list=PLyaCd9XYVI9DiMvYl-8OdZk7ktc6NQWrb&index=5&t=211s">https://www.youtube.com/watch?v=Q18WTrnK3e8&list=PLyaCd9XYVI9DiMvYl-8OdZk7ktc6NQWrb&index=5&t=211s</a>
			</li>
			<li>

			</li>
			<li>

			</li>
			<li>

			</li>
			<li>

			</li>
		</ol>
	


&lt;





		<h3 class="title_text">[6]. Permissions</h3>
		<hr>

		<ol>

			<li>

			</li>
			<li>

			</li>
			<li>

			</li>
			<li>

			</li>
		</ol>
	


&lt;





		<h3 class="title_text">[7]. Like, Bookmarks, Rating</h3>
		<hr>

		<ol>

			<li>

			</li>
			<li>

			</li>
			<li>

			</li>
			<li>

			</li>
		</ol>
	


&lt;





		<h3 class="title_text">[8]. Annotate и агрегация</h3>
		<hr>

		<ol>

			<li>

			</li>
			<li>

			</li>
			<li>

			</li>
			<li>

			</li>
		</ol>
	


&lt;






		<h3 class="title_text">[9]. Оптимизация SQL запросов в ORM</h3>
		<hr>

		<ol>

			<li>

			</li>
			<li>

			</li>
			<li>

			</li>
			<li>

			</li>
		</ol>
	


&lt;






		<h3 class="title_text">[10]. Кеширующие поля</h3>
		<hr>

		<ol>

			<li>

			</li>
			<li>

			</li>
			<li>

			</li>
			<li>

			</li>
		</ol>
	


&lt;










		<h3 class="title_text">[0]. Название</h3>
		<hr>

		<ol>

			<li>

			</li>
			<li>

			</li>
			<li>

			</li>
			<li>

			</li>
		</ol>
	


&lt;


		



	</div><!-- container-md all -->
&lt; &lt; &lt;

<!-- # Ctrl + Alt + L  -->





<!-- JS Bootstrap 5 -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-gtEjrD/SeCtmISkJkNUaaKMoLD0//ElJ19smozuHV6z3Iehds+3Ulb9Bn9Plx0x4" crossorigin="anonymous"></script>


</body>
</html>


