<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- css bootstrap 5 -->
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x" crossorigin="anonymous">

	<title>selfedu-django3 - конспект курса</title>

	<style type="text/css">
		
		pre{
			color: black;
			background: #c6ffe3;
			margin-right: 30px;
			margin-left: 15px;
			margin-bottom: 2px;
			margin-top: 5px;
		}
		
		.all{
			background: #2C4352;
			color: white;

		}
		
		body{
			background: #b7e2ff;
		}
		
		.spec {
			font-size: 18px;
			letter-spacing: .2em;
			font-weight: 500;
/*			text-transform: uppercase;*/
			color: #ff7575;
			margin-top: 15px;
			margin-bottom: 2px;
		}

		.title_text {
			letter-spacing: .1em;
			font-weight: 500;
			color: #f2cb71;

		}

	</style>


&lt; &lt; &lt;
</head>


<body>
	<p><a href="https://www.youtube.com/@selfedu_rus">selfedu</a></p>
	<p><a href="https://www.youtube.com/watch?v=FyTL1bnUx5I&list=PLA0M1Bcd0w8xO_39zZll2u1lz_Q-Mwn1F">Django 3 для Python(плейлист)</a></p>
	<p><a href="https://django.fun/ru/articles/tutorials/">Статьи о Django</a></p>
	<p><a href="https://habr.com/ru/post/514348/">Шесть Python-пакетов, которые рекомендуется использовать в каждом веб-приложении на Django</a></p>
	<p><a href="https://django.fun/ru/docs/">Документация по фреймворку и библиотекам Django</a></p>
	<p><a href="https://translated.turbopages.org/proxy_u/en-ru.ru.5b0ed4c9-6378aa3f-3f4ce05c-74722d776562/https/hackr.io/blog/top-django-interview-questions-and-answers">50 лучших вопросов и ответов для интервью Django на 2022 год</a></p>

	<div class="container-md all">
		<h1 class="title_text">YouTube selfedu</h1>
		<br>
		<h4 class="title_text">Django 3 для Python</h4>
		<br>

		<h4 class="title_text border">[1]. Django - что такое, порядок установки.</h4>
		<ol>
			<li>Django - фреймворк, для работы на стороне сервера - backend - на языке программирования - Python</li>
			<li>Фреймворк - это обвёртка для языка программирования, для упрощения работы</li>
			<li><span class="spec">Взаимодействие Пользоветеля-Сервера-Фреймворка</span>
				<br>
				<img src="images\request-render.jpg" class="img-fluid">
				<br>
				Запрос от пользователя --> сервер &lt;-WSGI-> Django --> Модели, функции, БД, Шаблоны--> Django --> Сервер --> ответ пользователю
			</li>
			<li>
				WSGI (Web Server Fateway Interface) - стандарт взаимодействия между Python программой на стороне сервера, и вебсайтом.
			</li>
			<li>
				У Django есть свой отладочный сервер - на localhost = http://127.0.0.1:8000/ - Но в итоге сайты размещаются на ориендуемых сервеах - Хостингах
			</li>
			<li>Для того чтобы всё правильно работало - желательно исользовать одни и теже версии продуктов Python и Django - для этого создаётся вируальное окружение для проекта - venv. При этом на ПК можно будет обнавлять версии, и они могут отличатся от версий виртуального окружения</li>
			<li>
				<p class="spec">Устанавливаем и проверяем Python на ПК</p>
				<ol type="A">
					<li>На оф сайте - скачиваем и устанавливаем последнюю версию</li>
					<li>Скачиваем и устанавливаем сторонний эмулятор конольного окна Windows - ConEmu - Она удобней встроенной</li>
					<li>При первом запуске ConEmu - Обязательно в окне выбрать [Shels::cmd(Admin)]</li>
					<li>
						Для проверки интерпритаора питона, в cmd пишем:
						<pre>
python -V  #Должно вывести текущую версию Python на ПК</pre>
					</li>
					<li>
						Для просмотра всех установленных пакетов на ПК, в сmd:
						<pre>
pip list 
#покажет все установленные пакеты и их версии(Pillow, pip, psycopg2, Django,django-crispy-forms) - если они установлены
#это пакеты в глобальном окружении - то-есть на ПК
#В каждом venv - необходиму будет устанавливать дополнительно</pre>
						pip(менеджер пакетов) - система управления пакетами, которая используется для установки и управления программными пакетами, написанными на Python.
					</li>
				</ol><!-- устанавливаем django -->
			</li><!-- устанавливаем django -->

			<li>
				<p class="spec">Устанавливаем Глобальное окружение</p>
				<ol type="A">
					<li>Создаём папку где будут проекты selfedu/создаём папку где будет проект один из
						<br>
						C:\Хранилище\IT\IT Разное\Обучение\YouTube_selfedu\djsite
					</li>
					<li>Внутри папки \YouTube_selfedu\djsite - будем устанавливать venv</li>
					<li>
						В cmd - переходим в эту папку
						<pre>
cd C:\Хранилище\IT\IT Разное\Обучение\YouTube_selfedu\djsite</pre>
					</li>
					<li>Создаём окружение (созможно до этого необходимо было установить в глобальном окружении)- но у меня уже было.>
						<br>В cmd (в итоге создастся папка окружения):
						<pre>
python -m venv venv2020
#где venv2022 - это имя окружения</pre>
					</li>
					<li>
						Заходим в окружение. В cmd - \YouTube_selfedu\djsite:
						<pre>
.\venv2022\Scripts\activate</pre>
						Теперь мы в окружении (venv2022)
					</li>
					<li>
						Проверяем pip list
						<pre>
pip list</pre>
						У нас всего 2 пакета pip и setuptools (в глобальном гораздо больше)
					</li>
					<li>
						Можно обновить pip - внутри окружения в cmd:
						<pre>
python.exe -m pip install --upgrade pip</pre>
					</li>
					<li>
						Чтоыбы выйти из окружения достаточно в cmd - (venv2022) .. \YouTube_selfedu\djsite
						<pre>
deactivate</pre>
					</li>
				</ol><!-- устанавливаем venv -->
			</li><!-- устанавливаем venv --------------------------------------------------------------->
			<li>
				<p class="spec">Устанавливаем Django</p>
				<ol type="A">
					<li>Django можно установить и через терминал PyCharm</li>
					<li>
						В PyCharm - создаём новый проект
						<pre>
Location: C:\Хранилище\IT\IT Разное\Обучение\YouTube_selfedu\djsite
Previoursly configured iterpretetre: ....\djsite\venv2022\Scripts\python.exe
						</pre>
					</li>
					<li>Жмём терминал - теперь этот проект автоматически будет в виртуальном окружении -(venv2022) C:\Хранилище\IT\IT Разное\Обучение\YouTube_selfedu\djsite></li>
					<li>Создалась папка .idea - незнаю пригодится ли</li>
					<li>Можжно вручную открыть venv2022 для этого в PyCharm:
						<br>File - Settings - Project:djsite - Python Interpritator - venv2022 - там же и будет показыватся все установленные пакеты в venv2022
					</li>
					<li>
						<span class="spec">Размер шрифта в SublimeText:</span>
						<br>Preferens - Font - Larger/Smaller/Reset
					</li>
					<li>
						Устанавливаем джанго через PyCharm терминал - в 
						<br>(venv2022) C:\Хранилище\IT\IT Разное\Обучение\YouTube_selfedu\djsite>
						<pre>
pip install django #устанавливаем пакет django в venv2022
#это ядро(пакет) - тоесть проект мы не создавали, никаких файлов не появляется в папке</pre>
					</li>
					<li>
						Список команд Django  - в терминале PyCH
						<pre>
django-admin</pre>
					</li>
					<li>В терминале так же работает 'cls' - очистить терминал</li>
					<li>
						В терминале YouTube_selfedu\djsite> создаём django -проект
						<pre>
django-admin startproject coolsite
#где coolsite - это и есть наш проект</pre>
					</li>
					<li>переходим в djsite/coolsite - запускаем сервер
						<pre>
python manage.py runserver</pre>
					</li>
					<li>
						Можно проверить работоспособность - в браузере - http://127.0.0.1:8000/
					</li>
					<li>Для остановки сервера так же работает ctrl+c</li>
					<li>
						Django работает со многими СУБД - PostgreSQL, MySQL, Oracle, SQLite..
					</li>
					<li>Можно запустить отладночный сервер на другом порте, например http://127.0.0.1:4000/:
						<pre>python manage.py runserver 4000</pre>
					</li>
				</ol><!-- устанавливаем Django -->
			</li><!-- устанавливаем Django ------------------------------------------------------>
			
			<br><br>
			


			<h4 class="title_text border">[2]. Модель MTV. Маршрутизация. Функции представления</h4>
			<li><span class="spec">Механизм обработки запроса от пользователя в Django</span>
				<br>
				<img src="images\mtv.jpg" class="img-fluid">
				<br>
				<p>
					-От пользователя приходит запрос (url)
					<br>-В маршрутизаторе идёт поиск url(path) - и ищется первое нужное значение
					<br>- . . . . 
				</p>
			</li>
			<li>
				Пути по слагу или индексу:
				<pre>
http://127.0.0.1:8000/   -  path('')
http://127.0.0.1:8000/category/1   -  path('category/&lt;id(число)>')
http://127.0.0.1:8000/women/madonna   -  path('women/&lt;slug(строка)>')
				</pre>
				Если совпадений никаких нк будет - выведет страницу 404
				
			</li>
			<br>
			<br>
			<li>
				<img src="images\madonna.jpg" class="img-fluid">
				<br>
				<p>-Приходит запрос от пользователя:					
					<br>-Функция view - берёт данные из models.py
					<br>-models.py - берёт данный из Бызы данных
					<br>-В шаблоне собирается информация
					<br>-Всё это формируется в views и отправляется пользователю, в виде html страницы
				</p>
			</li>
			<li>
				<span class="spec">MTV = Models + Templates + Views</span>
			</li>
			<li>Кааждая самостоятельная часть сайта, должны быть представленна в виде отдельного приложения (Основное приложение, Форум, Блог, Магазин)
				<br>Приложения желательно делать максимально независимыми, чтобы можно было воспользоваться в другом проекте например. Как минимум к этому необходимо стремится.
			</li>


			<li>
				<p class="spec">Создаём приложение django - app</p>
				<ol type="A">
					<li>
						В терминале - djsite\coolsite:
						<pre>
python manage.py startapp men
#где men - название приложения</pre>
					</li>
					<li>
						<span class="spec">Назначение файлов django внутри приложения</span>
						<br>admin.py - связь приложения с админ панелью
						<br>apps.py - настройка текущего приложения
						<br>models.py - для хранения ORM моделей (представление данных из базы данных)
						<br>test.py - модуль с тестирующими процедурами
						<br>views.py - хранение представлений (функции)
					</li>
				</ol><!-- устанавливаем django - app -->
			</li>	<!-- устанавливаем django - app ------------------------------------------------------>		
			<li>
				<p class="spec">Регистрируем приложение</p>
				<ol type="A">
					<li>В coolsite/coolsite/settings.py
						<br>[INSTALLED_APPS] - добавляем наше приложение
						<pre>
INSTALLED_APPS = [...., 'men.apps.MenConfig',]
#будет обращатся в coolsite/men/apps.py - class MenConfig(AppConfig)
						</pre>
					</li>
				</ol><!-- Регистрируем приложение -->
			</li>	<!-- Регистрируем приложение ------------------------------------------------------>
			<li>
				Далее заходим  в men/views.py  - создаём функцию index
				<pre>
def index(request): #request - информация о запросе, сессии, 'куках''
	return HttpResponse('Страница приложения men') #HttpResponse - ответ</pre>
			</li>
			<li>
				HttpResponse - необходимо имортировать в men/views.py
				<pre>
from django.http import HttpResponse #импортировали</pre>
			</li>
			<li>
				В coolsite/urls.py - импортируем нашу функцию
				<pre>
from men.views import index 
# импортировали из men/views.py  - def index</pre>
			</li>
			<li>
				В coolsite/urls.py - добавляем путь (все пути добаляются в список urlpatterns)
				<pre>
path('men/', index),
#где 'men/' - путь url  - localhost/men
#index - функция из men/views.py</pre>
			</li>
			<li>Делаем нашу папку - рабочим каталогом, чтобы ничего личшенего не подчёркивалось
				<br>В PyCharm - внешнюю папку coolsite - пкм - MarkDirectory - Sourcec Root
			</li>
			<li>
				Запускаем сервер - в браузере http://127.0.0.1:8000/men - всё работает
				<br>-В views.py можно добавить html теги h1 - чтобы в браузере отображалось как заголовок
			</li>
			<li>
				В men/views.py - добавим ещё одну функцию - категории
				<pre>
def categories(request):
    return HttpResponse('&lt;h1>Статьи по категориям&lt;/h1>')</pre>
			</li>
			<li>
				В coolsite/urls.py - обавим ещё один путь для категорий, перед этим функцию необходимо импортировать 
				<pre>
from men.views import index, categories

path('cats/', categories),  # категории</pre>
			</li>
			<li>
				Чтобы импортировать все функции изменяем наш импорт views.
				<pre>
from men.views import index, categories   --->   from men.views import *
# импортировали из men/views.py  - все функции</pre>
				В браузере проверяем - http://127.0.0.1:8000/cats/ - всё работает
			</li>
			<li>
				В coolsite/urls.py корректируем путь главной страницы
				<pre>
path('men/', index),  --> path('', index)</pre>
				Теперь она будет открываться по пути - http://127.0.0.1:8000/
			</li>
			<li><span class="spec">Перенесём пути внутрь приложения</span>
				<ol type="A">
					<li>
						В coolsite/coolsite/urls.py - импортируем функцию include
						<pre>
from django.urls import include  # импорт функции include</pre>
					</li>
					<li>
						В coolsite/coolsite/urls.py - убираем все предыдущии пути - кроме админки, и добавляем путь:
						<pre>
path('men/', include('men.urls')),  # путь к путям  приложения men
						</pre>
					</li>
					<li>
						В men(app) - создадим новый файл - urls.py
					</li>
					<li>
						В men/urls.py импортируем функцию path, из текущей папки (men) - импортируем все прдставления (функции)
						<pre>
from django.urls import path
from .views import *</pre>
					</li>
					<li>
						В men/urls.py - созадём свой список urlpatterns = [], и прописываем пути текущего приложения
						<pre>
urlpatterns = [
    path('', index),  # домашняя страницы приложения - !!!путь - http://127.0.0.1:8000/men/
    path('cats/', categories),  # категории - !!!путь - http://127.0.0.1:8000/men/сats/
]
#men - добавляется из главного urls.py - coolsite/urls.py					
						</pre>
					</li>
				</ol>
			</li>


			<br><br>
			<h4 class="title_text border">[3]. Модель Маршрутизация, обработка исключений запросов, перенаправление</h4>
			<li>
				Переходим в главный urls.py (coolsite/urls.py) - меняем путь к приложению men  - чтобы в путях не было дополнительного пути /men/
				<pre>
path('men/', include('men.urls')),  --> 	path('', include('men.urls')),</pre>
			</li>
			<li>
				<span class="spec">Добавляем в путь числовой параметр</span>
				<ol type="A">
					<li>Для этого, в men/urls.py - корректируем путь категорий
						<pre>
path('cats/&lt;int:catid>/', categories),
# где int - целое число - 1/2/3/4
# catid - имя числового параметра, придумываем сами</pre>
					</li>
					<li>
						В men/views.py - def categories, добавляем имя числового параметра в двух местах.
						<pre>
def categories(request, catid):
	return HttpResponse(f'&lt;h1>Статьи по категориям&lt;/h1>&lt;p>{catid}&lt;/p>')
# где f' - это обычная ф-трока питона
# сatid - наш числовой параметр из пути в urls.py
# {catid} - вывод нашего числа - на html</pre>
						Теперь у нас есть пути http://127.0.0.1:8000/cats/1-2-3-4..9999../
						<br>Но пути http://127.0.0.1:8000/cats/ - больше нет
					</li>
				</ol>	
			</li>
			<li>
				<span class="spec">Какие типы данных мы вожем указывать в path (в шаблонах марщритов) - '&lt;int:id>:</span>
				<br>- str - любая не пустая строка, кроме '/'
				<br>- int - Любое положительное число, включая 0
				<br>- slug - слаг - латиница ASCII таблиц, дефис, подчёркивание
				<br>- uuid - цифры, малые латинские вимволы ASCII, дефис
				<br>- path - любая не пустая строка, включая '/'
			</li>
			<li>
				<span class="spec">функция re_path()</span>
				<ol type="A">
					<li>
						В men/urls.py - Импортируем re_path и добавим путь
						<pre>
from django.urls import path, re_path

re_path(r'archive/(?P&lt;year>[0-9]{4})/', archive),
# &lt;year>[0-9]{4})  -  год должен состоять именно из 4 чисел
# каждая цифра числа должны бть любой от 0 до 9 включительно</pre>
					</li>
					<li>
						В men/views.py - добавляем функцию
						<pre>
def archive(request, year):
	return HttpResponse(f'&lt;h1>Архив по годам&lt;/h1>&lt;p>{year}&lt;/p>')</pre> 
					</li>
					<li>Теперь у нас есть пути:
						<br>http://127.0.0.1:8000/archive/0001..2022..9999/
					</li>
				</ol>
			</li>
			<li>
				<span class="spec">Обработка GET и POST запросов</span>
				<ul>
					<li>url запрос - http://127.0.0.1:8000/?name=Alexandr&cart=music
						<br>name - ключ, Alexandr - значение
						<br>cart - ключ, music - значение
					</li>
					<li>
						Выделяем ключи из GET запроса
						<br>В views.py - def categories - добавляем строчку
						<pre>
print(request.GET)</pre>
						В браузере введём:
						<pre>
http://127.0.0.1:8000/cats/5/?name=Alexandr&cart=music</pre>
						В нашем терминале выдаст словарь ключ - значение, ключ значение
						<pre>
&lt;QueryDict: {'name': ['Alexandr'], 'cart': ['music']}>
[17/Nov/2022 19:04:20] "GET /cats/5/?name=Alexandr&cart=music HTTP/1.1" 200 55</pre>
					</li>
					<li>
						В нашей функции, добавим проверку (Есть ли данные в get запросе?):
						<pre>
if(request.GET):  # если данные в запросе есть
	print(request.GET)	# будет выведен словарь {'ключ:['ззначения']}</pre>
						Если данные будут, тогда в терминале нам покажет словарь
						<br>Если путь будет без GET - http://127.0.0.1:8000/cats/5/ - то ничего показывать не будет, так как гет данных нет
					</li>
					<li>Почти аналогично будет работа с POST запросом (request.POST)<br>POST - запросы обычно работают с формами login/passwod, либо когда отправляют какието изображения на сервер</li>
				</ul>
			</li>
			<li><span class="spec">Обработка исключений при запросах к серверу</span>
				<ul>
					<li>Если будет введён запрос - которого не существует, будет выведена страница 404 - c описанием проблемы  - прри DEBUG = True - в settings.py</li>
					<li>DEBUG = True - обычно только в момент работы над проектом, в итоговом варианте, чтобы пользователи не видели всех ошибок необходимо сделать DEBUG = Fasle/ALLOWED_HOSTS = ['хостинг.ру']
						<br>Для наглядности, в  settings.py меняем 2 строчки на:
						<pre>
DEBUG = False
ALLOWED_HOSTS = ['127.0.0.1']</pre>
						Пробуем запустить сервер и ввести несущестующий адрес, получим страничку нет страницы, но без ошибок. Page Not Found - либо что то подобное
					</li>
					<li>
						-Для того чтобы заменить страницу ошибки, заходим в coolsite/urls.py:
						<pre>
# handler404 - это спец переменная, pageNotFound - наша функция views.py							
handler404 = pageNotFound</pre>
						-В men/views.py - импортируем - HttpResponseNotFound
						-В men/views.py - пишем функцию этой страницы:
						<pre>
from django.http import HttpResponse, HttpResponseNotFound

def pageNotFound(request, exception):
	# exception - если произошли какието исключения, мы должны их обработать
    return HttpResponseNotFound('&lt;h1>Страница не найдена&lt;/h1>')</pre>
    					Теперь при неправильном urle - будет выводится наша страница ошибки
					</li>
					<li>
						Сгенерируем исключение в функции archive - если год будет больше 2022.
						<br>men/views.py - импортируем Http404
						<br>men/views.py - def archive - добавим 2 строчки:
						<pre>
from django.http import HttpResponse, HttpResponseNotFound, Http404

def archive(request, year):	
	if int(year) > 2022:  # если год больше 2022
		raise Http404()  # сгенерируем классом 404
	return HttpResponse(f'&lth1>Архив по годам&lt/h1>&ltp>{year}&lt/p>')</pre>
						Если год будет больше 2022 нас отпрявят к функции pageNotFound - та в своё время откроет нашё страницу - 'Страница не найдена'
					</li>
					<li>http://127.0.0.1:8000/archive/2023..9999/ - нас перенаправит на "страница не найдена"</li>
					<li><span class="spec">Выиды исключений (работают при DEBUG = False)</span>
						<br>-handler404 - страница не найдена (делали выше)
						<br>-handler403 - доступ запрещён
						<br>-handler500 - ошибка сервера
						<br>-handler400 - невозможно обраблтать запрос
					</li>
				</ul>
			</li>
			<li><span class="spec">Создание 301 и 302 редиректов</span>
				<ul>
					<li>
						301 - страница перемещена на другой постоянный URL-адрес
						<br>302- страница перемещена временно на другой URL-адрес
					</li>
					<li>
						В views.py  - импортируем функцию redidect
						<pre>
from django.shortcuts import render, redirect #рендер был изначально</pre>
					</li>
					<li>
						В views.py - в функции archive, поменяем строчку:
						<pre>
raise Http404()  --->  return redirect('/')
#если год будет больше 2022 - нас перенапривит на главную сраницу
						</pre>
						Нас будет направлять на главную страницу
						<br>В терминале будет 302 - [17/Nov/2022 20:18:38] "GET /archive/2023/ HTTP/1.1" 302 0
					</li>
					<li>
						В той же функции поменяем ту же строчку:
						<pre>
return redirect('/', permanent=True)</pre>
						Произойдёт то же самое только в терминале будет 301
					</li>
				</ul>
				<li>
					<ul><span class="spec">Задаём параметр name='имя' - пути path</span>
						<li>
							В men/urls.py - в пути index - задаём параметр name - и присваиваем имя(любое)
							<pre>
path('', index, name='home'),</pre>
						</li>
						<li>
							теперь по имени 'home'- можно ссылкться на домашнюю страницу
							<br>Например в views.py - поменяем
							<pre>
 return redirect('/', permanent=True) --> return redirect('home', permanent=True)</pre>
						</li>
						<li>
							<span class="spec">
								Название приложения можно поменять 'почти без последствий'
							</span>
							<br>Для этого в PyCharm - корневую папку приложения переименовываем (Rafactor/Rename)
							<br>Со всем соглашаемся - PyCharm исправить имя пости везде сам - автоматически (в функциях, в путях и тд)
							<br><strong>Проверь class в apps.py и сопоставь в settings.py - INSTALLED_APPS = []</strong>
						</li>
					</ul>
				</li>
				<li>
					<span class="spec">Работа с git </span> [добавил от себя]
					<ul>
						<li>Скачиваем, уcтанавливаем git</li>
						<li>При установке - обязательно делаем так чтобы могли работать из cmd Windows</li>
						<li>Логинимся на <a href="https://github.com/">https://github.com/</a></li>
						<li>На https://github.com/ - создаём новый репозиторий - обычно название проекта</li>
						<li>Там появится ссылка - куда будем push-ить</li>
						<li>В папке, которую хотим установить git - добавляем файл -.gitignore:
							<br>-Сгенерировать код для django можно на <a href="https://www.toptal.com/developers/gitignore/">https://www.toptal.com/developers/gitignore/</a> можно взять информацию из предыдущих проектов
							<br>-В sublime добавляем код, сохраняем
							<br><strong>-Это необходимо сделать до первого запуска сервера и миграций!</strong>
							</li>
						<li>
							В командной строке (cmd Windows или ComEmu или GitBash) - в корневой(внешней) папке проекта:
							<pre>
git –v  # посмотреть версию git
git init  # инициализируем git репозиторикй- папку на pc
git status  # смотрим какие файлы не отслеживаются на данный момент
git add .  # добавляем все файлы
git status  # смотрим что теперь всё отслеживается
git commit -m "имя коммита(что сделали/стадия)"  # создаём коммит
git remote add origin  - https://github.com/Mello134/репозиторий.git  # туда будем загружать
git branch -M main
git push -u origin main  # отправили на github - в репозитор</pre>
						</li>
					</ul>
				</li>
			<br><br>
			<h4 class="title_text border">[4]. Определение моделей. Миграции: создание и выполнение</h4>
			<li>
				<p>ORM (Object-Relational Mapping) - объектно-реляционноя приложение</p>
				<p>WSGI (англ. Web Server Gateway Interface) — стандарт взаимодействия между Python-программой, выполняющейся на стороне сервера, и самим веб-сервером, например Apache.<br>WSGI предоставляет простой и универсальный интерфейс между большинством веб-серверов и веб-приложениями или фреймворками
				</p>
				<p>Интерфейс прикладного программирования (API) - это соединение между компьютерами или между компьютерными программами. Это тип программного интерфейса, предлагающий услугу другим частям программного обеспечения. Документ или стандарт, описывающий, как построить или использовать такое соединение или интерфейс, называется спецификацией API.</p>
				<p>
					<img src="images\ORM.jpg" class="img-fluid">
				</p>
			</li>
			<li>Простыми словами в django встроен сеханизм взаимодействи с таблицами базы данных через ORM</li>
			<li>
				<span class="spec">Подключаемся проект к базе данных postrgeSQL</span>(добавил от себя)
				<ol type="A">
					<li>Скачиваем устанавливаем PostreSQL</li>
					<li>
						По умолчанию:
						<br>пароль - blog1234
						<br>port - 5432
						<br>Выбираем localhost
						<br>дополнительно ничего не устанавливал
					</li>
					<li>ВХОД В SQL Shell (cmd postgreSQL):
						<pre>
Server [localhost]:Enter
Database [postgres]:Enter
Port [5432]:Enter
Username [postgres]:Enter
Пароль пользователя postgres:blog1234 Enter</pre>
					</li>
					<li>СОЗДАЁМ БАЗУ ДАННЫХ ДЛЯ ПРОЕКТА<br>
						Далее там же в SQL Shell:
						<pre>
psql \! chcp 1251  # чтобы кирилица отображалась корректно
postgres=# \du  # видим всех пользователей
\password postgres  # смена пароля(если необхоимо)
\l  # поомотреть список баз данных на PC
CREATE DATABASE coolsitedb;  #Создали новыую БД(пустую) - для нашего проекта. ';'-обязательно
#ДОЛЖНО ВЫВЕСТИ  - CREATE DATABASE

\l  # поомотреть создалось ли</pre>
						SQL Shell -терминал можно закрывать.
					</li>
					<li>
						Настраиваем Django проект. В settings.py. В словаре DATABASES = {}: - удаляем или комментируем строчки
						<pre>
'ENGINE': 'django.db.backends.sqlite3',# стандартная DB
'NAME': BASE_DIR / 'db.sqlite3', #стандартная DB</pre>
						Там же в settings.py - связываем наш проект с db
						<br>DATABASES = {} - добавляем код:
						<pre>
'ENGINE': 'django.db.backends.postgresql',  # поменяли на postgresql - джижок постгрес
'NAME': 'coolsitedb',  # поменяли на - имя нашей БД
'USER': 'postgres',  # пользователь postgres - который создал БД
'PASSWORD': 'blog1234',  # пароль в PostgreSQL, для пользователя postgres
'HOST': '127.0.0.1',  # либо просто'localhost'
'PORT': '5432',  # стандартный порт</pre>
						Сохраняемся и получаем ошибку - Error loading psycopg2 module: No module named 'psycopg2'
					</li>
					<li>Psycopg2 – это база данных PostgreSQL. драйвер, который служит клиентом Python для доступа к серверу PostgreSQL.
						<br>В терминале внутри виртуального окружения устанавливаем:
						<pre>
pip list  # видим что psycopg2 действительно не установлен в окружении
pip install psycopg2</pre>
					</li>
					<li>
						Можно запустить сервер runserver - и убедится что всё работает!
					</li>
					<li>
						Таблицы баз данных можно смотреть наглядно pdAdmin 4 (есть русский интерфейс)
					</li>
				</ol>
			</li>
			<li>
				Будем создавать модель для men по данной структуре (заголовки столбцов):
				<br>-id: integer, primary key  - идентефикатор записи, номер
				<br>-title: Varchar - заголовок статьи (строка из определенного числа символов)
				<br>-content: Text - сама статься - тект
				<br>-photo: Image - изображение
				<br>-time_create: DataTime - дата создания
				<br>-time_update: DataTime - дата обновления
				<br>-is_publisher: Bolean - опубликовано/неопубликовано True/False
				<br><br>Нам необходимо будет сделать класс с этими полями и сделать миграцию
			</li>
			<li>
				Создаём класс Men в men/models.py:
				<pre>
from django.db import models  # было изначально

class Men(models.Model):  # наследуем все функции для нашего класса Men от Django класса Model
    # Id прописывать не нужно - Model Это делает автоматически
    title = models.CharField(max_length=255)  # длина 255 символов
    content = models.TextField(blank=True)  # текстовое поле без ограничений, blank=True - поле может быть пустым
    photo = models.ImageField(upload_to='photos/%Y/%m/%d')  # загружать будем в photos/год/месяц/день
    time_create = models.DateTimeField(auto_now_add=True)  # дата время - создание, auto_now_add=True - создастся единожды
    time_update = models.DateTimeField(auto_now=True)  # дата время - изменение, auto_now=True - будет менятся с каждым изменением
    is_publisher = models.BooleanField(default=True)  # default=True</pre>
			</li>
			<li>Почитай документацию Models - поле FileField - загрузка файлов(любых) в ней описано как настраивать MEDIA_ROOT, MEDIA_URL</li>
			<li>
				После сохранения models.py - выбаёт ошибку - Cannot use ImageField because Pillow is not installed.
				<p>
					Pillow - Библиотека изображений Python, или PIL (Python Imaging Library) нужна для обработки графики в Python, в том цисле загрузки изображений в models.py
				</p>
				<br>В терминале останавливаем сервер и устанавливаем пакет Pillow (внутри окружения)
				<pre>
python -m pip install Pillow  # устанавливаем пакет
pip list  # убедились что пакет в окружение утсановлен</pre>
			</li>
			<li><span class="spec">Настраиваем MEDIA_ROOT, MEDIA_URL</span>
				<br>В settings.py после static.url добавляем две строчки:
				<pre>
MEDIA_ROOT = BASE_DIR / 'media'  # будет загружать медия в папку media
MEDIA_URL = '/media/'  # добавили url - будет отображатся в браузере</pre>
			</li>
			<li><span class="spec">Дополнительно: Настраиваю время МСК и русский язык в админке</span>
				<br>settings.py - меняем две строчки кода
				<pre>
LANGUAGE_CODE = 'ru-Ru'  # русский язык в admin
TIME_ZONE = 'Europe/Moscow'  # время по МСК</pre>
			</li>
			<li>
				Для эмуляции работы сервер для получения ранее загруженных файлов, и передачи их нашему приложению. Для этого в coolsite/urls.py - импоритуем settings.py и после urlpatterns - добавим 2 строчки кода:
				<pre>
from django.conf.urls.static import static  # для DEBUG пути
from coolsite import settings  # для DEBUG пути

if settings.DEBUG:
    # к путям добавляем путь к статическим данным, графическим данным
    # на реальныъ серверах обычно это не используется
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)</pre>
			</li>
			<li>
				В settings.py - DEBUG вернём к зачению True
				<pre>
DEBUG = True</pre>
			</li>
			<li>
				<span class="spec">Создаём и выполняем миграции</span>
				<br>
				-Миграции Django-это файлы Python, которые помогают добавлять и изменять данные в таблицах базы данных для отражения изменений в моделях Django.
				<br><br>
				-При выполнении миграции в Django - в базе данных создаутся новые, или изменяются старые таблицы базы данных нашех моделей(классов) - по этому после измененив в моделях в models.py - необходимо делать миграции.
				<br><br>
				-На практике желательно избегать изменения структуры таблиц, и продумывать модели заранее.
				<ol type="A">
					<li>
						В терминале, в вируальном окружении, в корневой папке проекта - coolsite, пишем, для создания миграции:
						<pre>
python manage.py makemigrations</pre>
					</li>
					<li>
						В папке migrations - появится новый файл - 0001_initial.py - он служит для того чтобы создавать таблицы в базе данных, информацию можно посмотреть внутри файла
					</li>
					<li>
						Можно посмотреть sql запрос, который будет выполнятся для данной миграции, для этого в терминале пишем:
						<pre>
python manage.py sqlmigrate men 0001
#где men - наша модел Men, 0001 - порадковый номер 0001_initial.py</pre>
						Терминал покажет нам SQL запрос
					</li>



					<li>Далее применяем(выполняем) миграцию, в терминале:
						<pre>
python manage.py migrate</pre>
						Помимо наших миграций, выполнены изначальные миграции для djando - (админка, аутентификация и так далее)
					</li>
					<li>
						Таблмцу нашего класса теперь можно посмотреть с базе данных (она уже там создана)
						<br>Для этого используем pgAdmin 4:
						<br>-Servers
						<br>-PostreSQL
						<br>-Базы данных
						<br>-Схемы
						<br>-public
						<br>-Таблицы
						<br>-men_men  # название приложения_название модели(класса)
						<br>-View Data (значек таблицы)
						<br><br>Видно что по сути мы создали пустую таблицу,  толко столбцы - заполнять будем далее, через админ панель или например с помощью ORM
					</li>
				</ol>
			</li>

			<br><br>
			<h4 class="title_text border">[5]. CRUD - основы ORM по работе с моделями</h4>
			<li>
				CRUD: Create-создание / Read-чтение / Update-изменение / Delete-удаление
			</li>	
			<li>Использование ORM фреймфорка Django - Можно быполнять все вышеуказанные операции. Для большинства проектов (почти всех!), Django - нет необходимости напрямую переходить на SQL-рапросы. ORM django - достаточно мощная штука</li>
			<li>Каждый экземпляр класса - это по сту строчки в таблице</li>
			<li>
				Переход в консоль Django - Для работы с командами ORM. В терминале:
				<pre>
python manage.py shell  # вход в консоль django					
				</pre>
			</li>
			<li>
				Импортируем наш класс в терминал
				<pre>
#из men/models.py - импортируем модель(класс) - Men</pre>
			</li>
			<li>
				Добавляем информацию в таблицу. В shell django:
				<pre>
Men(title="Том Круз", content="Биография Тома Круза")  # указали данные но они ещё не записаны в БД
w1 = _  # '_' - сохраняет в себе последние действия, т.е в переменную w1 - мы записали то что писали в предыдущем коде. 
w1  # &lt;Men: Men object (None)> - вот что теперь в переменной w1. (None) - это id - пока не записали в таблицу
w1.save()  # теперь мы сохранили данные в нашу таблицу, можно ибудится в pdAdmin 4</pre>
				Как видим все поля заполнились. title,content -мы заполнили / time_create, time_update, is_publisher - автоматичекм, так как мы это прописывали в создании модели. / photo - на данный момент поле пустое, так как изображения мы не загружали.
			</li>
			<li>
				Можем оперировать всеми значениями нашей запси:
				<pre>
w1.id  -->  1
w1.time_create  -->  datetime.datetime(2022, 11, 18, 15, 46, 39, 456330, tzinfo=datetime.timezone.utc)
w1.title  -->  'Том Круз'</pre>
			</li>
			<li>
				pk - совпадает со знаечнием id.
			</li>
			<li>
				Посмотрим на SQL запрос который был выполнен для дополнения вышеуказанной записи, там же в django shell:
				<pre>
from django.db import connection  # импортировали модуль
connection.queries  # запрашиваем sql запрос

-->[{'sql': 'INSERT INTO "men_men" ("title", "content", "photo", "time_create", "time_update", "is_publisher") VALUES (\'Том Круз\', \'Биография
 Тома Круза\', \'\', \'2022-11-18T15:46:39.456330+00:00\'::timestamptz, \'2022-11-18T15:46:39.456330+00:00\'::timestamptz, true) RETURNING "m
en_men"."id"', 'time': '0.000'}]  # это и есть sql - запрос</pre>
			</li>
			<li>
				Создадим ещё одну запись в таблицу:
				<pre>
# здесь сразу присвоили в переменной w2
w2 = Men(title="Марк Уолберг", content="Биография Марка Уолберга")
w2.save()  #сохранили в таблице БД</pre>
			</li>
			<li>
				Добавлять данные можно поочерёдно (отдельно title, content):
				<pre>
w3 = Men()  # Создали пустую запись
w3.title = 'Вечаслав Бутусов'  # Добавили заголовок
w3.content = 'Биография Вечаслава Бутусова'  # Добавили контент
w3.save()  # занесли в таблицу Базы данных</pre>
			</li>
			<li>
				Каждый класс модели содержит специальный статический объект objects. - Бедётся из базового класса модели Model и представляет собой ссылку на специальный класс Manager (менеджер записей)
				<pre>
Men.objects  -->  &lt;django.db.models.manager.Manager object at 0x00000188D081FC90>
				</pre>
			</li>
			<li>
				Метод добаления записей create()
				<pre>
Одной строчкой сделали запист в базу данных
w4 = Men.objects.create(title="Александр Овечкин", content="Биография Александра Овечкина")
#можно записать даже без w4 = </pre>
			</li>
			<li>
				Добавим ещё запись:
				<pre>
 Men.objects.create(title="Юрий Каспарян", content="Биография Юрия Каспаряна")</pre>
			</li>
			<li>
				Читаем данные из таблицы:
				<pre>
Men.objects.all()  # чтение всех записей
&lt;QuerySet [&lt;Men: Men object (1)>, &lt;Men: Men object (2)>, &lt;Men: Men object (3)>, &lt;Men: Men object (4).......(5)>]></pre>
				Как видим из этих записей мало что понятно, для изменения этого в модели необходимо прописать метод отображения __str__()
			</li>
			<li>
				Специальные методы __str__ и __repr__ отвечают за строковое представления объекта. При этом используются они в разных местах.
				<br><br>
				Прописываем метод __str__ в модели Men (men/models.py class Men) - снизу после всех полей модели(класса):
				<pre>
# с помощью метода запись нашего класса будет выводится по её заголовку
def __str__(self):
	return self.title</pre>
				Сохраняем models.py
			</li>
			<li>
				Опять пробуем читать таблицу, перед этим необходимо перезайти в django shell
				<pre>
exit() 
python manage.py shell
from men.models import Men
Men.objects.all()

Выведет -->	&lt;QuerySet [&lt;Men: Том Круз>, &lt;Men: Марк Уолберг>, &lt;Men: Вечаслав Бутусов>, &lt;Men: Александр Овечкин>, &lt;Men: Юрий Каспарян>]></pre>
			</li>
			<li>
				Выбираем отдельные элементы списка QuerySet:
				<pre>
Men.objects.all()  # посмотрели все записи в списке QuertSet
w = _  # записали их в переменной w
w[0]  # 0 индекс --> &lt;Men: Том Круз>
w[0]  # 4 индекс --> &lt;Men: Юрий Каспарян></pre>
			</li>
			<li>
				Обращаемся к отдельным полям:
				<pre>
w[1].title  -->  'Марк Уолберг'
w[3].content  -->  'Биография Александра Овечкина'</pre>
			</li>
			<li>
				Длинна списка (количество записей):
				<pre>
len(w)  -->  5</pre>
			</li>
			<li>
				Перебираем все заголовки нашех записей, циклом for:
				<pre>
for wi in w:  # wi это просто переменная
    print(wi.title)  # выведет просто все заголовки с новой строки

Том Круз
Марк Уолберг
Вечаслав Бутусов
Александр Овечкин
Юрий Каспарян</pre>
			</li>
			<li>
				<span class="spec">Метод filter()</span>
				<pre>
Men.objects.filter(title="Александр Овечкин")  --> &lt;QuerySet [&lt;Men: Александр Овечкин>]></pre>
				По критерию Алекс Овечкин, выведутся все записи, в нашем случае такая запись одна
			</li>
			<li>
				Посмортим sql запрос.
				<pre>
from django.db import connection
connection.queries</pre>
			</li>
			<li>Если мы обратимся методом filter() - и не будет ни одного совпадения, нам выдаст просто пустой список</li>
			<li>
				Обращение методом filter() - по id [pk]
				<pre>
Men.objects.filter(pk=2)  # обращаемся по pk 2
&lt;QuerySet [&lt;Men: Марк Уолберг>]></pre>
			</li>
			<li>
				Ряд спецификаторов позволяют найти объекты, свойства которых больше или меньше определенного значения: gt (>), gte (>=), lt (&lt;), lte (&lt;=)
				<pre>
Men.objects.filter(pk__gte=2)  # выведет записи у которых id >= 2
&lt; QuerySet [&lt; Men: Марк Уолберг>, &lt; Men: Вечаслав Бутусов>, &lt; Men: Александр Овечкин>, &lt; Men: Юрий Каспарян>]></pre>
			</li>
			<li>
				<span class="spec">Метод exclude()</span>
				<br>Работает противоположно методу filter()
				<pre>
Men.objects.exclude(pk=2)  # выведет все записи кроме записи с id[pk] 2</pre>
			</li>
			<li>
				<span class="spec">Метод get()</span>
				<br>Когда нам нужно выбрать строго определённую запись по строго определённому критерию, лучше использовать метод get()  - хотя и тот же filter() также сработает
				<pre>
 Men.objects.get(pk=2)  # вывкедет запись по id = 2</pre>
 				Метод get() - используется при авторизации пользователя например
			</li>
			<li>
				order_by - сортировка
				<pre>
Men.objects.filter(pk__lte=4).order_by('title')
&lt;QuerySet [&lt;Men: Александр Овечкин>, &lt;Men: Вечаслав Бутусов>, &lt;Men: Марк Уолберг>, &lt;Men: Том Круз>]>					
#то есть мы выбрали все ключи у которого id	&lt;= 4, и отсортировали по полю title
# методы можно писать сразу в цепочку</pre>
			</li>
			<li>просто отсортируем весь список:
				<pre>
Men.objects.order_by('title')</pre>
				Вместо поля title - можно использывать любое другое поле
			</li>
			<li>
				Изменение записи в таблице:
				<pre>
wu = Men.objects.get(pk=1)  # порчитали и записали в переменную по pk=1 (Том Труз)
wu.title = 'Брэд Питт'  # Изменили заголовок
wu.content = 'Биография Брэда Питта'  # Изменили контент
wu.save()  # записали в таблицу БД
wu  # проверили</pre>
			</li>
			<li>
				<span class="spec">Удаление записей из БД. Метод delete()</span>
				<pre>
 wd = Men.objects.filter(pk__gte=4)  # выбрали все записи pk >= 4 (4 и 5)
 wd  # посмотрели что это за записи
 wd.delete() -->  (2, {'men.Men': 2})  # означает что удалили 2 записи</pre>
			</li>


			<br><br><br><br>
			<li><!-- Jinja2 -->
				<h4 class="title_text border" style="border-color: red; color: rgb(107, 250, 255);">
				Jinja2 - курс</h4>
				<p><a href="https://www.youtube.com/watch?v=cFJqMXxVNsI&list=PLA0M1Bcd0w8wfmtElObQrBbZjY6XeA06U&index=1&t=13s" style="color: rgb(107, 250, 255);">You_Tube</a></p>
				<ul><!-- Jinja2 список начало-->
					
					<li>
						<h6 class="title_text border" style="border-color: red; color: rgb(107, 250, 255);">[1]. О шаблонизаторе, использование</h6>
						<ul>
							<li>Jinja2 - Модуль для обработки шаблонов в Python</li>
							<li>
								Проверяем установлен ли он, в py документе любом пробуем импортировать:
								<pre>
from jinja2 import Template  # импортируем класс шаблоны из джинджи</pre>
								Если не получается то модуль не установлен
							</li>
							<li>
								Устанавливаем Jinja2 - в терминале (PyCharm или Win):
								<pre>
python -m pip install -U Jinja2</pre>
								Я установил в глобальное окружение, возможно необходимо будет устанавливать и в виртуальные окружения.
							</li>
							<li>
								Пример применения:
								<pre>
from jinja2 import Template

first_name = 'Александр'

# создаём экземпляр класса Temp - на основе шаблона ({{}})
tm = Template("Привет {{ name }}"))

# на выходе render - возвращает нам готовую стоку(шаблон)
msg = tm.render(name=first_name)

print(tm)  -->  &lt;Template memory:1f1737b3210>
print(msg)  -->  Привет Александр</pre>
								Пример очень простой, и в подобных случаях лучше просто использовать f строки:
								<pre>
first_name = 'Александр'
msg2 = f"Привет {first_name}"
print(msg2)  -->  Привет Александр</pre>
							</li>
							<li>
								<span class="spec">Конструкции внутри шаблонов:</span>
								<pre>
{% %} - спецификатор шаблона
{{ }} - выражение для вставки конструкция Pithon в шаблон
{# #} - блок комментариев
# ## - строковый комментарий</pre>
							</li>
							<li>
								Пример с двумя переменными:
								<pre>
first_name = 'Александр'
age = 30
tm = Template("Мне {{ a }} лет. Меня зовут - {{ n }}")
msg = tm.render(n = first_name, a = age)
print(tm)  -->  &lt;Template memory:263d9da1a10>
print(msg)  -->  Мне 30 лет. Меня зовут - Александр</pre>
							</li>
							<li>
								Внутри скобок можно прописывать конструкции Python, формулы
								<pre>
tm = Template("Мне {{ a*2 }} лет. Меня зовут - {{ n.upper() }}")
msg = tm.render(n = first_name, a = age)
print(msg)  -->  Мне 60 лет. Меня зовут - АЛЕКСАНДР</pre>
							</li>
							<li>
								Вывод информации из классов:
								<pre>
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

per = Person("Александр", 30)
tm = Template("Мне {{ p.age }} лет. Меня зовут - {{ p.name }}")
msg = tm.render(p=per)

print(msg)</pre>
							</li>
							<li>Вывод информации из словаря(по ключам)
								<pre>
per = {'name': 'Александр', 'age': 30, }
tm = Template("Мне {{ p.age }} лет. Меня зовут - {{ p.name }}")
msg = tm.render(p=per)
print(msg) -->  Мне 30 лет. Меня зовут - Александр</pre>
							</li>
						</ul>
					</li>
					<li>
						<h6 class="title_text border" style="border-color: red; color: rgb(107, 250, 255);">[2]. Экранирование и блоки raw, for, if</h6>
						<ul>
							<li>
								Экранирование {%raw%}...{%endraw%}
								<br>Всю что будет между ними не будит никак преобразоваваться и будет представлено ровно так, как это записано.
							</li>
							<li>
								Игнорирование - символов &lt; ''' и тд при выводе готового варианта html страницы с помощью 'e'
								<pre>
link_1 = ''' бла бла бла &lt;a href=''>ссылка&lt;/a> '''
tm = Template("{{ link | e }}")
msg = tm.render(link=link_1)
print(msg)  -->  бла бла бла &lt;a href=&#39;&#39;&gt;ссылка&lt;/a&gt;</pre>
								То есть на выходе из браузера, мы получим полноценный html текст, такое же как пишем в редакторе.
							</li>
							<li>
								Предыдущий код можно выполнить гораздо проще с помошью метода escape
								<pre>
from markupsafe import escape  # markupsafe кстанавливается в месте с jinja
link_1 = ''' бла бла бла &lt;a href=''>ссылка&lt;/a> '''
msg = escape(link_1)
print(msg)</pre>
								На выходе то же самое что и предыдущий код
							</li>
							<li><span class="spec">{% Выражение for %}</span>
								<pre>
{%for-варажение-%}									
повт. фрагмент
{%endfor%}</pre>
							</li>
							<li>
								Пример использования for в шаблоне:
								<pre>
cityes = [
    {'id': 1, 'city': 'Волгоград'},
    {'id': 5, 'city': 'Москва'},
    {'id': 7, 'city': 'Тверь'},
    {'id': 8, 'city': 'Смоленск'},
    {'id': 11, 'city': 'Калуга'},
]

link = '''&lt;select name="cityes">
{% for c in cityes %}
    &lt;option value="{{c['id']}}">{{c['city']}}&lt;/option>
{% endfor %}
&lt;/select>'''

tm = Template(link)
msg = tm.render(cityes=cityes)
print(msg)

----------------->

&lt;select name="cityes">

    &lt;option value="1">Волгоград&lt;/option>

    &lt;option value="5">Москва&lt;/option>

    &lt;option value="7">Тверь&lt;/option>

    &lt;option value="8">Смоленск&lt;/option>

    &lt;option value="11">Калуга&lt;/option>

&lt;/select></pre>
							</li>
							<li>
								Добавив - уберутся переносы строк
								<pre>
{% for c in cityes -%}
код
{% endfor -%}</pre>
							</li>
							<li>
								<span class="spec">{% Выражение if %}</span>
								<pre>
{%if-варажение-%}
фрагмент - при истинности условий
{%endif%}</pre>
							</li>
							<li>
								Пример блока if в шаблоне:
								<pre>
link = '''&lt;select name="cityes">
{% for c in cityes -%}
{% if c.id > 7 -%}  # минусы расставляем чтобы не получалось пустых строк
    &lt;option value="{{c['id']}}">{{c['city']}}&lt;/option>
{% endif -%}
{% endfor -%}
&lt;/select>'''

tm = Template(link)
msg = tm.render(cityes=cityes)
print(msg)  -->  Выведет только Смоленск и Калуга</pre>
								Так же в блоке можно добовлять конструкцию elif, else - всё по правилам Python.
							</li>
						</ul>
					</li>

					<li>
						<h6 class="title_text border" style="border-color: red; color: rgb(107, 250, 255);">[3]. Фильтры и макросы macro, call</h6>
						<ul>
							<li>
								Сумма по атрибуту из списка словарей в шаблоне:
								<pre>
cars = [
    {'price': 23000, 'model': 'Ауди'},
    {'price': 17300, 'model': 'Шкода'},
    {'price': 44300, 'model': 'Вольво'},
    {'price': 21300, 'model': 'Фольксваген'},
]
tpl = "Суммарная цена автомобилей {{ cs | sum(attribute='price') }}"
# sum(attribute='price') - сложит все цены из списка

tm = Template(tpl)
msg = tm.render(cs=cars)
print(msg)  -->  Суммарная цена автомобилей 105900</pre>
							</li>
							<li>
								Сумма чисел из элементов числового списка в шаблоне:
								<pre>
digs = [1, 2, 3, 4, 5]
tpl = "Сумма чисел списка - digs: {{ digit | sum }}"
tm = Template(tpl)
msg = tm.render(digit=digs)
print(msg) -->  Сумма чисел списка - digs: 15</pre>
							</li>
							<li>
								sum(inereble,attribute=None, start=0)
								<br>Если чего то не нужно в конкретном случсе, то поля не обязательны
							</li>
							<li>
								Максимальная цена из списка автомобилей:
								<pre>
cars = [
    {'price': 23000, 'model': 'Ауди'},
    {'price': 17300, 'model': 'Шкода'},
    {'price': 44300, 'model': 'Вольво'},
    {'price': 21300, 'model': 'Фольксваген'},
]
tpl = "Максимальная цена из списка автомобилей {{ cs | max(attribute='price') }}"
tm = Template(tpl)
msg = tm.render(cs=cars)
print(msg) -->  Максимальная цена из списка автомобилей {'price': 44300, 'model': 'Вольво'}</pre>
							</li>
							<li>
								Если нужно вывести только марку автомобяля с максимальной ценой:
								<pre>
cars = [
    {'price': 23000, 'model': 'Ауди'},
    {'price': 17300, 'model': 'Шкода'},
    {'price': 44300, 'model': 'Вольво'},
    {'price': 21300, 'model': 'Фольксваген'},
]
tpl = "Самый дорогой автомобиль в списке: {{ (cs | max(attribute='price')).model }}"
tm = Template(tpl)
msg = tm.render(cs=cars)
print(msg) -->  Самый дорогой автомобиль в списке: Вольво</pre>
								Аналогично работает фильтр min
							</li>
							<li>
								Фильтр random - выберет случайный элемент списка
								<pre>
tpl = "Случайный авто в виде словаря: {{ cs | random }}"
tm = Template(tpl)
msg = tm.render(cs=cars)
print(msg)
-->  Случайный авто в виде словаря: {'price': 44300, 'model': 'Вольво'}
-->  Каждое выполненние программы будет менять вывод</pre>
							</li>
							<li>
								Заменяем символы, например о на (.):
								<pre>
tpl = "Случайный авто в виде словаря: {{ cs | replace('о','(.)') }}"
tm = Template(tpl)
msg = tm.render(cs=cars)
print(msg)  -->  [{....{'price': 17300, 'model': 'Шк(.)да'}, {'pr....}]
								</pre>
							</li>
							<li>
								<span class="spec">{% filter..%}</span>
								Применение фильтров непосредственно внутри шаблонов
								<pre>
{% filter-название фильтра-%}
-фрагмент для применения вильтра-
{% endfilter -%}
								</pre>
							</li>
							<li>
								Пример. Сделаем все буквы в именах в верхнем регистре:
								<pre>
men = [
    {'name': 'Алексей', 'old': 18, 'weight': 78.5},
    {'name': 'Николай', 'old': 28, 'weight': 82.3},
    {'name': 'Иван', 'old': 33, 'weight': 94},
]
tpl = '''
{%- for u in users -%}
{% filter upper %}{{ u.name }}{% endfilter %}
{% endfor -%}
'''
tm = Template(tpl)
msg = tm.render(users=men)
print(msg)
------------->
АЛЕКСЕЙ
НИКОЛАЙ
ИВАН</pre>
							</li>
							<li>
								Макроопределения - для издегания повторяемых определений
								Прописываем значения в тегах html - python кодом
								<br>{% macro %}  - {% endmacro %}
							</li>
							<li>
								{% call %}  - {% endcall %} - вложенные макросы
							</li>
						</ul>
					</li>

					<li>
						<h6 class="title_text border" style="border-color: red; color: rgb(107, 250, 255);">[4]. Загрузчики шаблонов - FileSystemLoader, PackageLoader, DictLoader, FunctionLoader</h6>	
						<ul>
							<li>
								Кратно - загрузка html кода из html страницы (шаблона):
								<br>tpl - находится внутри html в body - там конструкция for
								<pre>
from jinja2 import Environment, FileSystemLoader
# FileSystemLoader - Это загрузчик который работает с нашим SSD

men = [
    {'name': 'Алексей', 'old': 18, 'weight': 78.5},
    {'name': 'Николай', 'old': 28, 'weight': 82.3},
    {'name': 'Иван', 'old': 33, 'weight': 94},
]

file_loader = FileSystemLoader('templates')  # из какого подкоталога будем брать шаблоны
#('templates') - путь (папка_где_мы_находимся/templates)
#('') - если бы необходимо было брать из корневого подкоталога

env = Environment(loader=file_loader)
# Environment - это класс, через который как раз и идёт работа с API

tm = env.get_template('main.html')
# формируем класс Template - на основе main.html

msg = tm.render(users=men)
# получение на выходе текстовой строки уже преобразованного шаблона

print(msg)

								</pre>
							</li>
							<li>
								Стандартные загрузчики в пакете Jinja:
								<br>-FileSystemLoader - берёт шаблоны из фаловой системы нашего устройства(жусткий диск)
								<br>-PackegeLoader - для загрузки пакета из шаблона
								<br>-DictLoader - Для загрузки шаблонов из словаря
								<br>-FunctionLoader - для загрузки на основе функции
								<br>-PrefixLoader - загрузчик, использующий словарь для построения подкаталогов
								<br>-CholeLoader - загрузчик, содержащий список других загрузчиков (если один не сработает выбирается слудующий)
								<br>-ModeuleLoader - загрузчик для скомпилированных шаблонов
						</ul>
					</li>
					

					<li>
						<h6 class="title_text border" style="border-color: red; color: rgb(107, 250, 255);">[5]. Конструкции include и import</h6>
						<ul>
							<li>
								Разделение шаблонов на заголовок(навбар например) - контент страницы - футер страницы.
								<br>заголовки и футеры обычно одинаковые для всех страниц сайта
								<br>Для того чтобы не писать футер и заголовок каждый раз, с помощью include можно сократить работу
								<br><br>
								Предположим у нас есть 3 html страницы = navbar.html/content.html/footer.html. Внутри контента чтобы не дублировать постоянно можно сделать так:
								<pre>
{% include 'navbar.html' %}
&lt;p> основной контент &lt;/p>
{% include 'footer.html' %}</pre>
							</li>
							<li>
								Если вдруг программан не найдёт файл navbar.html - чтобы не возникало ошибок, а шаблон сформировался без навбара добавим ignore missing
								<pre>
{% include 'navbar222.html' ignore missing %}
&lt;p> основной контент &lt;/p>
{% include 'footer.html' %}</pre>
							</li>
							<li>
								Конструкция import - при импорте файл не добавляется но мы можем использовать функционал этого файла (например - макрос)
							</li>
						</ul>
					</li>

					<li>
						<h6 class="title_text border" style="border-color: red; color: rgb(107, 250, 255);">[6]. Наследование расширение шаблонов</h6>
						<ul>
							<li>
								{% block title %} заголовок {% endblock %}
								<br>{% block content %} контент {% endblock %}
							</li>
							<li>
								<pre>
{% extends 'base.html' %} # имя базового шаблона на основе которого будет и строится страцица
{% block title %} название страницы {% endblock %}

{% block content %}
основной контент
{% endblock %}</pre>
							<li>
								{{self.title()}}
								<pre>
{% extends 'base.html' %}
{% block title %} название страницы {% endblock %}

{% block content %}
{{self.title()}}  # обращаемся к блоку title  - напишет название страницы
основной контент
{% endblock %}</pre>
							</li>
							<li>
								{{ super() }} 
							</li>
							<li>
								<img src="images\base_tpl.jpg" class="img-fluid">
								<br><br>
								<br>base.tpl - содержит какойто шаблон (ex_main)
								<br>child1 - расширяет base.tpl
								<br>child2 - расширяет child1
							</li>
						</ul>
					</li>
				
				</ul><!-- Jinja2 список конец-->
			</li><!-- Jinja2 всё -->
			<br><br>


			<br><br>
			<h4 class="title_text border">[6]. Шаблоны (templates). Начало.</h4>
			<li>
				Во views.py изначаньно импортирована функция render.
				<br><span class="spec">render - встроенный шаблонизатор Django</span>
				<br>Функкия render - производит обработку наших шаблонов
			</li>
			<li>
				<span class="spec">Шаблон - это по сути html страница</span>
			</li>
			<li>
				В качестве главной страницы отабразим шаблон в файле index.html (создадим позже), аналогично about.html
				<ol type="A">
					<li>
						В men/views.py - проверяем, импортирован ли встроенный шобланизатор (функция render)
						<pre>
from django.shortcuts import render</pre>
					</li>
					<li>
						В men/views.py - изменяем функцию index
						<pre>
def index(request):  # главная страница
    return render(request, '')  # (request, 'путь к шаблону') - путь укажем позже</pre>
					</li>
					<li>
						В men - создаём директорию - 'templates', а в папке templates - необходимо создать ещё один подкоталог c названием приложения.
						<br>То есть получилось coolsite/men/templates/men - Это делается потому что приложений может быть множество, и в каждом может быть templstes, а название шаблонов может совпадать (home.html, index.html и тд)
						<br>В случае если название шаблонов будет совпадать, django выберет шаблон, первый попавшийся - для этого в templates каждого приложения и делают ещё один подкатолог с названием приложения
					</li>
					<li>
						В templates/men - создадим index.html, При работе с Pithon или Django - в meta charset - всегда необходимо делать UTF 8 
					</li>
					<li>
						Добавляем путь к нашему шаблону. В men/views.py - def index
						<pre>
return render(request, 'men/index.html')  # (request, 'путь к шаблону')</pre>
					</li>
					<li>
						Место где django будет искать шаблоны прописаны в settings.py. TEMPLATED - 'APP_DIRS': True - то есть будет искать в папках приложения, в каталогах с именем templates
					</li>
					<li>
						Создадим ещё html файл - в templates/men - about.html
					</li>
					<li>
						В men/views.py - пропишем функкцию для отображения about.html
						<pre>
def about(request):  # главная страница
    return render(request, 'men/about.html')  # (request, 'men/templates/men/about.html')</pre>
					</li>
					<li>
						В men/urls.py - в путях можно убрать пути к категориям и архивам, и юдобавляем путь для страницы 127.0.0.1:8000/about
						<pre>
path('cats/&lt;int:catid>/', categories), - удаляем
re_path(r'archive/(?P&lt;year>[0-9]{4})/', archive), -удаляем

 # путь('url/', функция, name='имя для пути'),
 path('about/', about, name='about'),</pre>
					</li>
				</ol>
			</li>
			<li>
				Передаём параметры с помощью {{}} - {%for%}
			<ol type="A">

					<li>
						Отображаем title - автоматически, с помощью {{}}
						<br>В Заголовках html (about.html index.html) добавляем конструкцию шаблона {{}}
						<pre>
&lt;title>{{ title }}&lt;/title></pre>
						<br>Добавим в viewp.py - параметры, в виде словаря которые в виде шаблонов будем передавать в html {{ title }}
						<br>Дополняем функции index и about
						<pre>
# (request, 'путь к шаблону', передаваемый параметр - словарь)
return render(request, 'men/index.html', {'title': 'Главная страница'})

# (request, 'men/templates/men/about.html', {'ключ':'значение'})
return render(request, 'men/about.html', {'title': 'О сайте'})</pre>
					</li>
					<li>
						Усложняем функуию индекс, и будеи передавать несколько параметров (список и title).
						<br>В men/views.py - до функции добавим список, внутри функции добавим передаваемый в будущем параметр(этот список):
						<pre>
menu = ['О сайте', 'Добавить статью', 'Обратная связь', 'Войти']

def index(request):  # главная страница
    # (request, 'путь к шаблону', передаваемые параметры параметры)
    return render(request, 'men/index.html', {'menu': menu, 'title': 'Главная страница'})</pre>
    					<br>В свою уочередь в index.html - передаём пареметр menu - с помощью цикла for:
    					<pre>
    &lt;h1>Главная страница</h1>
    &lt;ul>
    {% for m in menu %}
        &lt;li>{{m}}&lt;/li>
    {% endfor %}
    &lt;/ul></pre>
    					На выходе у у нас Получится ul оформленный список, из жлементов списка menu
					</li>
					<li>
						В about.html - передаём тот же список, изменяя функцию about и саму страницу about.html
					</li>

				</ol>
			</li>
			<li>
				Наследование шаблонов! Чтобы не повторять одинковый код - например navbar, footer
				<ol type="A">
					<li>
						Создаём базовый шаблон, шаблон в котором будет одинаковай html код для всех страниц нашего сайта.
						<br>В templates/men - создаём base.html
					</li>
					<li>
						Пишем код base.html:
						<pre>
&lt;!DOCTYPE html>
&lt;html>
&lt;head>
    &lt;meta charset="utf-8">  # проверяй utf-8
    &lt;meta name="viewport" content="width=device-width, initial-scale=1">
    &lt;!-- css bootstrap 5 -->  # добавляй css ссылку 
    &lt;title>{{ title }}&lt;/title> # автоматом будет менятся название страниц
&lt;/head>
&lt;body>
    {% block mainmenu %}  # по сути блок навбара
    &lt;ul>
        {% for m in menu %} # список навбара через for
        &lt;li>{{m}}&lt;/li> # элементы списка
        {% endfor %} 
    &lt;/ul>
    {% endblock mainmenu %} # конец навбара

    {% block content %}  # индивидуальный контент для каждой страницы
    {% endblock %}  # конец индивид контента



&lt;!-- JS Bootstrap 5 -->  # добавь JS скрипты bootstrap
&lt;/body>
&lt;/html></pre>
						!Лично мне с html - гораздо удобнее работать в Sublime Text!
					</li>
					<li>
						Изменяем  - наследуемся в index/about.html от base.html
						<br>Пример index.html - about.html - аналогично:
						<pre>
{% extends 'men/base.html' %}  # наследуемся от base.html

{% block content %}  # начало индивидуального контента
&lt;h1>{{ title }}&lt;/h1>  # сам контент
&lt;p>О&lt;сновной индивидуальный контент&lt;/p> # сам контент
{% endblock %} # конец индивидуального контента</pre>
					</li>
				</ol>
			</li>

			<li>
				<span class="spec">Чтение данных таблицы нашей модели(класса Men) в шаблонах:</span>
				<ol type="A">
					<li>
						В men/views.py - импортируем все модели
						<pre>
from .models import *  # импортируем все модели из men/models.py</pre>
					</li>
					<li>
						В men/views.py - в функциу представления для главной страницы - index. Возьмём все запси из таблицы, сохраним ссылку на них в переменной(post), Передадим post - в качестве параметра, чтобы было возможно отобразить их на html странице.
						<pre>
def index(request):  # главная страница
    # Берем все записис модели, помещаем в переменную
    posts = Men.objects.all()
    # (request, 'путь к шаблону', передаваемые параметры параметры)
    return render(request, 'men/index.html', {'posts': posts, 'menu': menu, 'title': 'Главная страница'})</pre>
					</li>
					<li>
						Отображаем наши записи в index.html:
						<pre>
{% block content %}
&lt;h1>{{ title }}&lt;/h1>
&lt;ul>
    {% for p in posts %}
    &lt;li>
        &lt;h2>{{ p.title }}&lt;/h2>
        &lt;p>{{ p.content }}&lt;/p>
        &lt;hr>  # линия снизу
    &lt;/li>
    {% endfor %}
&lt;/ul>
{% endblock %}</pre>
				</ol>
			</li>


			<br><br>
			<h4 class="title_text border">[7].  Подключение статических файлов. Фильтры шаблонов.</h4>
			<li>
				Во время отладки django ищет статические файлы во всех подкоталогах static(их может быть несколько)
				<br>
				Но в режиме экслплуатации - на реальном веб сервере - статические файлы будут браться из одной главной папки статический файлов (djsite/coolsite/scatic) - расположенной в каталоге всего проекта
			</li>
			<li>
				Для того чтобы собрать все статические файлы в этот главный поткаталог, в терминале необходимо все статические файлы собрать.
				<pre>
Python manage.py collectstatic</pre>
				<br><strong>Но для корректрой работы необходимо прописать настройки в settings.py для:</strong>
				<br>-STATIC_URL - префикс URL-адреса
				<br>-STATIC_ROOT - путь к общей статической папке, используемый реальым веб-сервером
				<br>-STATICFILES_DIRS - список дополнительных(нестандартных) путей к статическим файлам, используемых для сбора и для рещима отладки
			</li>
			<li>
				Прописываем все константы STATIC в settings.py - после STATIC_URL (его оставляем стандартно)
				<pre>
STATIC_URL = 'static/'  # стандартно

# STATIC_ROOT добавили, в эту папку при collectstatic - django перемещает все статические файлы
# путь djsite/coolsite - из этой папке, статический файлы будут пользоватся в режиме эксплуатации сайта на сервере
STATIC_ROOT = BASE_DIR / 'static'

# добавили пустой список, список нестандартных путей, пока у нас нет, оставим пустым
STATICFILES_DIRS = []</pre>
			</li>
			<li>
				-Создадим в men - папку static
				<br>-В static - папку men (аналогично с templete)
				<br>-В men/static/men - папку css
				<br>-В men/static/men - папку js
				<br>-В men/static/men - папку imsges
			</li>
			<li>
				В папке css - создадим styles.css
				<br>Что бы не терять время беру с гитхаба создателя курса - этот файл, там ничего сложного стандартные css стили.
			</li>
			<li>
				Аналогично, копирую c github-a - images - в men/static/men/images - картинки которые будем использовать в шаблоне
			</li>
			<li>
				Подгружаем наши статические файлы в base.html - в самом верху страницы - до html кода
				<pre>
{% load static %}</pre>
				-Добавляем путь для нашего style.css - в head - base.html
				<pre>
&lt;link rel="stylesheet" type="text/css" href="{% static 'men/css/styles.css' %}" /></pre>
				Можно обнавлять сттраницу, если изменений нет попробуй Mozilla - В Хроме сохраняется кэш, и изменения стилей иногда срабатывают с опозданием, возможно сработают только после перезапуска праузера или даже пк.
			</li>
			<li>
				Верстаем наши страницы все, приводим вид в порядок, используем styles.css. Не Буду подробно описывать процесс
				<ul>
					<li>
						В base.html:
						<br>Загружаем иконку
						<pre>
&lt;!-- загружаем иконку для отоброжения в браузере где titte-->
&lt;link rel="shortcut icon" href="{% static 'men/images/main.ico' %}" type="image/x-icon"/></pre>
						И так далее. Очень много писать, но всё просто.
					</li>
					<li>
						Напоминалка по тегам таблицы html
						<pre>
table - таблица
thead - голова таблицы
tr - строка
td - столбец
th - заголовок в таблице
&lt;th colspan="4> - заголовок будет растянут на столбца</pre>
					</li>
					<li>
						index.html
						<pre>
{% extends 'men/base.html' %}

{% block content %}
&lt;ul class="list-articles">
    {% for p in posts %}
    &lt;li>
        &lt;h2>{{ p.title }}&lt;/h2>
        &lt;p>{{ p.content }}&lt;/p>
        &lt;div class="clear">&lt;/div>
        &lt;p&lt; class="link-read-post">&lt;a href="#">Читать пост&lt;/a>&lt;/p>
        &lt;hr>
    &lt;/li>
    {% endfor %}
&lt;/ul>
{% endblock %}</pre>
					</li>
					<li>
						about.html
						<pre>
{% extends 'men/base.html' %}

{% block content %}
&lt;h1>{{ title }}&lt;/h1>
&lt;p>здесь будет информация о сайте&lt;/p>
{% endblock %}</pre>
					</li>
				</ul><!-- Верстаем -->
			</li><!-- Верстаем -->

			<li>
				<span class="spec">Использование фильтров при работе с шаблонами</span>
				<br><span class="spec">{{ переменная | фильтр: 'значение' }}</span>
				<br>Фильтров много, просмотри и изучи официальную документацию по встроенными фильтрам джанго.
			</li>
			<li>
				Разбиваем текст по абзацам (в index.html):
				<pre>
&lt;p>{{ p.content }}&lt;/p>  -->  &lt;p>{{ p.content|linebreaks }}&lt;/p></pre>
			</li>
			<li>
				Отображаем на главной странице только первые 50слов статьи.
				в index.html - добавляем фильтр:
				<pre>
&lt;p>{{ p.content|linebreaks }}&lt;/p> -->  &lt;p>{{ p.content|linebreaks|truncatewords:50 }}&lt;/p></pre>
			</li>
			<li>{% autoescape off %} # 'выключить экранирование, по умолчанию включено.
				<pre>
{% autoescape off %}  # выключить экранирование
	{{p.content|linebreaks|truncatewords:50}}
{% endautoescape %}  # конец зоны выключения экранирования</pre>
			</li>
		


		</ol><!-- общий список -->
	</div><!-- container-md all -->
&lt; &lt; &lt; 
&lt; &lt; &lt;
&lt; &lt; &lt;


<!-- JS Bootstrap 5 -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-gtEjrD/SeCtmISkJkNUaaKMoLD0//ElJ19smozuHV6z3Iehds+3Ulb9Bn9Plx0x4" crossorigin="anonymous"></script>


</body>
</html>