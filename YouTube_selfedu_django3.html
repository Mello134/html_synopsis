er<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- css bootstrap 5 -->
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x" crossorigin="anonymous">

	<title>selfedu-django3 - конспект курса</title>

	<style type="text/css">
		
		pre{
			color: black;
			background: #c6ffe3;
			margin-right: 30px;
			margin-left: 15px;
			margin-bottom: 2px;
			margin-top: 5px;
		}
		
		.all{
			background: #2C4352;
			color: white;

		}
		
		body{
			background: #b7e2ff;
		}
		
		.spec {
			font-size: 18px;
			letter-spacing: .2em;
			font-weight: 500;
/*			text-transform: uppercase;*/
			color: #ff7575;
			margin-top: 15px;
			margin-bottom: 2px;
		}

		.title_text {
			letter-spacing: .1em;
			font-weight: 500;
			color: #f2cb71;

		}

	</style>


&lt; &lt; &lt;
</head>


<body>
	<p><a href="https://www.youtube.com/@selfedu_rus">selfedu</a></p>
	<p><a href="https://www.youtube.com/watch?v=FyTL1bnUx5I&list=PLA0M1Bcd0w8xO_39zZll2u1lz_Q-Mwn1F">Django 3 для Python(плейлист)</a></p>
	<p><a href="https://proproprogs.ru/django">https://proproprogs.ru/django</a></p>
	<p><a href="https://django.fun/ru/articles/tutorials/">Статьи о Django</a></p>
	<p><a href="https://habr.com/ru/post/514348/">Шесть Python-пакетов, которые рекомендуется использовать в каждом веб-приложении на Django</a></p>
	<p><a href="https://django.fun/ru/docs/">Документация по фреймворку и библиотекам Django</a></p>
	<p><a href="https://translated.turbopages.org/proxy_u/en-ru.ru.5b0ed4c9-6378aa3f-3f4ce05c-74722d776562/https/hackr.io/blog/top-django-interview-questions-and-answers">50 лучших вопросов и ответов для интервью Django на 2022 год</a></p>
	<p><a href="https://pypi.org/">pypi.org</a></p>
	<p><a href="https://python-scripts.com/user-accounts-django#login">python-scripts.com</a></p>
	<p><a href="https://tutorial.djangogirls.org/ru/django_forms/">tutorial.djangogirls.org/ru/django_forms/</a></p>
	<p><a href="https://dvmn.org/encyclopedia/">https://dvmn.org/encyclopedia/</a></p>
	<p><a href="https://djangodoc.ru/">https://djangodoc.ru/</a></p>
	<p><a href="https://github.com/django/django">https://github.com/django/django</a></p>
	<p><a href="https://www.youtube.com/@DinarAhmetshin/featured">https://www.youtube.com/@DinarAhmetshin/featured</a></p>
	<p><a href="https://tproger.ru/translations/django-react-webapp/">Пишем приложение с бэкендом на Django и фронтендом на React</a></p>

	<p><a href="https://www.youtube.com/playlist?list=PL1mHvJEjGCggI4YRDioFE3HPW2KJtZV3Q">Хороший курс Youtube - Python, Django, Linux</a></p>
	<p><a href="https://www.youtube.com/watch?v=fwoPp4v_flE&list=LL&index=31&t=133s">добавление комментариев, всплывающее окно</a></p>

	<p><a href="https://vivazzi.pro/ru/django-shop/cart-checkout/">Интересный сайт - корзина, истекание корзины и тд</a></p>

	<p><a href="https://vivazzi.pro/ru/django-shop/">Перевод Django Shop</a></p>
	<p><a href="https://vivazzi.pro/ru/deploy-django-site//">Книга "Разверни сайт на Django"</a></p>

	<p>
		Хороший сайт с подробными статьями, как реализовать ту или иную фичу на django
		<a href="https://pocoz.gitbooks.io/django-v-primerah/content/">Django в примерах</a>
	</p>
	<p>
		Хороший вариант для лайков
		-создавать отдельные функции с отдельными urlami с редиректом на path='car'
		-ставится лайк - создаётся комментарий
		<a href="https://programbox.ru/2022/12/04/%D0%BA%D0%B0%D0%BA-%D0%B4%D0%BE%D0%B1%D0%B0%D0%B2%D0%B8%D1%82%D1%8C-%D0%BB%D0%B0%D0%B9%D0%BA%D0%B8-%D0%BA-%D0%BC%D0%BE%D0%B8%D0%BC-%D1%81%D0%BE%D0%BE%D0%B1%D1%89%D0%B5%D0%BD%D0%B8%D1%8F%D0%BC-%D0%B2/">programbox.ru</a>
	</p>




	<div class="container-md all">
		<h1 class="title_text">YouTube selfedu</h1>
		<br>
		<h4 class="title_text">Django 3 для Python</h4>
		<br>

		<h4 class="title_text border">[1]. Django - что такое, порядок установки.</h4>
		<ol>
			<li>Django - фреймворк, для работы на стороне сервера - backend - на языке программирования - Python</li>
			<li>Фреймворк - это обвёртка для языка программирования, для упрощения работы</li>
			<li><span class="spec">Взаимодействие Пользоветеля-Сервера-Фреймворка</span>
				<br>
				<img src="images\request-render.jpg" class="img-fluid">
				<br>
				Запрос от пользователя --> сервер &lt;-WSGI-> Django --> Модели, функции, БД, Шаблоны--> Django --> Сервер --> ответ пользователю
			</li>
			<li>
				WSGI (Web Server Fateway Interface) - стандарт взаимодействия между Python программой на стороне сервера, и вебсайтом.
			</li>
			<li>
				У Django есть свой отладочный сервер - на localhost = http://127.0.0.1:8000/ - Но в итоге сайты размещаются на ориендуемых сервеах - Хостингах
			</li>
			<li>Для того чтобы всё правильно работало - желательно исользовать одни и теже версии продуктов Python и Django - для этого создаётся вируальное окружение для проекта - venv. При этом на ПК можно будет обнавлять версии, и они могут отличатся от версий виртуального окружения</li>
			<li>
				<p class="spec">Устанавливаем и проверяем Python на ПК</p>
				<ol type="A">
					<li>На оф сайте - скачиваем и устанавливаем последнюю версию</li>
					<li>Скачиваем и устанавливаем сторонний эмулятор конольного окна Windows - ConEmu - Она удобней встроенной</li>
					<li>При первом запуске ConEmu - Обязательно в окне выбрать [Shels::cmd(Admin)]</li>
					<li>
						Для проверки интерпритаора питона, в cmd пишем:
						<pre>
python -V  #Должно вывести текущую версию Python на ПК</pre>
					</li>
					<li>
						Для просмотра всех установленных пакетов на ПК, в сmd:
						<pre>
pip list 
#покажет все установленные пакеты и их версии(Pillow, pip, psycopg2, Django,django-crispy-forms) - если они установлены
#это пакеты в глобальном окружении - то-есть на ПК
#В каждом venv - необходиму будет устанавливать дополнительно</pre>
						pip(менеджер пакетов) - система управления пакетами, которая используется для установки и управления программными пакетами, написанными на Python.
					</li>
				</ol><!-- устанавливаем django -->
			</li><!-- устанавливаем django -->

			<li>
				<p class="spec">Устанавливаем Глобальное окружение</p>
				<ol type="A">
					<li>Создаём папку где будут проекты selfedu/создаём папку где будет проект один из
						<br>
						C:\Хранилище\IT\IT Разное\Обучение\YouTube_selfedu\djsite
					</li>
					<li>Внутри папки \YouTube_selfedu\djsite - будем устанавливать venv</li>
					<li>
						В cmd - переходим в эту папку
						<pre>
cd C:\Хранилище\IT\IT Разное\Обучение\YouTube_selfedu\djsite</pre>
					</li>
					<li>Создаём окружение (созможно до этого необходимо было установить в глобальном окружении)- но у меня уже было.>
						<br>В cmd (в итоге создастся папка окружения):
						<pre>
python -m venv venv2020
#где venv2022 - это имя окружения</pre>
					</li>
					<li>
						Заходим в окружение. В cmd - \YouTube_selfedu\djsite:
						<pre>
.\venv2022\Scripts\activate</pre>
						Теперь мы в окружении (venv2022)
					</li>
					<li>
						Проверяем pip list
						<pre>
pip list</pre>
						У нас всего 2 пакета pip и setuptools (в глобальном гораздо больше)
					</li>
					<li>
						Можно обновить pip - внутри окружения в cmd:
						<pre>
python.exe -m pip install --upgrade pip</pre>
					</li>
					<li>
						Чтоыбы выйти из окружения достаточно в cmd - (venv2022) .. \YouTube_selfedu\djsite
						<pre>
deactivate</pre>
					</li>
				</ol><!-- устанавливаем venv -->
			</li><!-- устанавливаем venv --------------------------------------------------------------->
			<li>
				<p class="spec">Устанавливаем Django</p>
				<ol type="A">
					<li>Django можно установить и через терминал PyCharm</li>
					<li>
						В PyCharm - создаём новый проект
						<pre>
Location: C:\Хранилище\IT\IT Разное\Обучение\YouTube_selfedu\djsite
Previoursly configured iterpretetre: ....\djsite\venv2022\Scripts\python.exe
						</pre>
					</li>
					<li>Жмём терминал - теперь этот проект автоматически будет в виртуальном окружении -(venv2022) C:\Хранилище\IT\IT Разное\Обучение\YouTube_selfedu\djsite></li>
					<li>Создалась папка .idea - незнаю пригодится ли</li>
					<li>Можжно вручную открыть venv2022 для этого в PyCharm:
						<br>File - Settings - Project:djsite - Python Interpritator - venv2022 - там же и будет показыватся все установленные пакеты в venv2022
					</li>
					<li>
						<span class="spec">Размер шрифта в SublimeText:</span>
						<br>Preferens - Font - Larger/Smaller/Reset
					</li>
					<li>
						Устанавливаем джанго через PyCharm терминал - в 
						<br>(venv2022) C:\Хранилище\IT\IT Разное\Обучение\YouTube_selfedu\djsite>
						<pre>
pip install django #устанавливаем пакет django в venv2022
#это ядро(пакет) - тоесть проект мы не создавали, никаких файлов не появляется в папке</pre>
					</li>
					<li>
						Список команд Django  - в терминале PyCH
						<pre>
django-admin</pre>
					</li>
					<li>В терминале так же работает 'cls' - очистить терминал</li>
					<li>
						В терминале YouTube_selfedu\djsite> создаём django -проект
						<pre>
django-admin startproject coolsite
#где coolsite - это и есть наш проект</pre>
					</li>
					<li>переходим в djsite/coolsite - запускаем сервер
						<pre>
python manage.py runserver</pre>
					</li>
					<li>
						Можно проверить работоспособность - в браузере - http://127.0.0.1:8000/
					</li>
					<li>Для остановки сервера так же работает ctrl+c</li>
					<li>
						Django работает со многими СУБД - PostgreSQL, MySQL, Oracle, SQLite..
					</li>
					<li>Можно запустить отладночный сервер на другом порте, например http://127.0.0.1:4000/:
						<pre>python manage.py runserver 4000</pre>
					</li>
				</ol><!-- устанавливаем Django -->
			</li><!-- устанавливаем Django ------------------------------------------------------>
			
			<br><br>
			


			<h4 class="title_text border">[2]. Модель MTV. Маршрутизация. Функции представления</h4>
			<li><span class="spec">Механизм обработки запроса от пользователя в Django</span>
				<br>
				<img src="images\mtv.jpg" class="img-fluid">
				<br>
				<p>
					-От пользователя приходит запрос (url)
					<br>-В маршрутизаторе идёт поиск url(path) - и ищется первое нужное значение
					<br>- . . . . 
				</p>
			</li>
			<li>
				Пути по слагу или индексу:
				<pre>
http://127.0.0.1:8000/   -  path('')
http://127.0.0.1:8000/category/1   -  path('category/&lt;id(число)>')
http://127.0.0.1:8000/women/madonna   -  path('women/&lt;slug(строка)>')
				</pre>
				Если совпадений никаких нк будет - выведет страницу 404
				
			</li>
			<br>
			<br>
			<li>
				<img src="images\madonna.jpg" class="img-fluid">
				<br>
				<p>-Приходит запрос от пользователя:					
					<br>-Функция view - берёт данные из models.py
					<br>-models.py - берёт данный из Бызы данных
					<br>-В шаблоне собирается информация
					<br>-Всё это формируется в views и отправляется пользователю, в виде html страницы
				</p>
			</li>
			<li>
				<span class="spec">MTV = Models + Templates + Views</span>
			</li>
			<li>Кааждая самостоятельная часть сайта, должны быть представленна в виде отдельного приложения (Основное приложение, Форум, Блог, Магазин)
				<br>Приложения желательно делать максимально независимыми, чтобы можно было воспользоваться в другом проекте например. Как минимум к этому необходимо стремится.
			</li>


			<li>
				<p class="spec">Создаём приложение django - app</p>
				<ol type="A">
					<li>
						В терминале - djsite\coolsite:
						<pre>
python manage.py startapp men
#где men - название приложения</pre>
					</li>
					<li>
						<span class="spec">Назначение файлов django внутри приложения</span>
						<br>admin.py - связь приложения с админ панелью
						<br>apps.py - настройка текущего приложения
						<br>models.py - для хранения ORM моделей (представление данных из базы данных)
						<br>test.py - модуль с тестирующими процедурами
						<br>views.py - хранение представлений (функции)
					</li>
				</ol><!-- устанавливаем django - app -->
			</li>	<!-- устанавливаем django - app ------------------------------------------------------>		
			<li>
				<p class="spec">Регистрируем приложение</p>
				<ol type="A">
					<li>В coolsite/coolsite/settings.py
						<br>[INSTALLED_APPS] - добавляем наше приложение
						<pre>
INSTALLED_APPS = [...., 'men.apps.MenConfig',]
#будет обращатся в coolsite/men/apps.py - class MenConfig(AppConfig)
						</pre>
					</li>
				</ol><!-- Регистрируем приложение -->
			</li>	<!-- Регистрируем приложение ------------------------------------------------------>
			<li>
				Далее заходим  в men/views.py  - создаём функцию index
				<pre>
def index(request): #request - информация о запросе, сессии, 'куках''
	return HttpResponse('Страница приложения men') #HttpResponse - ответ</pre>
			</li>
			<li>
				HttpResponse - необходимо имортировать в men/views.py
				<pre>
from django.http import HttpResponse #импортировали</pre>
			</li>
			<li>
				В coolsite/urls.py - импортируем нашу функцию
				<pre>
from men.views import index 
# импортировали из men/views.py  - def index</pre>
			</li>
			<li>
				В coolsite/urls.py - добавляем путь (все пути добаляются в список urlpatterns)
				<pre>
path('men/', index),
#где 'men/' - путь url  - localhost/men
#index - функция из men/views.py</pre>
			</li>
			<li>Делаем нашу папку - рабочим каталогом, чтобы ничего личшенего не подчёркивалось
				<br>В PyCharm - внешнюю папку coolsite - пкм - MarkDirectory - Sourcec Root
			</li>
			<li>
				Запускаем сервер - в браузере http://127.0.0.1:8000/men - всё работает
				<br>-В views.py можно добавить html теги h1 - чтобы в браузере отображалось как заголовок
			</li>
			<li>
				В men/views.py - добавим ещё одну функцию - категории
				<pre>
def categories(request):
    return HttpResponse('&lt;h1>Статьи по категориям&lt;/h1>')</pre>
			</li>
			<li>
				В coolsite/urls.py - обавим ещё один путь для категорий, перед этим функцию необходимо импортировать 
				<pre>
from men.views import index, categories

path('cats/', categories),  # категории</pre>
			</li>
			<li>
				Чтобы импортировать все функции изменяем наш импорт views.
				<pre>
from men.views import index, categories   --->   from men.views import *
# импортировали из men/views.py  - все функции</pre>
				В браузере проверяем - http://127.0.0.1:8000/cats/ - всё работает
			</li>
			<li>
				В coolsite/urls.py корректируем путь главной страницы
				<pre>
path('men/', index),  --> path('', index)</pre>
				Теперь она будет открываться по пути - http://127.0.0.1:8000/
			</li>
			<li><span class="spec">Перенесём пути внутрь приложения</span>
				<ol type="A">
					<li>
						В coolsite/coolsite/urls.py - импортируем функцию include
						<pre>
from django.urls import include  # импорт функции include</pre>
					</li>
					<li>
						В coolsite/coolsite/urls.py - убираем все предыдущии пути - кроме админки, и добавляем путь:
						<pre>
path('men/', include('men.urls')),  # путь к путям  приложения men
						</pre>
					</li>
					<li>
						В men(app) - создадим новый файл - urls.py
					</li>
					<li>
						В men/urls.py импортируем функцию path, из текущей папки (men) - импортируем все прдставления (функции)
						<pre>
from django.urls import path
from .views import *</pre>
					</li>
					<li>
						В men/urls.py - созадём свой список urlpatterns = [], и прописываем пути текущего приложения
						<pre>
urlpatterns = [
    path('', index),  # домашняя страницы приложения - !!!путь - http://127.0.0.1:8000/men/
    path('cats/', categories),  # категории - !!!путь - http://127.0.0.1:8000/men/сats/
]
#men - добавляется из главного urls.py - coolsite/urls.py					
						</pre>
					</li>
				</ol>
			</li>


			<br><br>
			<h4 class="title_text border">[3]. Модель Маршрутизация, обработка исключений запросов, перенаправление</h4>
			<li>
				Переходим в главный urls.py (coolsite/urls.py) - меняем путь к приложению men  - чтобы в путях не было дополнительного пути /men/
				<pre>
path('men/', include('men.urls')),  --> 	path('', include('men.urls')),</pre>
			</li>
			<li>
				<span class="spec">Добавляем в путь числовой параметр</span>
				<ol type="A">
					<li>Для этого, в men/urls.py - корректируем путь категорий
						<pre>
path('cats/&lt;int:catid>/', categories),
# где int - целое число - 1/2/3/4
# catid - имя числового параметра, придумываем сами</pre>
					</li>
					<li>
						В men/views.py - def categories, добавляем имя числового параметра в двух местах.
						<pre>
def categories(request, catid):
	return HttpResponse(f'&lt;h1>Статьи по категориям&lt;/h1>&lt;p>{catid}&lt;/p>')
# где f' - это обычная ф-трока питона
# сatid - наш числовой параметр из пути в urls.py
# {catid} - вывод нашего числа - на html</pre>
						Теперь у нас есть пути http://127.0.0.1:8000/cats/1-2-3-4..9999../
						<br>Но пути http://127.0.0.1:8000/cats/ - больше нет
					</li>
				</ol>	
			</li>
			<li>
				<span class="spec">Какие типы данных мы вожем указывать в path (в шаблонах марщритов) - '&lt;int:id>:</span>
				<br>- str - любая не пустая строка, кроме '/'
				<br>- int - Любое положительное число, включая 0
				<br>- slug - слаг - латиница ASCII таблиц, дефис, подчёркивание
				<br>- uuid - цифры, малые латинские вимволы ASCII, дефис
				<br>- path - любая не пустая строка, включая '/'
			</li>
			<li>
				<span class="spec">функция re_path()</span>
				<ol type="A">
					<li>
						В men/urls.py - Импортируем re_path и добавим путь
						<pre>
from django.urls import path, re_path

re_path(r'archive/(?P&lt;year>[0-9]{4})/', archive),
# &lt;year>[0-9]{4})  -  год должен состоять именно из 4 чисел
# каждая цифра числа должны бть любой от 0 до 9 включительно</pre>
					</li>
					<li>
						В men/views.py - добавляем функцию
						<pre>
def archive(request, year):
	return HttpResponse(f'&lt;h1>Архив по годам&lt;/h1>&lt;p>{year}&lt;/p>')</pre> 
					</li>
					<li>Теперь у нас есть пути:
						<br>http://127.0.0.1:8000/archive/0001..2022..9999/
					</li>
				</ol>
			</li>
			<li>
				<span class="spec">Обработка GET и POST запросов</span>
				<ul>
					<li>url запрос - http://127.0.0.1:8000/?name=Alexandr&cart=music
						<br>name - ключ, Alexandr - значение
						<br>cart - ключ, music - значение
					</li>
					<li>
						Выделяем ключи из GET запроса
						<br>В views.py - def categories - добавляем строчку
						<pre>
print(request.GET)</pre>
						В браузере введём:
						<pre>
http://127.0.0.1:8000/cats/5/?name=Alexandr&cart=music</pre>
						В нашем терминале выдаст словарь ключ - значение, ключ значение
						<pre>
&lt;QueryDict: {'name': ['Alexandr'], 'cart': ['music']}>
[17/Nov/2022 19:04:20] "GET /cats/5/?name=Alexandr&cart=music HTTP/1.1" 200 55</pre>
					</li>
					<li>
						В нашей функции, добавим проверку (Есть ли данные в get запросе?):
						<pre>
if(request.GET):  # если данные в запросе есть
	print(request.GET)	# будет выведен словарь {'ключ:['ззначения']}</pre>
						Если данные будут, тогда в терминале нам покажет словарь
						<br>Если путь будет без GET - http://127.0.0.1:8000/cats/5/ - то ничего показывать не будет, так как гет данных нет
					</li>
					<li>Почти аналогично будет работа с POST запросом (request.POST)<br>POST - запросы обычно работают с формами login/passwod, либо когда отправляют какието изображения на сервер</li>
				</ul>
			</li>
			<li><span class="spec">Обработка исключений при запросах к серверу</span>
				<ul>
					<li>Если будет введён запрос - которого не существует, будет выведена страница 404 - c описанием проблемы  - прри DEBUG = True - в settings.py</li>
					<li>DEBUG = True - обычно только в момент работы над проектом, в итоговом варианте, чтобы пользователи не видели всех ошибок необходимо сделать DEBUG = Fasle/ALLOWED_HOSTS = ['хостинг.ру']
						<br>Для наглядности, в  settings.py меняем 2 строчки на:
						<pre>
DEBUG = False
ALLOWED_HOSTS = ['127.0.0.1']</pre>
						Пробуем запустить сервер и ввести несущестующий адрес, получим страничку нет страницы, но без ошибок. Page Not Found - либо что то подобное
					</li>
					<li>
						-Для того чтобы заменить страницу ошибки, заходим в coolsite/urls.py:
						<pre>
# handler404 - это спец переменная, pageNotFound - наша функция views.py							
handler404 = pageNotFound</pre>
						-В men/views.py - импортируем - HttpResponseNotFound
						-В men/views.py - пишем функцию этой страницы:
						<pre>
from django.http import HttpResponse, HttpResponseNotFound

def pageNotFound(request, exception):
	# exception - если произошли какието исключения, мы должны их обработать
    return HttpResponseNotFound('&lt;h1>Страница не найдена&lt;/h1>')</pre>
    					Теперь при неправильном urle - будет выводится наша страница ошибки
					</li>
					<li>
						Сгенерируем исключение в функции archive - если год будет больше 2022.
						<br>men/views.py - импортируем Http404
						<br>men/views.py - def archive - добавим 2 строчки:
						<pre>
from django.http import HttpResponse, HttpResponseNotFound, Http404

def archive(request, year):	
	if int(year) > 2022:  # если год больше 2022
		raise Http404()  # сгенерируем классом 404
	return HttpResponse(f'&lth1>Архив по годам&lt/h1>&ltp>{year}&lt/p>')</pre>
						Если год будет больше 2022 нас отпрявят к функции pageNotFound - та в своё время откроет нашё страницу - 'Страница не найдена'
					</li>
					<li>http://127.0.0.1:8000/archive/2023..9999/ - нас перенаправит на "страница не найдена"</li>
					<li><span class="spec">Выиды исключений (работают при DEBUG = False)</span>
						<br>-handler404 - страница не найдена (делали выше)
						<br>-handler403 - доступ запрещён
						<br>-handler500 - ошибка сервера
						<br>-handler400 - невозможно обраблтать запрос
					</li>
				</ul>
			</li>
			<li><span class="spec">Создание 301 и 302 редиректов</span>
				<ul>
					<li>
						301 - страница перемещена на другой постоянный URL-адрес
						<br>302- страница перемещена временно на другой URL-адрес
					</li>
					<li>
						В views.py  - импортируем функцию redidect
						<pre>
from django.shortcuts import render, redirect #рендер был изначально</pre>
					</li>
					<li>
						В views.py - в функции archive, поменяем строчку:
						<pre>
raise Http404()  --->  return redirect('/')
#если год будет больше 2022 - нас перенапривит на главную сраницу
						</pre>
						Нас будет направлять на главную страницу
						<br>В терминале будет 302 - [17/Nov/2022 20:18:38] "GET /archive/2023/ HTTP/1.1" 302 0
					</li>
					<li>
						В той же функции поменяем ту же строчку:
						<pre>
return redirect('/', permanent=True)</pre>
						Произойдёт то же самое только в терминале будет 301
					</li>
				</ul>
				<li>
					<ul><span class="spec">Задаём параметр name='имя' - пути path</span>
						<li>
							В men/urls.py - в пути index - задаём параметр name - и присваиваем имя(любое)
							<pre>
path('', index, name='home'),</pre>
						</li>
						<li>
							теперь по имени 'home'- можно ссылкться на домашнюю страницу
							<br>Например в views.py - поменяем
							<pre>
 return redirect('/', permanent=True) --> return redirect('home', permanent=True)</pre>
						</li>
						<li>
							<span class="spec">
								Название приложения можно поменять 'почти без последствий'
							</span>
							<br>Для этого в PyCharm - корневую папку приложения переименовываем (Rafactor/Rename)
							<br>Со всем соглашаемся - PyCharm исправить имя пости везде сам - автоматически (в функциях, в путях и тд)
							<br><strong>Проверь class в apps.py и сопоставь в settings.py - INSTALLED_APPS = []</strong>
						</li>
					</ul>
				</li>
				<li>
					<span class="spec">Работа с git </span> [добавил от себя]
					<ul>
						<li>Скачиваем, уcтанавливаем git</li>
						<li>При установке - обязательно делаем так чтобы могли работать из cmd Windows</li>
						<li>Логинимся на <a href="https://github.com/">https://github.com/</a></li>
						<li>На https://github.com/ - создаём новый репозиторий - обычно название проекта</li>
						<li>Там появится ссылка - куда будем push-ить</li>
						<li>В папке, которую хотим установить git - добавляем файл -.gitignore:
							<br>-Сгенерировать код для django можно на <a href="https://www.toptal.com/developers/gitignore/">https://www.toptal.com/developers/gitignore/</a> можно взять информацию из предыдущих проектов
							<br>-В sublime добавляем код, сохраняем
							<br><strong>-Это необходимо сделать до первого запуска сервера и миграций!</strong>
							</li>
						<li>
							В командной строке (cmd Windows или ComEmu или GitBash) - в корневой(внешней) папке проекта:
							<pre>
git –v  # посмотреть версию git
git init  # инициализируем git репозиторикй- папку на pc
git status  # смотрим какие файлы не отслеживаются на данный момент
git add .  # добавляем все файлы
git status  # смотрим что теперь всё отслеживается
git commit -m "имя коммита(что сделали/стадия)"  # создаём коммит
git remote add origin  - https://github.com/Mello134/репозиторий.git  # туда будем загружать
git branch -M main
git push -u origin main  # отправили на github - в репозитор</pre>
						</li>
					</ul>
				</li>
			<br><br>
			<h4 class="title_text border">[4]. Определение моделей. Миграции: создание и выполнение</h4>
			<li>
				<p>ORM (Object-Relational Mapping) - объектно-реляционноя приложение</p>
				<p>WSGI (англ. Web Server Gateway Interface) — стандарт взаимодействия между Python-программой, выполняющейся на стороне сервера, и самим веб-сервером, например Apache.<br>WSGI предоставляет простой и универсальный интерфейс между большинством веб-серверов и веб-приложениями или фреймворками
				</p>
				<p>Интерфейс прикладного программирования (API) - это соединение между компьютерами или между компьютерными программами. Это тип программного интерфейса, предлагающий услугу другим частям программного обеспечения. Документ или стандарт, описывающий, как построить или использовать такое соединение или интерфейс, называется спецификацией API.</p>
				<p>
					<img src="images\ORM.jpg" class="img-fluid">
				</p>
			</li>
			<li>Простыми словами в django встроен сеханизм взаимодействи с таблицами базы данных через ORM</li>
			<li>
				<span class="spec">Подключаемся проект к базе данных postrgeSQL</span>(добавил от себя)
				<ol type="A">
					<li>Скачиваем устанавливаем PostreSQL</li>
					<li>
						По умолчанию:
						<br>пароль - blog1234
						<br>port - 5432
						<br>Выбираем localhost
						<br>дополнительно ничего не устанавливал
					</li>
					<li>ВХОД В SQL Shell (cmd postgreSQL):
						<pre>
Server [localhost]:Enter
Database [postgres]:Enter
Port [5432]:Enter
Username [postgres]:Enter
Пароль пользователя postgres:blog1234 Enter</pre>
					</li>
					<li>СОЗДАЁМ БАЗУ ДАННЫХ ДЛЯ ПРОЕКТА<br>
						Далее там же в SQL Shell:
						<pre>
psql \! chcp 1251  # чтобы кирилица отображалась корректно
postgres=# \du  # видим всех пользователей
\password postgres  # смена пароля(если необхоимо)
\l  # поомотреть список баз данных на PC
CREATE DATABASE coolsitedb;  #Создали новыую БД(пустую) - для нашего проекта. ';'-обязательно
#ДОЛЖНО ВЫВЕСТИ  - CREATE DATABASE

\l  # поомотреть создалось ли</pre>
						SQL Shell -терминал можно закрывать.
					</li>
					<li>
						Настраиваем Django проект. В settings.py. В словаре DATABASES = {}: - удаляем или комментируем строчки
						<pre>
'ENGINE': 'django.db.backends.sqlite3',# стандартная DB
'NAME': BASE_DIR / 'db.sqlite3', #стандартная DB</pre>
						Там же в settings.py - связываем наш проект с db
						<br>DATABASES = {} - добавляем код:
						<pre>
'ENGINE': 'django.db.backends.postgresql',  # поменяли на postgresql - джижок постгрес
'NAME': 'coolsitedb',  # поменяли на - имя нашей БД
'USER': 'postgres',  # пользователь postgres - который создал БД
'PASSWORD': 'blog1234',  # пароль в PostgreSQL, для пользователя postgres
'HOST': '127.0.0.1',  # либо просто'localhost'
'PORT': '5432',  # стандартный порт</pre>
						Сохраняемся и получаем ошибку - Error loading psycopg2 module: No module named 'psycopg2'
					</li>
					<li>Psycopg2 – это база данных PostgreSQL. драйвер, который служит клиентом Python для доступа к серверу PostgreSQL.
						<br>В терминале внутри виртуального окружения устанавливаем:
						<pre>
pip list  # видим что psycopg2 действительно не установлен в окружении
pip install psycopg2</pre>
					</li>
					<li>
						Можно запустить сервер runserver - и убедится что всё работает!
					</li>
					<li>
						Таблицы баз данных можно смотреть наглядно pdAdmin 4 (есть русский интерфейс)
					</li>
				</ol>
			</li>
			<li>
				Будем создавать модель для men по данной структуре (заголовки столбцов):
				<br>-id: integer, primary key  - идентефикатор записи, номер
				<br>-title: Varchar - заголовок статьи (строка из определенного числа символов)
				<br>-content: Text - сама статься - тект
				<br>-photo: Image - изображение
				<br>-time_create: DataTime - дата создания
				<br>-time_update: DataTime - дата обновления
				<br>-is_publisher: Bolean - опубликовано/неопубликовано True/False
				<br><br>Нам необходимо будет сделать класс с этими полями и сделать миграцию
			</li>
			<li>
				Создаём класс Men в men/models.py:
				<pre>
from django.db import models  # было изначально

class Men(models.Model):  # наследуем все функции для нашего класса Men от Django класса Model
    # Id прописывать не нужно - Model Это делает автоматически
    title = models.CharField(max_length=255)  # длина 255 символов
    content = models.TextField(blank=True)  # текстовое поле без ограничений, blank=True - поле может быть пустым
    photo = models.ImageField(upload_to='photos/%Y/%m/%d')  # загружать будем в photos/год/месяц/день
    time_create = models.DateTimeField(auto_now_add=True)  # дата время - создание, auto_now_add=True - создастся единожды
    time_update = models.DateTimeField(auto_now=True)  # дата время - изменение, auto_now=True - будет менятся с каждым изменением
    is_publisher = models.BooleanField(default=True)  # default=True</pre>
			</li>
			<li>Почитай документацию Models - поле FileField - загрузка файлов(любых) в ней описано как настраивать MEDIA_ROOT, MEDIA_URL</li>
			<li>
				После сохранения models.py - выбаёт ошибку - Cannot use ImageField because Pillow is not installed.
				<p>
					Pillow - Библиотека изображений Python, или PIL (Python Imaging Library) нужна для обработки графики в Python, в том цисле загрузки изображений в models.py
				</p>
				<br>В терминале останавливаем сервер и устанавливаем пакет Pillow (внутри окружения)
				<pre>
python -m pip install Pillow  # устанавливаем пакет
pip list  # убедились что пакет в окружение утсановлен</pre>
			</li>
			<li><span class="spec">Настраиваем MEDIA_ROOT, MEDIA_URL</span>
				<br>В settings.py после static.url добавляем две строчки:
				<pre>
MEDIA_ROOT = BASE_DIR / 'media'  # будет загружать медия в папку media
MEDIA_URL = '/media/'  # добавили url - будет отображатся в браузере</pre>
			</li>
			<li><span class="spec">Дополнительно: Настраиваю время МСК и русский язык в админке</span>
				<br>settings.py - меняем две строчки кода
				<pre>
LANGUAGE_CODE = 'ru-Ru'  # русский язык в admin
TIME_ZONE = 'Europe/Moscow'  # время по МСК</pre>
			</li>
			<li>
				Для эмуляции работы сервер для получения ранее загруженных файлов, и передачи их нашему приложению. Для этого в coolsite/urls.py - импоритуем settings.py и после urlpatterns - добавим 2 строчки кода:
				<pre>
from django.conf.urls.static import static  # для DEBUG пути
from coolsite import settings  # для DEBUG пути

if settings.DEBUG:
    # к путям добавляем путь к статическим данным, графическим данным
    # на реальныъ серверах обычно это не используется
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)</pre>
			</li>
			<li>
				В settings.py - DEBUG вернём к зачению True
				<pre>
DEBUG = True</pre>
			</li>
			<li>
				<span class="spec">Создаём и выполняем миграции</span>
				<br>
				-Миграции Django-это файлы Python, которые помогают добавлять и изменять данные в таблицах базы данных для отражения изменений в моделях Django.
				<br><br>
				-При выполнении миграции в Django - в базе данных создаутся новые, или изменяются старые таблицы базы данных нашех моделей(классов) - по этому после измененив в моделях в models.py - необходимо делать миграции.
				<br><br>
				-На практике желательно избегать изменения структуры таблиц, и продумывать модели заранее.
				<ol type="A">
					<li>
						В терминале, в вируальном окружении, в корневой папке проекта - coolsite, пишем, для создания миграции:
						<pre>
python manage.py makemigrations</pre>
					</li>
					<li>
						В папке migrations - появится новый файл - 0001_initial.py - он служит для того чтобы создавать таблицы в базе данных, информацию можно посмотреть внутри файла
					</li>
					<li>
						Можно посмотреть sql запрос, который будет выполнятся для данной миграции, для этого в терминале пишем:
						<pre>
python manage.py sqlmigrate men 0001
#где men - наша модел Men, 0001 - порадковый номер 0001_initial.py</pre>
						Терминал покажет нам SQL запрос
					</li>



					<li>Далее применяем(выполняем) миграцию, в терминале:
						<pre>
python manage.py migrate</pre>
						Помимо наших миграций, выполнены изначальные миграции для djando - (админка, аутентификация и так далее)
					</li>
					<li>
						Таблмцу нашего класса теперь можно посмотреть с базе данных (она уже там создана)
						<br>Для этого используем pgAdmin 4:
						<br>-Servers
						<br>-PostreSQL
						<br>-Базы данных
						<br>-Схемы
						<br>-public
						<br>-Таблицы
						<br>-men_men  # название приложения_название модели(класса)
						<br>-View Data (значек таблицы)
						<br><br>Видно что по сути мы создали пустую таблицу,  толко столбцы - заполнять будем далее, через админ панель или например с помощью ORM
					</li>
				</ol>
			</li>

			<br><br>
			<h4 class="title_text border">[5]. CRUD - основы ORM по работе с моделями</h4>
			<li>
				CRUD: Create-создание / Read-чтение / Update-изменение / Delete-удаление
			</li>	
			<li>Использование ORM фреймфорка Django - Можно быполнять все вышеуказанные операции. Для большинства проектов (почти всех!), Django - нет необходимости напрямую переходить на SQL-рапросы. ORM django - достаточно мощная штука</li>
			<li>Каждый экземпляр класса - это по сту строчки в таблице</li>
			<li>
				Переход в консоль Django - Для работы с командами ORM. В терминале:
				<pre>
python manage.py shell  # вход в консоль django					
				</pre>
			</li>
			<li>
				Импортируем наш класс в терминал
				<pre>
#из men/models.py - импортируем модель(класс) - Men</pre>
			</li>
			<li>
				Добавляем информацию в таблицу. В shell django:
				<pre>
Men(title="Том Круз", content="Биография Тома Круза")  # указали данные но они ещё не записаны в БД
w1 = _  # '_' - сохраняет в себе последние действия, т.е в переменную w1 - мы записали то что писали в предыдущем коде. 
w1  # &lt;Men: Men object (None)> - вот что теперь в переменной w1. (None) - это id - пока не записали в таблицу
w1.save()  # теперь мы сохранили данные в нашу таблицу, можно ибудится в pdAdmin 4</pre>
				Как видим все поля заполнились. title,content -мы заполнили / time_create, time_update, is_publisher - автоматичекм, так как мы это прописывали в создании модели. / photo - на данный момент поле пустое, так как изображения мы не загружали.
			</li>
			<li>
				Можем оперировать всеми значениями нашей запси:
				<pre>
w1.id  -->  1
w1.time_create  -->  datetime.datetime(2022, 11, 18, 15, 46, 39, 456330, tzinfo=datetime.timezone.utc)
w1.title  -->  'Том Круз'</pre>
			</li>
			<li>
				pk - совпадает со знаечнием id.
			</li>
			<li>
				Посмотрим на SQL запрос который был выполнен для дополнения вышеуказанной записи, там же в django shell:
				<pre>
from django.db import connection  # импортировали модуль
connection.queries  # запрашиваем sql запрос

-->[{'sql': 'INSERT INTO "men_men" ("title", "content", "photo", "time_create", "time_update", "is_publisher") VALUES (\'Том Круз\', \'Биография
 Тома Круза\', \'\', \'2022-11-18T15:46:39.456330+00:00\'::timestamptz, \'2022-11-18T15:46:39.456330+00:00\'::timestamptz, true) RETURNING "m
en_men"."id"', 'time': '0.000'}]  # это и есть sql - запрос</pre>
			</li>
			<li>
				Создадим ещё одну запись в таблицу:
				<pre>
# здесь сразу присвоили в переменной w2
w2 = Men(title="Марк Уолберг", content="Биография Марка Уолберга")
w2.save()  #сохранили в таблице БД</pre>
			</li>
			<li>
				Добавлять данные можно поочерёдно (отдельно title, content):
				<pre>
w3 = Men()  # Создали пустую запись
w3.title = 'Вечаслав Бутусов'  # Добавили заголовок
w3.content = 'Биография Вечаслава Бутусова'  # Добавили контент
w3.save()  # занесли в таблицу Базы данных</pre>
			</li>
			<li>
				Каждый класс модели содержит специальный статический объект objects. - Бедётся из базового класса модели Model и представляет собой ссылку на специальный класс Manager (менеджер записей)
				<pre>
Men.objects  -->  &lt;django.db.models.manager.Manager object at 0x00000188D081FC90>
				</pre>
			</li>
			<li>
				Метод добаления записей create()
				<pre>
Одной строчкой сделали запист в базу данных
w4 = Men.objects.create(title="Александр Овечкин", content="Биография Александра Овечкина")
#можно записать даже без w4 = </pre>
			</li>
			<li>
				Добавим ещё запись:
				<pre>
 Men.objects.create(title="Юрий Каспарян", content="Биография Юрия Каспаряна")</pre>
			</li>
			<li>
				Читаем данные из таблицы:
				<pre>
Men.objects.all()  # чтение всех записей
&lt;QuerySet [&lt;Men: Men object (1)>, &lt;Men: Men object (2)>, &lt;Men: Men object (3)>, &lt;Men: Men object (4).......(5)>]></pre>
				Как видим из этих записей мало что понятно, для изменения этого в модели необходимо прописать метод отображения __str__()
			</li>
			<li>
				Специальные методы __str__ и __repr__ отвечают за строковое представления объекта. При этом используются они в разных местах.
				<br><br>
				Прописываем метод __str__ в модели Men (men/models.py class Men) - снизу после всех полей модели(класса):
				<pre>
# с помощью метода запись нашего класса будет выводится по её заголовку
def __str__(self):
	return self.title</pre>
				Сохраняем models.py
			</li>
			<li>
				Опять пробуем читать таблицу, перед этим необходимо перезайти в django shell
				<pre>
exit() 
python manage.py shell
from men.models import Men
Men.objects.all()

Выведет -->	&lt;QuerySet [&lt;Men: Том Круз>, &lt;Men: Марк Уолберг>, &lt;Men: Вечаслав Бутусов>, &lt;Men: Александр Овечкин>, &lt;Men: Юрий Каспарян>]></pre>
			</li>
			<li>
				Выбираем отдельные элементы списка QuerySet:
				<pre>
Men.objects.all()  # посмотрели все записи в списке QuertSet
w = _  # записали их в переменной w
w[0]  # 0 индекс --> &lt;Men: Том Круз>
w[0]  # 4 индекс --> &lt;Men: Юрий Каспарян></pre>
			</li>
			<li>
				Обращаемся к отдельным полям:
				<pre>
w[1].title  -->  'Марк Уолберг'
w[3].content  -->  'Биография Александра Овечкина'</pre>
			</li>
			<li>
				Длинна списка (количество записей):
				<pre>
len(w)  -->  5</pre>
			</li>
			<li>
				Перебираем все заголовки нашех записей, циклом for:
				<pre>
for wi in w:  # wi это просто переменная
    print(wi.title)  # выведет просто все заголовки с новой строки

Том Круз
Марк Уолберг
Вечаслав Бутусов
Александр Овечкин
Юрий Каспарян</pre>
			</li>
			<li>
				<span class="spec">Метод filter()</span>
				<pre>
Men.objects.filter(title="Александр Овечкин")  --> &lt;QuerySet [&lt;Men: Александр Овечкин>]></pre>
				По критерию Алекс Овечкин, выведутся все записи, в нашем случае такая запись одна
			</li>
			<li>
				Посмортим sql запрос.
				<pre>
from django.db import connection
connection.queries</pre>
			</li>
			<li>Если мы обратимся методом filter() - и не будет ни одного совпадения, нам выдаст просто пустой список</li>
			<li>
				Обращение методом filter() - по id [pk]
				<pre>
Men.objects.filter(pk=2)  # обращаемся по pk 2
&lt;QuerySet [&lt;Men: Марк Уолберг>]></pre>
			</li>
			<li>
				Ряд спецификаторов позволяют найти объекты, свойства которых больше или меньше определенного значения: gt (>), gte (>=), lt (&lt;), lte (&lt;=)
				<pre>
Men.objects.filter(pk__gte=2)  # выведет записи у которых id >= 2
&lt; QuerySet [&lt; Men: Марк Уолберг>, &lt; Men: Вечаслав Бутусов>, &lt; Men: Александр Овечкин>, &lt; Men: Юрий Каспарян>]></pre>
			</li>
			<li>
				<span class="spec">Метод exclude()</span>
				<br>Работает противоположно методу filter()
				<pre>
Men.objects.exclude(pk=2)  # выведет все записи кроме записи с id[pk] 2</pre>
			</li>
			<li>
				<span class="spec">Метод get()</span>
				<br>Когда нам нужно выбрать строго определённую запись по строго определённому критерию, лучше использовать метод get()  - хотя и тот же filter() также сработает
				<pre>
 Men.objects.get(pk=2)  # вывкедет запись по id = 2</pre>
 				Метод get() - используется при авторизации пользователя например
			</li>
			<li>
				order_by - сортировка
				<pre>
Men.objects.filter(pk__lte=4).order_by('title')
&lt;QuerySet [&lt;Men: Александр Овечкин>, &lt;Men: Вечаслав Бутусов>, &lt;Men: Марк Уолберг>, &lt;Men: Том Круз>]>					
#то есть мы выбрали все ключи у которого id	&lt;= 4, и отсортировали по полю title
# методы можно писать сразу в цепочку</pre>
			</li>
			<li>просто отсортируем весь список:
				<pre>
Men.objects.order_by('title')</pre>
				Вместо поля title - можно использывать любое другое поле
			</li>
			<li>
				Изменение записи в таблице:
				<pre>
wu = Men.objects.get(pk=1)  # порчитали и записали в переменную по pk=1 (Том Труз)
wu.title = 'Брэд Питт'  # Изменили заголовок
wu.content = 'Биография Брэда Питта'  # Изменили контент
wu.save()  # записали в таблицу БД
wu  # проверили</pre>
			</li>
			<li>
				<span class="spec">Удаление записей из БД. Метод delete()</span>
				<pre>
 wd = Men.objects.filter(pk__gte=4)  # выбрали все записи pk >= 4 (4 и 5)
 wd  # посмотрели что это за записи
 wd.delete() -->  (2, {'men.Men': 2})  # означает что удалили 2 записи</pre>
			</li>


			<br><br><br><br>
			<li><!-- Jinja2 -->
				<h4 class="title_text border" style="border-color: red; color: rgb(107, 250, 255);">
				Jinja2 - курс</h4>
				<p><a href="https://www.youtube.com/watch?v=cFJqMXxVNsI&list=PLA0M1Bcd0w8wfmtElObQrBbZjY6XeA06U&index=1&t=13s" style="color: rgb(107, 250, 255);">You_Tube</a></p>
				<ul><!-- Jinja2 список начало-->
					
					<li>
						<h6 class="title_text border" style="border-color: red; color: rgb(107, 250, 255);">[1]. О шаблонизаторе, использование</h6>
						<ul>
							<li>Jinja2 - Модуль для обработки шаблонов в Python</li>
							<li>
								Проверяем установлен ли он, в py документе любом пробуем импортировать:
								<pre>
from jinja2 import Template  # импортируем класс шаблоны из джинджи</pre>
								Если не получается то модуль не установлен
							</li>
							<li>
								Устанавливаем Jinja2 - в терминале (PyCharm или Win):
								<pre>
python -m pip install -U Jinja2</pre>
								Я установил в глобальное окружение, возможно необходимо будет устанавливать и в виртуальные окружения.
							</li>
							<li>
								Пример применения:
								<pre>
from jinja2 import Template

first_name = 'Александр'

# создаём экземпляр класса Temp - на основе шаблона ({{}})
tm = Template("Привет {{ name }}"))

# на выходе render - возвращает нам готовую стоку(шаблон)
msg = tm.render(name=first_name)

print(tm)  -->  &lt;Template memory:1f1737b3210>
print(msg)  -->  Привет Александр</pre>
								Пример очень простой, и в подобных случаях лучше просто использовать f строки:
								<pre>
first_name = 'Александр'
msg2 = f"Привет {first_name}"
print(msg2)  -->  Привет Александр</pre>
							</li>
							<li>
								<span class="spec">Конструкции внутри шаблонов:</span>
								<pre>
{% %} - спецификатор шаблона
{{ }} - выражение для вставки конструкция Pithon в шаблон
{# #} - блок комментариев
# ## - строковый комментарий</pre>
							</li>
							<li>
								Пример с двумя переменными:
								<pre>
first_name = 'Александр'
age = 30
tm = Template("Мне {{ a }} лет. Меня зовут - {{ n }}")
msg = tm.render(n = first_name, a = age)
print(tm)  -->  &lt;Template memory:263d9da1a10>
print(msg)  -->  Мне 30 лет. Меня зовут - Александр</pre>
							</li>
							<li>
								Внутри скобок можно прописывать конструкции Python, формулы
								<pre>
tm = Template("Мне {{ a*2 }} лет. Меня зовут - {{ n.upper() }}")
msg = tm.render(n = first_name, a = age)
print(msg)  -->  Мне 60 лет. Меня зовут - АЛЕКСАНДР</pre>
							</li>
							<li>
								Вывод информации из классов:
								<pre>
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

per = Person("Александр", 30)
tm = Template("Мне {{ p.age }} лет. Меня зовут - {{ p.name }}")
msg = tm.render(p=per)

print(msg)</pre>
							</li>
							<li>Вывод информации из словаря(по ключам)
								<pre>
per = {'name': 'Александр', 'age': 30, }
tm = Template("Мне {{ p.age }} лет. Меня зовут - {{ p.name }}")
msg = tm.render(p=per)
print(msg) -->  Мне 30 лет. Меня зовут - Александр</pre>
							</li>
						</ul>
					</li>
					<li>
						<h6 class="title_text border" style="border-color: red; color: rgb(107, 250, 255);">[2]. Экранирование и блоки raw, for, if</h6>
						<ul>
							<li>
								Экранирование {%raw%}...{%endraw%}
								<br>Всю что будет между ними не будит никак преобразоваваться и будет представлено ровно так, как это записано.
							</li>
							<li>
								Игнорирование - символов &lt; ''' и тд при выводе готового варианта html страницы с помощью 'e'
								<pre>
link_1 = ''' бла бла бла &lt;a href=''>ссылка&lt;/a> '''
tm = Template("{{ link | e }}")
msg = tm.render(link=link_1)
print(msg)  -->  бла бла бла &lt;a href=&#39;&#39;&gt;ссылка&lt;/a&gt;</pre>
								То есть на выходе из браузера, мы получим полноценный html текст, такое же как пишем в редакторе.
							</li>
							<li>
								Предыдущий код можно выполнить гораздо проще с помошью метода escape
								<pre>
from markupsafe import escape  # markupsafe кстанавливается в месте с jinja
link_1 = ''' бла бла бла &lt;a href=''>ссылка&lt;/a> '''
msg = escape(link_1)
print(msg)</pre>
								На выходе то же самое что и предыдущий код
							</li>
							<li><span class="spec">{% Выражение for %}</span>
								<pre>
{%for-варажение-%}									
повт. фрагмент
{%endfor%}</pre>
							</li>
							<li>
								Пример использования for в шаблоне:
								<pre>
cityes = [
    {'id': 1, 'city': 'Волгоград'},
    {'id': 5, 'city': 'Москва'},
    {'id': 7, 'city': 'Тверь'},
    {'id': 8, 'city': 'Смоленск'},
    {'id': 11, 'city': 'Калуга'},
]

link = '''&lt;select name="cityes">
{% for c in cityes %}
    &lt;option value="{{c['id']}}">{{c['city']}}&lt;/option>
{% endfor %}
&lt;/select>'''

tm = Template(link)
msg = tm.render(cityes=cityes)
print(msg)

----------------->

&lt;select name="cityes">

    &lt;option value="1">Волгоград&lt;/option>

    &lt;option value="5">Москва&lt;/option>

    &lt;option value="7">Тверь&lt;/option>

    &lt;option value="8">Смоленск&lt;/option>

    &lt;option value="11">Калуга&lt;/option>

&lt;/select></pre>
							</li>
							<li>
								Добавив - уберутся переносы строк
								<pre>
{% for c in cityes -%}
код
{% endfor -%}</pre>
							</li>
							<li>
								<span class="spec">{% Выражение if %}</span>
								<pre>
{%if-варажение-%}
фрагмент - при истинности условий
{%endif%}</pre>
							</li>
							<li>
								Пример блока if в шаблоне:
								<pre>
link = '''&lt;select name="cityes">
{% for c in cityes -%}
{% if c.id > 7 -%}  # минусы расставляем чтобы не получалось пустых строк
    &lt;option value="{{c['id']}}">{{c['city']}}&lt;/option>
{% endif -%}
{% endfor -%}
&lt;/select>'''

tm = Template(link)
msg = tm.render(cityes=cityes)
print(msg)  -->  Выведет только Смоленск и Калуга</pre>
								Так же в блоке можно добовлять конструкцию elif, else - всё по правилам Python.
							</li>
						</ul>
					</li>

					<li>
						<h6 class="title_text border" style="border-color: red; color: rgb(107, 250, 255);">[3]. Фильтры и макросы macro, call</h6>
						<ul>
							<li>
								Сумма по атрибуту из списка словарей в шаблоне:
								<pre>
cars = [
    {'price': 23000, 'model': 'Ауди'},
    {'price': 17300, 'model': 'Шкода'},
    {'price': 44300, 'model': 'Вольво'},
    {'price': 21300, 'model': 'Фольксваген'},
]
tpl = "Суммарная цена автомобилей {{ cs | sum(attribute='price') }}"
# sum(attribute='price') - сложит все цены из списка

tm = Template(tpl)
msg = tm.render(cs=cars)
print(msg)  -->  Суммарная цена автомобилей 105900</pre>
							</li>
							<li>
								Сумма чисел из элементов числового списка в шаблоне:
								<pre>
digs = [1, 2, 3, 4, 5]
tpl = "Сумма чисел списка - digs: {{ digit | sum }}"
tm = Template(tpl)
msg = tm.render(digit=digs)
print(msg) -->  Сумма чисел списка - digs: 15</pre>
							</li>
							<li>
								sum(inereble,attribute=None, start=0)
								<br>Если чего то не нужно в конкретном случсе, то поля не обязательны
							</li>
							<li>
								Максимальная цена из списка автомобилей:
								<pre>
cars = [
    {'price': 23000, 'model': 'Ауди'},
    {'price': 17300, 'model': 'Шкода'},
    {'price': 44300, 'model': 'Вольво'},
    {'price': 21300, 'model': 'Фольксваген'},
]
tpl = "Максимальная цена из списка автомобилей {{ cs | max(attribute='price') }}"
tm = Template(tpl)
msg = tm.render(cs=cars)
print(msg) -->  Максимальная цена из списка автомобилей {'price': 44300, 'model': 'Вольво'}</pre>
							</li>
							<li>
								Если нужно вывести только марку автомобяля с максимальной ценой:
								<pre>
cars = [
    {'price': 23000, 'model': 'Ауди'},
    {'price': 17300, 'model': 'Шкода'},
    {'price': 44300, 'model': 'Вольво'},
    {'price': 21300, 'model': 'Фольксваген'},
]
tpl = "Самый дорогой автомобиль в списке: {{ (cs | max(attribute='price')).model }}"
tm = Template(tpl)
msg = tm.render(cs=cars)
print(msg) -->  Самый дорогой автомобиль в списке: Вольво</pre>
								Аналогично работает фильтр min
							</li>
							<li>
								Фильтр random - выберет случайный элемент списка
								<pre>
tpl = "Случайный авто в виде словаря: {{ cs | random }}"
tm = Template(tpl)
msg = tm.render(cs=cars)
print(msg)
-->  Случайный авто в виде словаря: {'price': 44300, 'model': 'Вольво'}
-->  Каждое выполненние программы будет менять вывод</pre>
							</li>
							<li>
								Заменяем символы, например о на (.):
								<pre>
tpl = "Случайный авто в виде словаря: {{ cs | replace('о','(.)') }}"
tm = Template(tpl)
msg = tm.render(cs=cars)
print(msg)  -->  [{....{'price': 17300, 'model': 'Шк(.)да'}, {'pr....}]
								</pre>
							</li>
							<li>
								<span class="spec">{% filter..%}</span>
								Применение фильтров непосредственно внутри шаблонов
								<pre>
{% filter-название фильтра-%}
-фрагмент для применения вильтра-
{% endfilter -%}
								</pre>
							</li>
							<li>
								Пример. Сделаем все буквы в именах в верхнем регистре:
								<pre>
men = [
    {'name': 'Алексей', 'old': 18, 'weight': 78.5},
    {'name': 'Николай', 'old': 28, 'weight': 82.3},
    {'name': 'Иван', 'old': 33, 'weight': 94},
]
tpl = '''
{%- for u in users -%}
{% filter upper %}{{ u.name }}{% endfilter %}
{% endfor -%}
'''
tm = Template(tpl)
msg = tm.render(users=men)
print(msg)
------------->
АЛЕКСЕЙ
НИКОЛАЙ
ИВАН</pre>
							</li>
							<li>
								Макроопределения - для издегания повторяемых определений
								Прописываем значения в тегах html - python кодом
								<br>{% macro %}  - {% endmacro %}
							</li>
							<li>
								{% call %}  - {% endcall %} - вложенные макросы
							</li>
						</ul>
					</li>

					<li>
						<h6 class="title_text border" style="border-color: red; color: rgb(107, 250, 255);">[4]. Загрузчики шаблонов - FileSystemLoader, PackageLoader, DictLoader, FunctionLoader</h6>	
						<ul>
							<li>
								Кратно - загрузка html кода из html страницы (шаблона):
								<br>tpl - находится внутри html в body - там конструкция for
								<pre>
from jinja2 import Environment, FileSystemLoader
# FileSystemLoader - Это загрузчик который работает с нашим SSD

men = [
    {'name': 'Алексей', 'old': 18, 'weight': 78.5},
    {'name': 'Николай', 'old': 28, 'weight': 82.3},
    {'name': 'Иван', 'old': 33, 'weight': 94},
]

file_loader = FileSystemLoader('templates')  # из какого подкоталога будем брать шаблоны
#('templates') - путь (папка_где_мы_находимся/templates)
#('') - если бы необходимо было брать из корневого подкоталога

env = Environment(loader=file_loader)
# Environment - это класс, через который как раз и идёт работа с API

tm = env.get_template('main.html')
# формируем класс Template - на основе main.html

msg = tm.render(users=men)
# получение на выходе текстовой строки уже преобразованного шаблона

print(msg)

								</pre>
							</li>
							<li>
								Стандартные загрузчики в пакете Jinja:
								<br>-FileSystemLoader - берёт шаблоны из фаловой системы нашего устройства(жусткий диск)
								<br>-PackegeLoader - для загрузки пакета из шаблона
								<br>-DictLoader - Для загрузки шаблонов из словаря
								<br>-FunctionLoader - для загрузки на основе функции
								<br>-PrefixLoader - загрузчик, использующий словарь для построения подкаталогов
								<br>-CholeLoader - загрузчик, содержащий список других загрузчиков (если один не сработает выбирается слудующий)
								<br>-ModeuleLoader - загрузчик для скомпилированных шаблонов
						</ul>
					</li>
					

					<li>
						<h6 class="title_text border" style="border-color: red; color: rgb(107, 250, 255);">[5]. Конструкции include и import</h6>
						<ul>
							<li>
								Разделение шаблонов на заголовок(навбар например) - контент страницы - футер страницы.
								<br>заголовки и футеры обычно одинаковые для всех страниц сайта
								<br>Для того чтобы не писать футер и заголовок каждый раз, с помощью include можно сократить работу
								<br><br>
								Предположим у нас есть 3 html страницы = navbar.html/content.html/footer.html. Внутри контента чтобы не дублировать постоянно можно сделать так:
								<pre>
{% include 'navbar.html' %}
&lt;p> основной контент &lt;/p>
{% include 'footer.html' %}</pre>
							</li>
							<li>
								Если вдруг программан не найдёт файл navbar.html - чтобы не возникало ошибок, а шаблон сформировался без навбара добавим ignore missing
								<pre>
{% include 'navbar222.html' ignore missing %}
&lt;p> основной контент &lt;/p>
{% include 'footer.html' %}</pre>
							</li>
							<li>
								Конструкция import - при импорте файл не добавляется но мы можем использовать функционал этого файла (например - макрос)
							</li>
						</ul>
					</li>

					<li>
						<h6 class="title_text border" style="border-color: red; color: rgb(107, 250, 255);">[6]. Наследование расширение шаблонов</h6>
						<ul>
							<li>
								{% block title %} заголовок {% endblock %}
								<br>{% block content %} контент {% endblock %}
							</li>
							<li>
								<pre>
{% extends 'base.html' %} # имя базового шаблона на основе которого будет и строится страцица
{% block title %} название страницы {% endblock %}

{% block content %}
основной контент
{% endblock %}</pre>
							<li>
								{{self.title()}}
								<pre>
{% extends 'base.html' %}
{% block title %} название страницы {% endblock %}

{% block content %}
{{self.title()}}  # обращаемся к блоку title  - напишет название страницы
основной контент
{% endblock %}</pre>
							</li>
							<li>
								{{ super() }} 
							</li>
							<li>
								<img src="images\base_tpl.jpg" class="img-fluid">
								<br><br>
								<br>base.tpl - содержит какойто шаблон (ex_main)
								<br>child1 - расширяет base.tpl
								<br>child2 - расширяет child1
							</li>
						</ul>
					</li>
				
				</ul><!-- Jinja2 список конец-->
			</li><!-- Jinja2 всё -->
			<br><br>


			<br><br>
			<h4 class="title_text border">[6]. Шаблоны (templates). Начало.</h4>
			<li>
				Во views.py изначаньно импортирована функция render.
				<br><span class="spec">render - встроенный шаблонизатор Django</span>
				<br>Функкия render - производит обработку наших шаблонов
			</li>
			<li>
				<span class="spec">Шаблон - это по сути html страница</span>
			</li>
			<li>
				В качестве главной страницы отабразим шаблон в файле index.html (создадим позже), аналогично about.html
				<ol type="A">
					<li>
						В men/views.py - проверяем, импортирован ли встроенный шобланизатор (функция render)
						<pre>
from django.shortcuts import render</pre>
					</li>
					<li>
						В men/views.py - изменяем функцию index
						<pre>
def index(request):  # главная страница
    return render(request, '')  # (request, 'путь к шаблону') - путь укажем позже</pre>
					</li>
					<li>
						В men - создаём директорию - 'templates', а в папке templates - необходимо создать ещё один подкоталог c названием приложения.
						<br>То есть получилось coolsite/men/templates/men - Это делается потому что приложений может быть множество, и в каждом может быть templstes, а название шаблонов может совпадать (home.html, index.html и тд)
						<br>В случае если название шаблонов будет совпадать, django выберет шаблон, первый попавшийся - для этого в templates каждого приложения и делают ещё один подкатолог с названием приложения
					</li>
					<li>
						В templates/men - создадим index.html, При работе с Pithon или Django - в meta charset - всегда необходимо делать UTF 8 
					</li>
					<li>
						Добавляем путь к нашему шаблону. В men/views.py - def index
						<pre>
return render(request, 'men/index.html')  # (request, 'путь к шаблону')</pre>
					</li>
					<li>
						Место где django будет искать шаблоны прописаны в settings.py. TEMPLATED - 'APP_DIRS': True - то есть будет искать в папках приложения, в каталогах с именем templates
					</li>
					<li>
						Создадим ещё html файл - в templates/men - about.html
					</li>
					<li>
						В men/views.py - пропишем функкцию для отображения about.html
						<pre>
def about(request):  # главная страница
    return render(request, 'men/about.html')  # (request, 'men/templates/men/about.html')</pre>
					</li>
					<li>
						В men/urls.py - в путях можно убрать пути к категориям и архивам, и юдобавляем путь для страницы 127.0.0.1:8000/about
						<pre>
path('cats/&lt;int:catid>/', categories), - удаляем
re_path(r'archive/(?P&lt;year>[0-9]{4})/', archive), -удаляем

 # путь('url/', функция, name='имя для пути'),
 path('about/', about, name='about'),</pre>
					</li>
				</ol>
			</li>
			<li>
				Передаём параметры с помощью {{}} - {%for%}
			<ol type="A">

					<li>
						Отображаем title - автоматически, с помощью {{}}
						<br>В Заголовках html (about.html index.html) добавляем конструкцию шаблона {{}}
						<pre>
&lt;title>{{ title }}&lt;/title></pre>
						<br>Добавим в viewp.py - параметры, в виде словаря которые в виде шаблонов будем передавать в html {{ title }}
						<br>Дополняем функции index и about
						<pre>
# (request, 'путь к шаблону', передаваемый параметр - словарь)
return render(request, 'men/index.html', {'title': 'Главная страница'})

# (request, 'men/templates/men/about.html', {'ключ':'значение'})
return render(request, 'men/about.html', {'title': 'О сайте'})</pre>
					</li>
					<li>
						Усложняем функуию индекс, и будеи передавать несколько параметров (список и title).
						<br>В men/views.py - до функции добавим список, внутри функции добавим передаваемый в будущем параметр(этот список):
						<pre>
menu = ['О сайте', 'Добавить статью', 'Обратная связь', 'Войти']

def index(request):  # главная страница
    # (request, 'путь к шаблону', передаваемые параметры параметры)
    return render(request, 'men/index.html', {'menu': menu, 'title': 'Главная страница'})</pre>
    					<br>В свою уочередь в index.html - передаём пареметр menu - с помощью цикла for:
    					<pre>
    &lt;h1>Главная страница</h1>
    &lt;ul>
    {% for m in menu %}
        &lt;li>{{m}}&lt;/li>
    {% endfor %}
    &lt;/ul></pre>
    					На выходе у у нас Получится ul оформленный список, из жлементов списка menu
					</li>
					<li>
						В about.html - передаём тот же список, изменяя функцию about и саму страницу about.html
					</li>

				</ol>
			</li>
			<li>
				Наследование шаблонов! Чтобы не повторять одинковый код - например navbar, footer
				<ol type="A">
					<li>
						Создаём базовый шаблон, шаблон в котором будет одинаковай html код для всех страниц нашего сайта.
						<br>В templates/men - создаём base.html
					</li>
					<li>
						Пишем код base.html:
						<pre>
&lt;!DOCTYPE html>
&lt;html>
&lt;head>
    &lt;meta charset="utf-8">  # проверяй utf-8
    &lt;meta name="viewport" content="width=device-width, initial-scale=1">
    &lt;!-- css bootstrap 5 -->  # добавляй css ссылку 
    &lt;title>{{ title }}&lt;/title> # автоматом будет менятся название страниц
&lt;/head>
&lt;body>
    {% block mainmenu %}  # по сути блок навбара
    &lt;ul>
        {% for m in menu %} # список навбара через for
        &lt;li>{{m}}&lt;/li> # элементы списка
        {% endfor %} 
    &lt;/ul>
    {% endblock mainmenu %} # конец навбара

    {% block content %}  # индивидуальный контент для каждой страницы
    {% endblock %}  # конец индивид контента



&lt;!-- JS Bootstrap 5 -->  # добавь JS скрипты bootstrap
&lt;/body>
&lt;/html></pre>
						!Лично мне с html - гораздо удобнее работать в Sublime Text!
					</li>
					<li>
						Изменяем  - наследуемся в index/about.html от base.html
						<br>Пример index.html - about.html - аналогично:
						<pre>
{% extends 'men/base.html' %}  # наследуемся от base.html

{% block content %}  # начало индивидуального контента
&lt;h1>{{ title }}&lt;/h1>  # сам контент
&lt;p>О&lt;сновной индивидуальный контент&lt;/p> # сам контент
{% endblock %} # конец индивидуального контента</pre>
					</li>
				</ol>
			</li>

			<li>
				<span class="spec">Чтение данных таблицы нашей модели(класса Men) в шаблонах:</span>
				<ol type="A">
					<li>
						В men/views.py - импортируем все модели
						<pre>
from .models import *  # импортируем все модели из men/models.py</pre>
					</li>
					<li>
						В men/views.py - в функциу представления для главной страницы - index. Возьмём все запси из таблицы, сохраним ссылку на них в переменной(post), Передадим post - в качестве параметра, чтобы было возможно отобразить их на html странице.
						<pre>
def index(request):  # главная страница
    # Берем все записис модели, помещаем в переменную
    posts = Men.objects.all()
    # (request, 'путь к шаблону', передаваемые параметры параметры)
    return render(request, 'men/index.html', {'posts': posts, 'menu': menu, 'title': 'Главная страница'})</pre>
					</li>
					<li>
						Отображаем наши записи в index.html:
						<pre>
{% block content %}
&lt;h1>{{ title }}&lt;/h1>
&lt;ul>
    {% for p in posts %}
    &lt;li>
        &lt;h2>{{ p.title }}&lt;/h2>
        &lt;p>{{ p.content }}&lt;/p>
        &lt;hr>  # линия снизу
    &lt;/li>
    {% endfor %}
&lt;/ul>
{% endblock %}</pre>
				</ol>
			</li>


			<br><br>
			<h4 class="title_text border">[7].  Подключение статических файлов. Фильтры шаблонов.</h4>
			<li>
				Во время отладки django ищет статические файлы во всех подкоталогах static(их может быть несколько)
				<br>
				Но в режиме экслплуатации - на реальном веб сервере - статические файлы будут браться из одной главной папки статический файлов (djsite/coolsite/scatic) - расположенной в каталоге всего проекта
			</li>
			<li>
				Для того чтобы собрать все статические файлы в этот главный поткаталог, в терминале необходимо все статические файлы собрать.
				<pre>
Python manage.py collectstatic</pre>
				<br><strong>Но для корректрой работы необходимо прописать настройки в settings.py для:</strong>
				<br>-STATIC_URL - префикс URL-адреса
				<br>-STATIC_ROOT - путь к общей статической папке, используемый реальым веб-сервером
				<br>-STATICFILES_DIRS - список дополнительных(нестандартных) путей к статическим файлам, используемых для сбора и для рещима отладки
			</li>
			<li>
				Прописываем все константы STATIC в settings.py - после STATIC_URL (его оставляем стандартно)
				<pre>
STATIC_URL = 'static/'  # стандартно

# STATIC_ROOT добавили, в эту папку при collectstatic - django перемещает все статические файлы
# путь djsite/coolsite - из этой папке, статический файлы будут пользоватся в режиме эксплуатации сайта на сервере
STATIC_ROOT = BASE_DIR / 'static'

# добавили пустой список, список нестандартных путей, пока у нас нет, оставим пустым
STATICFILES_DIRS = []</pre>
			</li>
			<li>
				-Создадим в men - папку static
				<br>-В static - папку men (аналогично с templete)
				<br>-В men/static/men - папку css
				<br>-В men/static/men - папку js
				<br>-В men/static/men - папку imsges
			</li>
			<li>
				В папке css - создадим styles.css
				<br>Что бы не терять время беру с гитхаба создателя курса - этот файл, там ничего сложного стандартные css стили.
			</li>
			<li>
				Аналогично, копирую c github-a - images - в men/static/men/images - картинки которые будем использовать в шаблоне
			</li>
			<li>
				Подгружаем наши статические файлы в base.html - в самом верху страницы - до html кода
				<pre>
{% load static %}</pre>
				-Добавляем путь для нашего style.css - в head - base.html
				<pre>
&lt;link rel="stylesheet" type="text/css" href="{% static 'men/css/styles.css' %}" /></pre>
				Можно обнавлять сттраницу, если изменений нет попробуй Mozilla - В Хроме сохраняется кэш, и изменения стилей иногда срабатывают с опозданием, возможно сработают только после перезапуска праузера или даже пк.
			</li>
			<li>
				Верстаем наши страницы все, приводим вид в порядок, используем styles.css. Не Буду подробно описывать процесс
				<ul>
					<li>
						В base.html:
						<br>Загружаем иконку
						<pre>
&lt;!-- загружаем иконку для отоброжения в браузере где titte-->
&lt;link rel="shortcut icon" href="{% static 'men/images/main.ico' %}" type="image/x-icon"/></pre>
						И так далее. Очень много писать, но всё просто.
					</li>
					<li>
						Напоминалка по тегам таблицы html
						<pre>
table - таблица
thead - голова таблицы
tr - строка
td - столбец
th - заголовок в таблице
&lt;th colspan="4> - заголовок будет растянут на столбца</pre>
					</li>
					<li>
						index.html
						<pre>
{% extends 'men/base.html' %}

{% block content %}
&lt;ul class="list-articles">
    {% for p in posts %}
    &lt;li>
        &lt;h2>{{ p.title }}&lt;/h2>
        &lt;p>{{ p.content }}&lt;/p>
        &lt;div class="clear">&lt;/div>
        &lt;p&lt; class="link-read-post">&lt;a href="#">Читать пост&lt;/a>&lt;/p>
        &lt;hr>
    &lt;/li>
    {% endfor %}
&lt;/ul>
{% endblock %}</pre>
					</li>
					<li>
						about.html
						<pre>
{% extends 'men/base.html' %}

{% block content %}
&lt;h1>{{ title }}&lt;/h1>
&lt;p>здесь будет информация о сайте&lt;/p>
{% endblock %}</pre>
					</li>
				</ul><!-- Верстаем -->
			</li><!-- Верстаем -->

			<li>
				<span class="spec">Использование фильтров при работе с шаблонами</span>
				<br><span class="spec">{{ переменная | фильтр: 'значение' }}</span>
				<br>Фильтров много, просмотри и изучи официальную документацию по встроенными фильтрам джанго.
			</li>
			<li>
				Разбиваем текст по абзацам (в index.html):
				<pre>
&lt;p>{{ p.content }}&lt;/p>  -->  &lt;p>{{ p.content|linebreaks }}&lt;/p></pre>
			</li>
			<li>
				Отображаем на главной странице только первые 50слов статьи.
				в index.html - добавляем фильтр:
				<pre>
&lt;p>{{ p.content|linebreaks }}&lt;/p> -->  &lt;p>{{ p.content|linebreaks|truncatewords:50 }}&lt;/p></pre>
			</li>
			<li>{% autoescape off %} # 'выключить экранирование, по умолчанию включено.
				<pre>
{% autoescape off %}  # выключить экранирование
	{{p.content|linebreaks|truncatewords:50}}
{% endautoescape %}  # конец зоны выключения экранирования</pre>
			</li>

			<br><br>
			<h4 class="title_text border">[8].  Формирование URL-адресов в шаблонах.</h4>
			<li>
				<span class="spec">{% url 'URL-адрес/имя маршутра' [параметры ссылки] %}</span>
			</li>
			<li>
				Делаем ссылку для главной страницы (в base.html) - в навбаре, на лого сайта
				<pre>
href="/" #самый простой вариант для главной страницы - но так делать не стоит!</pre>
				Этот вариант лучше не делать, так как для главной страницы может быть изменен, путь, тогда придётся в каждом шаблоне менять путь
			</li> 
			<li>
				Лучше всего использовать имена маршрутов, которые прописываем в name - в path - urlpatterns
				<br>И так путь к домашней странице будем указывать
				<pre>
&lt;a href="{% url 'home' %}"></pre>
			</li>
			<li>
				Меняем структуру списка menu - это список в навбаре (сделаем словарь)
				<br>В men/views.py - узменяем menu:
				<pre>
# список - для navbar
menu = [{'title': 'О сайте', 'url_name': 'about'},
        {'title': 'Добавить статью', 'url_name': 'add_page'},
        {'title': 'Обратная связь', 'url_name': 'contact'},
        {'title': 'Войти', 'url_name': 'login'},
]</pre>
			</li>
			<li>
				Добавляем пути для Добавить статью, Контакты, Войти
				<br>В men/urls.py:
				<pre>
path('addpage/', addpage, name='add_page'),
path('contact/', contact, name='contact'),
path('login/', login, name='login'),</pre>
			</li>
			<li>
				В men/views.py - создаём функции представления страницы
				<br>addpage, contact, login
				<pre>
def addpage(request):
    return HttpResponse('&lt;h1>Страница создания статьи&lt;/h1>')

def contact(request):
    return HttpResponse('&lt;h1>Страница Обратной связи&lt;/h1>')

def login(request):
    return HttpResponse('&lt;h1>Авторизация&lt;/h1>')</pre>
			</li>
			<li>
				Изменим функуию index. Так как передаём слишком много ключей, лучше ключи поместить в отдельный словарь, и в передаваемый параметр - передать этот словарь.
				<br>В men/views.py - def index:
				<pre>
def index(request):  # функция отображения главной страница
    # Берем все записи из модели, помещаем в переменную
    posts = Men.objects.all()
    # context - словарь передаваемых параметров
    context = {
        'posts': posts,  # все записи модели Men - title, content, photo...
        'menu': menu,  # navbar - title, url_name
        'title': 'Главная страница',  # название страницы
    }
    return render(request, 'men/index.html', context=context)</pre>
			</li>
			<li>
				Прописываем пути в navbar -  в шаблоне base.html.
				<br>Перебираем всп m(элементы списка меню) - обращаемся к ключу url.mane
				<br><strong>Когда обращаемся к имени url нужны ковычки, когда к прописаноому в словаре имени пути по ключу, в шаблоне кавычки не нужны</strong> 
				<pre>
{% for m in menu %}

	{% if not forloop.last %}
	&lt;li>&lt;a href="{% url m.url_name %}">{{m.title}}&lt;/a>&lt;/li>
	{% else %}
	&lt;li class="last">&lt;a href="{% url m.url_name %}">{{m.title}}&lt;/a>&lt;/li>
	{% endif %} 

{% for m in menu %}</pre>
			</li>
			<li>
				Добавляем пути для для отдельных статей, по id
				<br><span class="spec">path('post/&lt;int:post_id>/'</span>
				<br>В men/urls/py
				<pre>
path('post/&lt;int:post_id>/', show_post, name='post'),</pre>
			</li>
			<li>
				Делаем функцию для отображения страницы отдельной статьи - show_post
				<br>В men/views.py:
				<pre>
def show_post(request, post_id):  # обязательно добавь доп параметр post_id
    return HttpResponse(f'Отображение статьи с id = {post_id}')</pre>
			</li>
			<li>
				Добавляем саму ссылку, для статьи в шаблон - index.html
				<pre>
<span class="spec">В1 - {% url 'post' p.pk %}</span>
href="{% url 'post' p.pk %}"  
- Варинт 1 - обращаемся по имени пути 'post' 
- далее к объекту цикла p  из списка posts (posts=Men.objects.all())
- по ключу pk то есть id в базе данных</pre>
			</li>
			<li>
				<span class="spec">В2 - {{ p.get_absolute_url }}</span>
				<br>В2 - отображение ссылки по pk, более предрочтительный!
				<br>Но для этого в models.py - необходимо прописать функцию - внутри класса Men а затем уже отобразить в ссылку в самом шаблоне:
				<ol type="A">
					<li>
						В models.py импортируем функцию reverse
						<pre>
from django.urls import reverse</pre>
					</li>
					<li>
						В моделе Men дописываем функцию(метод) - которая будет формировать нам нужный маршрут  - def get_absolute_url:
						<pre>
def get_absolute_url(self):  # функция формирования маршрута к ссылке
    return reverse('post', kwargs={'post_id': self.pk})</pre>
					</li>
					<li>
						Указываем ссылку непосредственно в шаблоне - index.html
						<pre>
{% for p in posts %}
....							
	href="{{ p.get_absolute_url }}
....
{% endfor %}

# p - это экземпляр(строка) таблицы
# get_absolute_url - обращаемся непосредственно к функции внутри класса</pre>
						Способ В2 - предпочтительнее делать если мы обращаемся к элементам модели.
						<br>Способ В1 - когда мы просто обращаемся к списку, например к ссылкам в navbar
					</li>
				</ol>
			</li>

			<br><br>
			<h4 class="title_text border">[9].  Создание связей между моделями через класс ForeignKey.</h4>
			<li>
				Будем создавать новую модель категории с двумя столбцами (id-автоматом, name - название категории)
				<br>Две модели необходимо будет связать, прописав связь класса мен и категории (в модел Men - добавим cat_id)
			</li>
			<li>
				В Django - есть три типа сввязи:
				<br>-ForeingKey - поля отношений один ко многим. Для связи Many to One. В нашем случае к одной категории Спортсмены, может относится множество разных спортсменов
				<br>-ManyToManyField - многие ко многим. Many to Many.
				<br>-OneToOneField - Один к одному (One to One)
			</li>
			<li>Первичная мадель в нашем случаее - Категории, Вторичная - отдельные личности модел Men</li>
			<li>
				Класс ForeingKey(ссылка на первичную модель, on_delete=ограничения при удалении)
				<br>on_delete - если например удалили модель спортсены, необходимо решить что делать с параметром cat_id - для спортсменов
			</li>
			<li>
				<span class="spec">on_delete:</span>
				<br>-models.CASCADE - удалили категорию - удаляются все записи связанные с этой категорией
				<br>-models.PROTECT - запрещает удаление категории, если на неё есть ссылка в модели Men
				<br>-models.SET_NULL - при удалении категории, устанавливает щначение foreign key NULL
				<br>-models.SET_DEFAULT - то же самое что и NULL - только вместо NULL - устанавливает значение по умолчанию, которое должно быть определено через класс ForeingKey
				<br>-models.SET() - то же самое, только устанавливает пользовательское значение
				<br>-models.DO_NOTHING - удаление категории - никак не повлияет на записи в Men
			</li>
			<li>
				Создаём модель категории, в нём одно поле name, id будет автоматом.
				<br>-максимальная длина символов 100
				<br>Сразу в этом клессе пропишем метод __str__()
				<pre>
class Category(models.Model):
    # db_index - для того чтобы поле было индексированным, поиск по небу будет происходить быстрей
    name = models.CharField(max_length=100, db_index=True)

    # будем обращатся к категории по полю name
    def __str__(self):
        return self.name</pre>
			</li>
			<li>
				В модели Men - добавим поле cat. Это поле и будет модель отношений ForeingKey
				<pre>
cat = models.ForeignKey('Category', on_delete=models.PROTECT)
#models.PROTECT - категорию нельзя будет удалить пока это прописано в модели Men
# cat_ig - id добавится автоматом4</pre>
			</li>
			<li>
				Формируем новую миграцию, так как изменили и добавили модели, теперь все эти изменения необходимо добавить в Базу данных, в терминале:
				<pre>
python manage.py makemigrations</pre>
				У Django встал вопрос, что теперь делать с записями Men, так как к ним добавилось поле cat - и это поле пустое. У нас в Category даже записей никаких нет, то есть нет никаких категорий (спортмсены, музыканты и так далее)
				<br>На данный момент, в терминале выберем второй вариант
				<br>А саму строчку отношений, на данный момент сделаем необязательным в модели Men
				<pre>
 cat = models.ForeignKey('Category', on_delete=models.PROTECT, null=True)</pre>

			</li>
			<li>
				Сохраняем models.py.
				Снова создаём миграции makemigrations - в корневой папке каталога:
				<pre>
python manage.py makemigrations</pre>
				В папке миграций появился новый файл миграций									
			</li>
			<li>
				Выполняем эти миграции, то есть отправляем в базу данных
				<pre>
python manage.py migrate</pre>
			</li>
			<li>
				Можно посотреть наглядно на наши таблицы в pdAdmin 4 
			</li>
			<li>
				Желательно сдела на реальный проектах не вносить изменения в структуру таблиц, и продумывать модели заранее.
			</li>
			<li>
				Добавляем 2 категории  - через python sell
				<pre>
python manage.py shell  # Запускаем командную строку питона
from men.models import *  # Импортируем все модели из models.py
Category.objects.create(name='Актёры')  # добавляем категорию - Актёры 
Category.objects.create(name='Музыканты')  # добавляем категорию - Музыканты</pre>
			</li>
			<li>
				Теперь во всех записях Men присвоим значение в столбце cat_id
				<pre>
w_list = Men.objects.all()  # в переменную заносим все записи Men
w_list.update(cat_id=1)  # во всех записях поменяли cat_id на 1</pre>
			</li>
			<li>
				Делаем отображение списка категорий
				Для этого в base.html - меняем структуры ссылок в Sidebar
				<br>Опять же будеи использовать цикл for.
				<br>Так же будем использовать конструкцию if - для того в каком виде отобразить категорию (если выбрана - то как строку, если не выбрано - как ссылку)
				<br><br>Изменения структурры ссылок Sidebar в base.html:
				<pre>
# еслы ссылка выбрана (то есть не выбрана категория никакая) 
тогда "все категории" отобразатся не как ссылка, а просто надписью
иначе, если будет выбрана какаято категория, то "все категории" - будет ссылкой
{% if cat_selected == 0 %}
    &lt;li class="selected">Все категории&lt;/li>
{% else %}
    &lt;li>&lt;a href="{% url 'home' %}">Все категории&lt;/a>&lt;/li>
{% endif %}


# далее цикл: перебираем записи c в модели cats
# cats = Category.objects.all() - в def index
# проверка если ключ pk == выбранной категории cat_selected
будет показывать как простую  строку (выделенную как выбраная)
если не совпадают будут показывать как ссылку
{% for c in cats %}
    {% if c.pk == cat_selected %} 
        &lt;li class="selected">{{ c.name }}&lt;/li>
    {% else %}
        &lt;li>&lt;a href="{{ c.get_absolute_url }}">{{ c.name }}&lt;/a><&lt;li>
    {% end&lt;if %}
{% endfor %}</pre>
			</li>
			<li>
				Прописываем метод формирования маршрута к ссылке -  get_absolute_url - Для модели Category - в men/models.py
				<pre>
# функция формирования маршрута к ссылке
def get_absolute_url(self):
    return reverse('category', kwargs={'cat_id': self.pk})</pre>
			</li>
			<li>
				Добавляем путь для категорий - в men/urls.py
				<pre>
path('category/&lt;int:cat_id>/', show_category, name='category'),</pre>
			</li>
			<li>
				Ранее писали def categories/archive - их можно удалить, писали в целях обучения
			</li>
			<li>
				Добавляем метод отображения страниц категорий - def show_category - в men/views.py
				<pre>
def show_category(request, cat_id):  # обязательно добавь доп параметр cat_id
    return HttpResponse(f'Отображение категории с id = {cat_id}')</pre>
			</li>
			<li>
				В параметры функции index - необходимо доаввить передаваемый параметр записей модели категории. Поместим её в переменную cats - в шаблоне base.html - мы к этой переменной уже обращались в цикле for.
				<br>Так же необходимо добавить переменную cat_selected - к ней уже обращались в шаблоне base.html в конструкции if - для отображения категорий ссылкой или строкой
				<br><br>
				Кратнко все манипуляции в def index:
				<br>cats = Category.objects.all()
				<br>context = {...,'cats': cats,...} добавили, в список передаваемых параметров
				<br>context = {...,'cat_selected': 0, } добавили, в список передаваемых параметров
				<br><br>Метод отображения домашней страницы - def index - целиком:
				<pre>
def index(request):  # функция отображения главной страница
    # Берем все записи из модели Men, помещаем в переменную
    posts = Men.objects.all()
    # Берем все записи из модели категории, помещаем в переменную
    cats = Category.objects.all()

    # context - словарь передаваемых параметров
    context = {
        'posts': posts,  # все записи модели Men - title, content, photo...
        'cats': cats,  # все записи модели категории
        'menu': menu,  # navbar - title, url_name
        'title': 'Главная страница',  # название страницы
        'cat_selected': 0,  # будут отображаться все записи
    }
    return render(request, 'men/index.html', context=context)</pre>
			</li>
			<li>
				Меняем функцию show_category - за основу можно взять функцию index:
				<pre>
def show_category(request, cat_id):  # обязательно добавь доп параметр cat_id
    # Берем только cat_id (номер категории)
    posts = Men.objects.filter(cat_id=cat_id)
    # Берем все записи из модели категории, помещаем в переменную
    cats = Category.objects.all()

    # context - словарь передаваемых параметров
    context = {
        'posts': posts,  # cat_id - к какой категории принадлежит запись в таблице Men
        'cats': cats,  # все записи модели категории
        'menu': menu,  # navbar - title, url_name
        'title': 'Отображение по рубрикам',  # название страницы
        'cat_selected': cat_id,  # cat_selected - принимает значение cat_id записи Men
    }
    # Шаблон домашней страницы, несмотря на то что это категории
    return render(request, 'men/index.html', context=context)</pre>
			</li>
			<li>
				Добавим условие в show_category, для того чтобы когда категоряи окажется пустой, либо её вообще не сушествует - отобразалась страница 404 - def pageNotFound
				<pre>
 len(posts) == 0:  # Если количество постов 0
    raise Http404()  # отобразится страница 404 - def pageNotFound(если DEBUG = False)
    # если DEBUG = True - нам покажет обычную страницу ошибки, с причиной ошибки</pre>
			</li>
			<li>
				Отобразим категорию и время обновления статью в indrx.html.
				<br><strong>В категории обращаемся к p.cat = Men.cat, cat обращается к записи Category, и помощью def __str__ в Category - нам и выведет название категории (Актеры, Музыканты и тд)</strong>
				<br>Дата к time_update - там всё понятно, так же сразу применили фильтр отображения день-месяц-Год Часы:минуты:секунды [18-11-2022 19:17:34]
				<br><br>
				Добавили в index.html - внутри цикла for сверзу, вразрыв до h2 тегов - добавили div
				<pre>
&lt;div class="article-panel">
    &lt;p class="first">
        Категория: {{ p.cat }}
    &lt;/p>
    &lt;p class="last">
        Дата обнавления: {{ p.time_update|date:'d-m-Y H:i:s' }}
    &lt;/p>
&lt;/div></pre>
			</li>


			<br><br>
			<h4 class="title_text border">[10].  Начинаем работу с админ-панелью.</h4>
			<li>
				Русский язык в админ панели. В настройках settings.py:
				<pre>
LANGUAGE_CODE = 'ru-Ru'
     либо просто
LANGUAGE_CODE = 'ru'</pre>
				Стнандартная админ панель в django - достаточно мощный инструмент, и для большинства проектов её достаточно - по-этому создавать свою в большинстве случаев нет необходимости.
			</li>
			<li>
				Создаём суперпользователя (админа). В терминале:
				<pre>
python manage.py createsuperuser  # создаём суперюзера

Имя пользователя: Mello
Адрес электронной почты: elproject220@yandex.ru
Password:blog1234
Password (again):blog1234
Superuser created successfully.  # пользователь создан</pre>
				Теперь можно залогинится в админпанели
			</li>
			<li>
				Регистрируем приложение в admin. Для этого в men/admin.py:
				<pre>
from .models import *  # импортируем все классы men/models.py

admin.site.register(Men)  # регистрируем в админке - модель Men</pre>
			</li>
			<li>
				<span class="spec">get_absolute_url</span>
				<br>Благодоря данным функциям внутри классов, которые мы прописывали, в админ панели, при просмотре информации есть кнопка - смотреть на сайте
			</li>
			<li>
				Пишем в модели дополнительный класс, для корректного отображения, в админпанеле.
				<span class="spec">Специальный класс - class Meta:</span>
				<br>Нужен для отображения моделей (имя, имя во множественном числе и тд)
				<br><br>В men/models.py - внутри класса Men - добавляем вложенный class Meta:
				<pre>
    class Meta:  # специальный класс - для отображения модели
        verbose_name = 'Популярные личности'  # отображение в админке вместо 'Mens'
    	verbose_name_plural = 'Популярные личности'  # отображение во множественном числе</pre>
			</li>
			<li>
				Сортировка внутри классов. Там же внутри класса Meta:
				<pre>
ordering = ['time_create', 'title']  # сортировка, сначала по дате создания, потом по имени

ordering = ['-time_create', 'title']  # обратная сортировка</pre>
				Сортировка происходит как в амин панели, так и на отображении сайта
			</li>
			<li>
				Изменяем отображение названия приложения! MEN - 'Мировые звёзды'
				<br>Для этого в men/apps.py - внутри class MenConfig(AppConfig)  - добавляем переменную verbose_name
				<pre>
class MenConfig(AppConfig):
    ...
    ...
    verbose_name = 'Мировые звёзды'  # отображение названия приложения</pre>
    			Этот атрибут сработает только в том случае, если мы прописали полностью наше приложение В settings.py - В INSTALLED_APPS - полностью прописали приложение как: 'men.apps.MenConfig'
			</li>
			<li>
				В админ панели, в списке полей отобразис не тлько заголовок статьи
				<br>Для этого в men/admin.py - сверху (после всех импортов) - пропишем новый класс алмин модели, и обязательно его зарегистрируем:
				<pre>
class MenAdmin(admin.ModelAdmin):
    # список отображаемых столбцов в админ-панели
    list_display = ('id', 'title', 'time_create', 'photo', 'is_publisher')
    # список полей на которые можно кликнуть - для редактирования
    list_display_links = ('id', 'title')
    # список полей - ко которым можно вести поиск
    search_fields = ('title', 'content')


# Register your models here.
# регистрируем в админке - модель Men
# регистрируем класс отображения в админке - MenAdmin
admin.site.register(Men, MenAdmin)</pre>
			</li>
			<li>
				Меняем отображение полей в админке - на понятный нам язык.
				<br>Для этого в models.py - внутри класса - для каждого поля добавляем параметр verbose_name='отображаемое имя':
				<pre>
title = models.CharField(max_length=255, verbose_name='Заголовок')
content = models.TextField(blank=True, verbose_name='Текст статьи')
photo = models.ImageField(upload_to='photos/%Y/%m/%d', verbose_name='Фото')
# дата время - создание, auto_now_add=True - создастся единожды
time_create = models.DateTimeField(auto_now_add=True, verbose_name='Время создания')
# дата время - изменение, auto_now=True - будет меняться с каждым изменением
time_update = models.DateTimeField(auto_now=True, verbose_name='Время изменения')
is_publisher = models.BooleanField(default=True, verbose_name='Публикация')
cat = models.ForeignKey('Category', on_delete=models.PROTECT, null=True, verbose_name='Категории')</pre> 

			</li>
			<li>
				Регистристрируем в админ-панели модель в Категории, сразу настраиваем какие поля будем отображать.
				<br>В men/admin.py
				<pre>
# отображение полей в админке
class CategoryAdmin(admin.ModelAdmin):
    list_display = ('id', 'name')
    list_display_links = ('id', 'name')
    search_fields = ('name',)  # ЗАПЯТАЯ В КОНЦЕ- при одном поле

# регистрация модели категории и отображение полей в админке для этой модели
# admin.site.register(Category, CategoryAdmin)</pre>
			</li>
			<li>
				Меняем параметры отображения полей и самой модели в админ панеле.
				<br>В men/models.py в  - модели Категории прописываем специальный class Meta: и для каджого поля добавляем параметр verbose_name='отображаемое имя':
				<pre>
class Meta:  # специальный класс - для отображения модели
    verbose_name = 'Категория'  # отображение в админке вместо 'Сategory'
    verbose_name_plural = 'Сategorys'  # отображение во множественном числе
    ordering = ['id']  # сортировка, сначала по id

# отображение поля категория в таблице(админ панели)
name = models.CharField(max_length=100, db_index=True, verbose_name='Категория')</pre>
			</li>
			<li>
				После всех работ с моделями  - создаём новый файл миграций - makemigrations
				<br>Сохраняем все файлы, останавливаем сервер, в корневом каталоге - в терминале
				<pre>
python manage.py makemigrations</pre>
			</li>
			<li>
				Применяем миграцию, записываем все изменения в моделях:
				<pre>
python manage.py migrate</pre>
			</li>
			<li>
				Попробуем добавить новую запись через админ панель, Добавляем фотографию (с любой папки на нашем пк) - сохраняем.
				<br>django автоматически создал папку в coolsite/media/photo/2022/11/21
				<br>-где media - это settings.py - MEDIA_ROOT = BASE_DIR / 'media'
				<br>-где photo/2022/11/21 - Год/месяц/число - в models.py - class Men - поле photo - (upload_to='photos/%Y/%m/%d'
			</li>
			<li>
				Добавляем отображение вотографий в шаблон - в index.html - после diva (Категория, дата) Добавляем конструкцию if -  если фото в записи модели загружено - отображаем -фото
				<br><span class="spec">{{ запись из модели.поле в модели.url }}</span>
				<br>index.html:
				<pre>
# Отобрадение фото, если в записи фото загружено:
# posts = Men.objects.all()
# p = одна запись из posts 
{% if p.photo %}
    &lt;p>
        &lt;img class="img-article-left thumb" src="{{ p.photo.url }}">
    &lt;/p>
{% endif %}</pre>
			</li>
			<li>
				Сделаем поле Публикации (is_publ..) редактируемым, то есть в админ-панели можно будет публиковати или убирать публицакию с сайта (просто галочкой)
				<br>
				Для этого в men/admin.py - в class MenAdmin - добавим переменную list_editable
				<pre>
# редактирование поля публикации - в списке - в админке
list_editable = ('is_publisher',)  # запятая - если 1 поле!</pre>
			</li>
			<li>
				Добавим поля по которым сможем фильтровать наш список полей:
				<br>Для этого в men/admin.py - в class MenAdmin - добавим переменную list_filter
				<pre>
# фильтрование по полям - публикация, время изменения.
list_filter = ('is_publisher', 'time_create')</pre>
			</li>

			<br><br>
			<h4 class="title_text border">[11].  Пользовательские теги шаблонов.</h4>
			<li>
				Пользовательские теги - для избежания дублирования
				<br>Например у нас в данный момент есть практически две одинаковые функции def index /show_category.
			</li>
			<li>
				Виды тегов в django:
				<br>-simple tags - простые теги
				<br>-inclusion tags - включающие теги
			</li>
			<li>
				Сошласно документации django - теги необходимо собирать в одном месте. Создадим подкаталог в папке men - templatetags. <br>Этот подкаталог должен быть пакетом - для этого в templatetags - необходимо создать py - файл  -  __init__
			</li>
			<li>
				В men/templatetags - создадим ещё один файл, в котором будем прописывать логигу работы нового тега - men_tags.py
			</li>
			<li>
				В men/templatetags/men_tags.py импортируем модуль template и все наши модели
				<pre>
from django import template  # модуль template djando
from men.models import *  # все наши модели</pre>
			</li>
			<li>
				Создаём экземпляр класа Library()  - через который происходит регистрация собственных шаблонных тегов.
				<br>В men/templatetags/men_tags.py:
				<pre>
register = template.Library()					
				</pre>
			</li>
			<li>
				Описываем функцию для работы нашего простого тега
				<br>В men/templatetags/men_tags.py:
				<pre>
# функция будет возвращать все наши категории
def get_categories():  # создаём функцию - имя придумываем сами
    # вернуть все объекты модели Категории(то есть все записи категории)
    return Category.objects.all()</pre>
			</li>
			<li>
				Связываем нашу функцию с тегом - тоесть превращаем её в тег
				<br>Там же, прям над функцией пишем:
				<pre>
@register.simple_tag()  # превращаем ф в тег. simple_tag(простой тег) из класса Library
def get_categories():  # создаём функцию - имя придумываем сами
    # вернуть все объекты модели Категории(то есть все записи категории)
    return Category.objects.all()</pre>
			</li>
			<li>
				Используем наш тег, в шаблоне нашего приложения
				<br>Для этого в base.html под load static - загружаем наш файл men_tags.py
				<pre>
{% load men_tags %}</pre>
				Теперь мы можем использовать наш простой тег в базовом шаблоне base.html
			</li>
			<li>
				Вызываем наш тег в base.html. В sidebar - добавляем строчку (наша функция-тег)
				<pre>
{% get_categories %}</pre>
				Сохраняем - запускаем сервер, на главной странице в sidebar видим:
				<pre>
&lt;QuerySet [&lt;Category: Актёры>, &lt;Category: Музыканты>]></pre>
				то есть отобразились все категории
			</li>
			<li>
				Записываем содержимое тега в переменной. Формируем ссылку для содержимого нашего тега.
				<br>Добавляем код. (as - ключевое слово тега / categories - это как раз переменная)
				<pre>
# это наш тег, содержимое которого в переменной categories
{% get_categories as categories %}</pre>
			</li>
			<li>
				Теперь в цикле for модем работать с нашей пересенной
				<br>Меняем цикл
				<pre>
{% for c in cats %}  -->  {% for c in categories %}</pre>
				<br><strong>
					То есть что бы сделали:
					<br>-Вместо cats = Category.objects.all() - которую мы прописывали в views.py в def index и def show_category
					<br>-Мы используем наш тег get_categories - переменную categories
					<br>-cats = Category.objects.all() == categories из get_categories
					<br>-Это сделано для того чтобы не писать несколько раз одно и тоже в разных функциях предвставления, а просто сослатся на наш тег.
				</strong>
			</li>
			<li>
				В функции index и show_category мы теперь можем убрать:
				<pre>
cats = Category.objects.all() # убираем
context = {
	'cats': cats,  # убираем параметр представления
}</pre>
				В base.html - проверми все циклы, что мы перебираем именно categories а не cats - так как cats -мы теперь удалилил
			</li>
			<li>
				Мы можем обрашатся к тегам не по названию функции тега, а присмоить имя тегу
				<br>В men_tags.py в simple_tag - доабвляем параметр neme:
				<pre>
@register.simple_tag(name='getcats')</pre>
				<br>После этого обящательно внутри шаблона обращатся именно по имени getcats - вместо названия функции get_categories.
				<br>в base.html - изменяем
			</li>
			<li>
				Далее сделаем второй тип тегов - включающий тег. Он позволяет формировать свой собственный шаблон на основе некоторых данных и возвращать уже фрагмент html страницы.
			</li>
			<li>
				Сформируем весь список sidebar - с помощтю включающего тега. В men/templatetegs/men_tags.py - создаём и регистрируем включающий тег - show_categories()
				<pre>
# тег будет возвращать весь список категорий в sidebar в виде html отрывка
#
# 3 имя шаблона, куда будет передаваться параметр cats
# list_categories.html - необходимо создать в templates/men
@register.inclusion_tag('men/list_categories.html')
def show_categories():  # 4 будет возвращать полноценную html страницу list_categories.html
    cats = Category.objects.all()  # 1 читает все категории
    return {'cats': cats}  # 2 возвращает словарь</pre>
			</li>
			<li>
				Создаём html файл в men/templates/men - list_categories.html
				<br>Копируем в него всю строчки кода списка категорий внутри sidebar - из base.html, только вместо categories - будем брать параметр cats - который прописывали в теге show_categories - весь цикл for, без ссылки и надписи все категории
				<br>list_categories.html - получился такой:
				<pre>
# далее цикл: перебираем записи c в модели cats 
# cats = Category.objects.all() - def show_categories() - в men_tags 
# проверка если ключ pk == выбранной категории cat_selected
# будет показывать как простую  строку (выделенную как выбраная)
# если не совпадают будут показывать как ссылку 
{% for c in cats %}
    {% if c.pk == cat_selected %} 
        &lt;li class="selected">{{ c.name }}&lt;/li>
    {% else %}
        &lt;li>&lt;a href="{{ c.get_absolute_url }}">{{ c.name }}&lt;/a>&lt;/li>
    {% endif %}
{% endfor %}</pre>
			</li>
			<li>
				В base.html - можно убрать польностью фрагмент цикла for - и вместо него просто прописываем наш тег - show_categories. А тот что прописывали ранее {% getcats as categories %} - убрать так как мы на него больше не ссылаемся
				<pre>
{% getcats as categories %}  # убираем

# это наш тег вложенный, будет сслыатся на шаблон show_categories
{% show_categories %}  # берём из тега	show_categories, которрый ссылается на show_categories.html</pre>
				Всё работает, но ссылки - Актёры - Музыканты, не выделяются при выюранной категории, потому что мы не пережавали параметры.
			</li>
			<li>
				Передаём параметры нашему тегу. 
				<br>В men_tags.py - в теге get_categories - передадим параметр filter, и прописываем проверку if
				<pre>
# функция будет возвращать все наши категории
@register.simple_tag(name='getcats')  # Превращаем ф в тег. simple_tag - простой тег, из класса Library
def get_categories(filter=None):  # стандартно фильтр не выбран
    if not filter:  # если фильтр не выбран
        return Category.objects.all()  # вернуть все записи категории
    else:  # иначе
        return Category.objects.filter(pk=filter)  # вернуть запись по фильтру id</pre>
			</li>
			<li>
				Передаём параметр filter в base.html, после td - sidebar - добавляем - {% getcats %} - смотрим на главной странице, если появилась запись:
				<pre>
&lt;QuerySet [&lt;Category: Актёры>, &lt;Category: Музыканты>]></pre>
				<br>Значит всё работает
				<br><br>Передаём непосредственно сам параметр фильтр в base.html:
				<pre>
{% getcats filter=1 %}  --> &lt;QuerySet [&lt;Category: Актёры>]>
то же самое
{% getcats  %}  --> &lt;QuerySet [&lt;Category: Музыканты>]></pre>
			</li>
			<li>
				Сделаем 2 новых параметра нашему включаюзему тегу - show_categories - сортировка и cat_selected. В men_tags.py - def show_categories - добавим их:
				<pre>
def show_categories(sort=None, cat_selected = 0):</pre>
				<br>Добавляем конструкцию if, полный тег будет:
				<pre>
# тег будет возвращать весь список категорий в sidebar в виде html отрывка
#
# 3 имя шаблона, куда будет передаваться параметр cats
# list_categories.html - необходимо создать в templates/men
@register.inclusion_tag('men/list_categories.html')
def show_categories(sort=None, cat_selected = 0):  # 4 будет возвращать полноценную html страницу list_categories.html
    if not sort:  # если сортировка не определена
        cats = Category.objects.all()  # 1 читает все категории
    else:  # если сортировка определена
        cats = Category.objects.order_by(sort)  # делаем сортировку которую указали
    return {'cats': cats, 'cat_selected': cat_selected}  # 2.Возвращает 2 параметра Категории, и cat_selected</pre>
			</li>
			<li>
				В base.html - убираем {% getcats 2 %}
				<br>Изменяем вложенный тег show_categories добавляя пораметры
				<pre>
{% show_categories %}  -->  {% show_categories '-name' cat_selected %}
#сортировка по имени с конца если стоит -
# cat_selected уже определён в шаблоне base.html - его мы прописывали в views.py - в index html - будет равен 0, а в showpost = id категории</pre>
				<br>Если сорировка не нужна необходимо указать один параметр cat_selected
				<pre>
{% show_categories cat_selected=cat_selected %}</pre>
			</li>

			<li>
				<span class="spec">Сделал тег для отображения меню в навбр:</span>
				<ol type="A">
					<li>
						В templates - создал пустой шаблон list_menu. В него скопировал всю информацию из base.html  - по навбару - block mainmenu
						<br>list_menu.html:
						<pre>
# Навбар -->
{% block mainmenu %}
    &lt;div class="header">
        &lt;ul  id="mainmenu" class="mainmenu">
            # Это лого внутри навбар -->
            &lt;li class="logo">&lt;a href="{% url 'home' %}">&lt;div class="logo">&lt;/div>&lt;/a>&lt;/li>
           # перебираем все в списке меню (men/views.py) -->
            {% for m in menu %}

                # если не последний -->
                {% if not forloop.last %}
                &lt;li>&lt;a href="{% url m.url_name %}">{{m.title}}&lt;/a>&lt;/li>
                {% else %}
                &lt;li class="last">&lt;a href="{% url m.url_name %}">{{m.title}}&lt;/a>&lt;/li>
                {% endif %}                                
            
            {% endfor %}
        &lt;/ul>
    &lt;/div> # &lt;div class="header"> -->
# Конец Навбар -->
{% endblock mainmenu %}</pre>
					</li>
					<li>
						В men_tags.py прописал и зарегестрировал вложенный тег - show_menu
						<pre>
@register.inclusion_tag('men/list_menu.html')
def show_menu():  # 4 будет возвращать полноценную html страницу list_menu.html
    menu = [{'title': 'О сайте', 'url_name': 'about'},
            {'title': 'Добавить статью', 'url_name': 'add_page'},
            {'title': 'Обратная связь', 'url_name': 'contact'},
            {'title': 'Войти', 'url_name': 'login'},
            ]
    return {'menu': menu}  # # navbar - title, url_name</pre>
					</li>
					<li>
						В men vievs.py - удалил:
						<br>-список словарей menu
						<br>-из функции index - убрал menu - в качестве передаваемого параметра
						<br>-из функции about - убрал menu - в качестве передаваемого параметра
						<br>-из функции show_category - убрал menu - в качестве передаваемого параметра
					</li>
					<li>
						В base.html - за место всего кода по менб добавил 1 строчку  - наш тег show_menu:
						<pre>
# меню навбара вложенный тег -->
{% show_menu %}</pre>
					</li>
					<li>
						Проверил в браузере - всё работает как и раньше.
					</li>
				</ol>
			</li>



			<br><br>
			<h4 class="title_text border">[12].  Добавляем слаги (slug) к URL-адресам.</h4>
			<li>
				slug - это уникальный фрагмент url-адреса, принадлежащей конкретной записи
				<br>Состоит из латинских символов, дефисов и подчёркиваний.
				<br>По слагу страницы лучше ранжируется в поиске и более понятны пользователю - по этому вместо id лучше использовать слаги - за исключением некоторых случаев
			</li>
			<li>
				Переходим в men/views.py - и изменяем функцию show_post - на данный момент она как функция заглушки, перед эти импортировав - get_object_or_404
				<pre>
def show_post(request, post_id):  # обязательно добавь доп параметр post_id
    # если id есть то есть есть запись в модели Men, то покажет страницу если нет nj 404
    post  = get_object_or_404(Men, pk=post_id)
    context = {
        'post': post,  # все записи модели Men - title, content, photo...
        'title': post.title,  # название страницы = название поста
        'cat_selected': post.cat_id,  # cat_id - в модели, поле cat (id автоматом делает django)
    }
    return render(request, 'men/post.html', context=context)</pre>
			</li>
			<li>
				В men/templates - создаём новый шаблон - post.html
				<br>-расширяемся от base.html
				<br>-блок контент
				<br>-внутри блок контента - название статьи, изображение, сам контент с фильтром
				<pre>
{% extends 'men/base.html' %}

{% block content %}
<h1>{{ post.title }}</h1>

{% if post.photo %}
&lt;p>
	&lt;img  class='img-article-left' src="{{ post.photo.url }}">
&lt;/p>
{% endif %}

{{ post.content|linebreaks }}

{% endblock %}</pre>
				Проверяем всё должно работать, но url у нас сейчас по id записи
			</li>
			<li>
				Добавляем полу slug - в моделе Men. men/models.py
				<pre>
    # unique=True - поле уникально, db_index=True - индексируемое (для ускорения поиска, verbose_name - отображение в адм.
    slug = models.SlugField(max_length=255,unique=True, db_index=True, verbose_name='URL')</pre>
			</li>
			<li>
				Так как поле слаг обязательно, а записи у нас уже есть, необходимо что то сделать, мало того поле слаг должно быть уникальным для каждой запси
			</li>
			<li>
				Будем удалять все файлы миграции - из папки migrations
			</li>
			<li>
				Сразу же изменим структуры таблиц, чтобы больше не возврашатся к этому, это будет конечный вариант структуры таблиц
				<br>-уберём null=True  - из поля cat в модели Men
				<pre>
cat = models.ForeignKey('Category', on_delete=models.PROTECT, null=True, verbose_name='Категории')</pre>
				<br>Добавим поле slug в модель Category
				<pre>
slug = models.SlugField(max_length=100, unique=True, verbose_name='URL')</pre>
			</li>
			<li>
				Из migrations удалили все файлы миграций, создаём новый файл миграций - makemigrations
				<pre>
python manage.py makemigrations</pre>
				применяем миграцию - migrate
				<br><strong>Опять будет ошибка - по этому ненужно менять структуру таблиц во время работы, планирую структуру моделей заранее, обойти это можно, но не желательно</strong>
			</li>
			<li>
				<span class="spec">Очишаем Базу данных, щаново делаем миграции
					<br>Удалятся все данные из базы данных включая сепурюзера
				</span>
				<ol type="A">
					<li>
						Удаляем все файлы миграции вручную из подкаталога  - men/migrations - dhexye.
					</li>
					<li>
						Заодно удилил папку 2022 - из папки media - всёравно будут создаватся заново
					</li>
					<li>
						ВРУЧНУЮ в pgAdmin 4 - PostgreSQL - удалил все таблицы из базы данных coolsitedb, если не удаляются , удаляй КАСКАДНО.
					</li>
					<li>
						Сохраняем все файлы проекта, создаём файл миграций, и применяем миграции
						<br>makemigrations - migrate
						<pre>
python manage.py makemigrations  # создали							
python manage.py migrate  # применили</pre>
					</li>
					<li>
						заново создавай суперюзера
						<pre>
python manage.py createsuperuser

Имя пользователя: Mello
Адрес электронной почты: elproject220@yandex.ru
Password:blog1234
Password (again):blog1234
Superuser created successfully.  # пользователь создан</pre>
					</li>
				</ol>
			</li>
			<li>
				Автоматизуруем написание слага в админ панеле (при создании записи) - для модели категории
				<br>Для этого переходим в men/admin.py, в class CategoryAdmin, добавляем атрибут prepopulated_fields:
				<pre>
 prepopulated_fields = {{ 'slug': ('name',) }}  # автозаполнение слага по имени категории</pre>
 				Пробуем создавать новую категорию  - и видем что всё работает, url(slug) - заполняется автоматически на основе Имени категории!
			</li>
			<li>
				Автоматизуруем написание слага в админ панеле (при создании записи) - для модели Men (Популярные личности)
				<br>Для этого переходим в men/admin.py, в class MenAdmin, добавляем атрибут prepopulated_fields:
				<pre>
 prepopulated_fields = {'slug': ('title',)}  # автозаполнение слага по имени поста</pre>
			</li>
			<li>
				Далее заполню информацию через админ панель по Актёрам и Музыкантам (добавляю записи в модели Men)
				<br>Всё проверяем, всё работает - но наш путь до сих пор по id - http://127.0.0.1:8000/post/1/
			</li>
			<li>
				Делаем отображение по slug - посты - модель Men:
				<ol type="A">
					<li>
						В men urls.py меняем путь для постов
						<pre>
path('post/&lt;int:post_id>/', show_post, name='post'),

на

path('post/&lt;slug:post_slug>/', show_post, name='post'),</pre>
					</li>
					<li>
						В функции представления - men/vievs.py - def show_post - меняем переменную post_id на post_slug. pk на slug
						<pre>
def show_post(request, post_slug):
	post  = get_object_or_404(Men, slug=post_slug)
	.....
	return.....</pre>
					</li>
					<li>
						В models.py - в Men - def get_absolute_url - post_id меняем на post_slug, pk на slug
						<br><strong>Параметры post_id/post_slug  - это как раз те параметры что указывем в path</strong>
						<pre>
class Men (models.Model):
	....
	....

	def get_absolute_url(self):  # self - ссылка на один экземпляр(строку) таблицы модели
	    return reverse('post', kwargs={'post_slug': self.slug})  # self.slug - атрибут slug</pre>
					</li>
					<li>Проверяем теперь всё работает как и задвмывали, путь отображается по слагу
						<br>http://127.0.0.1:8000/post/vyacheslav-butusov/
					</li>
				</ol>
			</li>

			<li>
				Делаем отображение по slug - категории - модель Category:
				<ol type="A">
					<li>
						urls.py - path category
						<pre>
path('category/&lt;slug:cat_slug>/', show_category, name='category'),</pre>
					</li>
					<li>
						views.py - show_category
						<pre><span class="spec">
def show_category(request, cat_slug):  # обязательно доп параметр cat_slug
    posts = Men.objects.filter(cat__slug=cat_slug)  # cat   '__'   slug!!! cat__slug=cat_slug
....
# для получения cat_selected ------------------------------------
cat_one_record = Category.objects.get(slug=cat_slug)  # получили 1 полную запись Category
cat_selected = cat_one_record.pk  # получили id или pk этой записи!
# для получения cat_selected ------------------------------------
....</span></pre>
						show_category полностью:
						<pre>
def show_category(request, cat_slug):  # обязательно доп параметр cat_slug
    posts = Men.objects.filter(cat__slug=cat_slug)  # cat   '__'   slug!!! cat__slug=cat_slug

    # для получения cat_selected ------------------------------------
    cat_one_record = Category.objects.get(slug=cat_slug)  # получили 1 полную запись Category
    cat_selected = cat_one_record.pk  # получили id или pk этой записи!
    # для получения cat_selected ------------------------------------

    if len(posts) == 0:  # Если количество постов 0
        raise Http404()  # отобразится страница 404 - def pageNotFound(если DEBUG = False)
        # если DEBUG = True - нам покажет обычную страницу ошибки, с причиной ошибки

    # context - словарь передаваемых параметров
    context = {
        'posts': posts,  # cat_id - к какой категории принадлежит запись в таблице Men
        'title': 'Отображение по рубрикам',  # название страницы
        'cat_selected': cat_selected,  # cat_selected - принимает значение cat_slug записи Men
    }
    # Шаблон домашней страницы, несмотря на то что это категории
    return render(request, 'men/index.html', context=context)</pre>
					</li>
					<li>
						models.py - class Category - def get_absolute_url
						<pre>
# функция формирования маршрута к ссылке
def get_absolute_url(self):
    return reverse('category', kwargs={'cat_slug': self.slug})</pre>
					</li>
					<li>
						Проверяем, всё работает, особове внимание cat_selected.
						<br>Пути пример - http://127.0.0.1:8000/category/muzykanty/
					</li>
				</ol>



			<br><br>
			<h4 class="title_text border">[13]. Использование форм, не связанных с моделями.</h4>
			<li>
				Форма - например форма для авторизации
				<br>Форма в html в тегах &lt;form>..&lt;/form>
				<br>Форма связанная с моделью  - авторизация и тп
				<br>Форма не связанная с моделью  - отправка письма и тп
			</li>
			<li>
				Будем добавлять форму по ссылке навбара - Добавить страницу
				<br>В men/vievf.py - правим функцию представления страницы add_page - сейчас она стоит заглушкой
				<pre>
def addpage(request):
    return render(request, 'men/addpage.html', {'title': 'О сайте'})</pre>
			</li>
			<li>
				в men/templates/men - создаём шаблон addpage.html, расширяемся от base.html - добавляем индивидуальный блок контент
				<pre>
{% extends 'men/base.html' %}  # наследуемся от base.html

{% block content %}  # начало собственного контента
&lt;h&lt;1>{{ title }}&lt;/h1>
&lt;p>это будет форма добавления статьи&lt;/p>
{% endblock %}  # конец собственного контента</pre>
			</li>
			<li>
				Необходимо будет создавать специальный класс django - формы.
				<br>Для этого в men(app) - создаём новый файл forms.py
			</li>
			<li>
				В forms.py импортируем из джанго модуль forms и все наши модели из models.py
				<pre>
from django import forms  # модуль forms
from .models import *  # все модели models.py</pre>
			</li>
			<li>
				В forms.py - прописываем форму модели
				<pre>
# Форма загрузки статьи
# аттрибуты(поля) совпадают с полями в Men
class AddPostForm(forms.Form):
    title = forms.CharField(max_length=255)
    slug = forms.SlugField(max_length=255)
    content = forms.CharField(widget=forms.Textarea(attrs={'cools': 60, 'rows': 10}))
    is_published = forms.BooleanField()
    cat = forms.ModelChoiceField(queryset=Category.objects.all())
    # time_create , time_update - автоматически будут менятся в классе Men</pre>
			</li>
			<li>
				Используем форму в функции представления def addpage, перед этим импортировав наш forms.py - всё во views.py
				<pre>
from .forms import *  # из forms.py импортируем все классы форм

def addpage(request):
    form = AddPostForm()  # создаём экземпляр класса AddPostForm
    # передаём в form - в качестве передоваемого параметра в шаблон addpage.html
    return render(request, 'men/addpage.html', {'form': form, 'title': 'Добавление статьи'})</pre>
			</li>
			<li>
				Отображаем форму непосредственно в шаблоне addpage.html
				<pre>
# url_page = path(..name='url_page') 
# post-передача данных/логин пароль/изображений и тд
&lt;form action="{%  url 'add_page' %}" method="post">
	# csrf_token - для защиты от csrf атак-->
	# form.as_p - функция as_p() - отображает все поля формы
	{% csrf_token %}
	{{ form.as_p }}
	&lt;button type="submit">  # кнопка отправить
		Добавить
	&lt;/button>
&lt;/form></pre>
				Можно проверять в браузере - форма уже отобразилась
			</li>
			<li>
				В men/views.py - имзеняем функцию представления страницы add_page
				<br>При первом запуске форма будет пустой
				<br>После того как уже попробывали отправить (но заполнили неправильно, записи в полях будуи сохранятся
				<br>Для этого и делаем конструкцию if в функции def addpage:
				<pre>
def addpage(request):
    # 2) если уже была какая-то отправка
    if request.method == 'POST':  # если уже что то пытались отправить
        form = AddPostForm(request.POST)  # ?создаём экземпляр класса AddPostForm
        if form.is_valid():  # если заполнено правильно
            # принт это временно, чтобы понять что отобразится (в терминале)
            print(form.cleaned_data)
    # 1) при первом открывании формы
    else:
        form = AddPostForm()  # пустая форма
    return render(request, 'men/addpage.html', {'form': form, 'title': 'Добавление статьи'})</pre>
    			<br>Проверяем в браузере, заполняем -нажимаем добавить:
    			<br>В терминале print(form.cleaned_data):
    			<pre>
{'title': 'Арнольд Швартснеггер', 'slug': 'arny', 'content': 'Качок из LA', 'is_published': True, 'cat': &lt;Category: Актёры>}</pre>
				<br>Попробуем допустить ошибки - например slug русскими буквами
				<pre>
В браузере:
  -Значение должно состоять только из латинских букв, цифр, знаков подчеркивания или дефиса.</pre>
			</li>
			<li>
				Приводим вид форму в порядок, для начала название полей формы сделаем на нашем языке, для этого в forms.py - в наш class AddPostForm - в каждом поле добавим параметр label='Имя отображаемого поля в браузере'
				<pre>
# Форма загрузки статьи
# аттрибуты(поля) совпадают с полями в Men
class AddPostForm(forms.Form):
    title = forms.CharField(max_length=255, label='Заголовок')
    slug = forms.SlugField(max_length=255, label='URL')
    content = forms.CharField(widget=forms.Textarea(attrs={'cools': 60, 'rows': 10}), label='Текст статьи')
    is_published = forms.BooleanField(label='Публикация')
    cat = forms.ModelChoiceField(queryset=Category.objects.all(), label='Категория')
    # time_create , time_update - автоматически будут менятся в классе Men</pre>
    			Обновняем браузер - проверяем
			</li>
			<li>
				Сделаем поле - is_published - необязательным
				<br>forms.py - class AddPostForm
				<pre>
is_published = forms.BooleanField(label='Публикация', required=False)  # required=False необязательное поле</pre>
				<br>Поле cat - вместо ---- будет отображать категория не выбрана
				<pre>
cat = forms.ModelChoiceField(queryset=Category.objects.all(), label='Категория', empty_label='Категория не выбрана')</pre>
				<br>Опять поле is_published - сделаем так что в поле изначально будет галочка
				<pre>
# required=False необязательное поле, initial=True изначально галочка стоит
    is_published = forms.BooleanField(label='Публикация', required=False, initial=True)</pre>
			</li>
			<li>
				Улучшаем внешний вид - непосредственно в шаблоне - addpage.html
				<pre>
{{ form.as_p }} 

заменяем на

&lt;p>
	# for= - уникальный идентификатор, для title при помощи св-ва (id_for_label - встр в django)
	&lt;label class="form-label" for="{{ form.title.id_for_label }}">
		# отображаем 'заголовок' поля
		{{ form.title.label }}:
	&lt;/label>
	# отображаем поле для ввода заголовка
	{{ form.title }}
&lt;/p>

&lt;div class="form-error">
	# возможные ошибки при вводе заголовка (встр в django)
	{{ form.title.errors }}
&lt;/div></pre>
				В данном случае будет отображон только заголовок и кнопка добавить
			</li>
			<li>
				Добавляем в шаблон все оставшиеся поля
				<br>-slug
				<br>див еррор slug
				<br>-content
				<br>див еррор content
				<br>-is_published
				<br>див еррор is_published
				<br>-cat
				<br>див еррор cat
				<pre>
#поле slug
&lt;p>&lt;label class="form-label" for="{{ form.slug.id_for_label }}">{{ form.slug.label }}:&lt;/label>{{ form.slug }}&lt;/p>
&lt;div class="form-error">{{ form.slug.errors }}&lt;/div>
#поле content
&lt;p>&lt;label class="form-label" for="{{ form.content.id_for_label }}">{{ form.content.label }}:&lt;/label>{{ form.content }}&lt;/p>
&lt;div class="form-error">{{ form.content.errors }}&lt;/div>
#поле is_published
&lt;p>&lt;label class="form-label" for="{{ form.is_published.id_for_label }}">{{ form.is_published.label }}:&lt;/label>{{ form.is_published }}&lt;/p>
&lt;div class="form-error">{{ form.is_published.errors }}&lt;/div>
#поле cat
&lt;p>&lt;label class="form-label" for="{{ form.cat.id_for_label }}">{{ form.cat.label }}:&lt;/label>{{ form.cat }}&lt;/p>
&lt;div class="form-error">{{ form.cat.errors }}&lt;/div></pre>
			</li>
			<li>
				Предыдущий код можно сократить с помощью цикла for, буквально в 2 строчки
				<pre>
# перебираем все поля title/slug/content/is_published/cat -->
# f = form.title/form.slug/from.content .. -->
{% for f in form %}

# for= - уникальный идентификатор, для title/slug и тд при помощи св-ва (id_for_label - встр в django) -->
# отображаем 'заголовок/url/Текст статьи/Публикация/Категория' поля -->
# отображаем поле для ввода заголовка/урла/статьи/публикации/категории -->
&lt;p>&lt;label class="form-label" for="{{ f.id_for_label }}">{{ f.label }}:&lt;/label>{{ f }}&lt;/p>

# возможные ошибки при вводе заголовка (встр в django) -->
&lt;div class="form-error">{{ f.errors }}&lt;/div>

{% endfor %}</pre>
			</li>
			<li>
				Настройку каждого поля можно сделать отдельно непосредственно внутри описания поля в forms.py. То есть джанго будет автоматически вставлять в тегги html classы!
				<br>Для примера сделаем поле title - добавим параметр widget
				<pre>
title = forms.CharField(max_length=255, label='Заголовок', widget=forms.TextInput(attrs={'class': 'form-input'}))
				
то есть для поля title в html получилось так:
&lt;p>
	&lt;label>....&lt;/label>
	&lt;input type="text" name="title" class="form-input" maxlength="255" required id="id_title">
&lt;	{{ form.title }}
&lt;/p></pre>
			</li>
			<li>
				Форма готова к использованию, теперьнеобходимо записывать информацию вместо того чтобы просто отображать её в терминале
				<br>Для этого в men/views.py - def addpage(request):
				<pre>
# print(form.cleaned_data)  #комментируем строку, вместо неё:

try:  # патаемся
    Men.objects.create(**form.cleaned_data)  # добавляем запись в базу данных Men
    return redirect('home')  # если добавление прошло, то возвращает path = name='home'
except:  # исключение (если не получилось добавить
    # общая ошибка на странице формы
    # чтобы её отобразить в шаблоне необходимо добавить
    form.add_error(None, 'Ошибка добавления поста')  # общая ошибка на странице формы</pre>
			</li>
			<li>
				def addpage - полностью:
				<pre>
def addpage(request):
    # 2) если уже была какая-то отправка
    if request.method == 'POST':  # если уже что то пытались отправить
        form = AddPostForm(request.POST)  # ?создаём экземпляр класса AddPostForm
        if form.is_valid():  # если заполнено правильно
            # принт это временно, чтобы понять что отобразится (в терминале)
            # print(form.cleaned_data)
            #
            try:  # патаемся
                Men.objects.create(**form.cleaned_data)  # добавляем запись в базу данных Men
                return redirect('home')  # если добавление прошло, то возвращает path = name='home'
            except:  # исключение (если не получилось добавить
                # общая ошибка на странице формы
                # чтобы её отобразить в шаблоне необходимо добавить
                form.add_error(None, 'Ошибка добавления поста')  # общая ошибка на странице формы
    # 1) при первом открывании формы
    else:
        form = AddPostForm()  # пустая форма
    return render(request, 'men/addpage.html', {'form': form, 'title': 'Добавление статьи'})</pre>

			</li>
			<li>
				Отображение общей ошибки на странице формы. В шаблоне  addpage.html сразу после csrf - добавляем div
				<pre>
# это из vievs.py - def addpage - except - form.add_errors
&lt;div class="form-error">{{ form.non_field_errors }}&lt;/div></pre>
			</li>
			<li>
				<span class="spec">
					Назавние полей в КЛАССАХ формы и модели (AddPostForm и Men) - должны полностью совпадать, иначе при добавление записи в Бау данных будет ошибка!
				</span>
					<br>Было is_published в форме - is_publisher в модели
			</li>




			<br><br>
			<h4 class="title_text border">[14]. Формы, связанные с моделями. Пользовательские валидаторы.</h4>
			<li>
				Когда ворма связана с моделью, лучше напрямую их связать. В прошлом уроке этого не сделали, из за этого получилось дублирование кода, а так же возможные ошибки
			</li>
			<li>
				Для этого в mne/forms.py - изменяем структуру нашей формы - AddPostForm.
				<br>(forms.Form)  --> (forms.ModelForm)
				<br>Убираем все поля и добавляем класс Meta
				<pre>
# Форма загрузки статьи
class AddPostForm(forms.ModelForm):
    class Meta:
        model = Men  # связь с моделью Men
        fields = '__all__'  # отображаем все поля модели Men (кроме тек что заполняются автоматически)</pre>
			</li>
			<li>
				Но на практике , рекомендуется вместо всех полей указывать конктертыне поля
				<br> __all__ - заменяем на:
				<pre>
# Форма загрузки статьи
class AddPostForm(forms.ModelForm):
    class Meta:
        model = Men  # связь с моделью Men
        # отображаем  поля модели Men (кроме тек что заполняются автоматически)
        # вместо списка можно сделать '__all__' - но не рекомендуется
        fields = ['title', 'slug', 'content', 'is_publisher', 'cat']</pre>
			</li>
			<li>
				прописываем свои стили оформления для полей<br>
				В forms.py - class AddPostForm - дочерний класс Meta, добавляем атрибут widgets:
				<pre>
        widgets = {
            'title': forms.TextInput(attrs={'class': 'form-input'}),
            'content': forms.Textarea(attrs={'cols': 60, 'rows': 10}),
        }</pre>
			</li>
			<li>
				Для отображения 'Категория не выбрана вместо '------'<br>
				Необходимо прописать конструктор внутри класса AddPostForm:
				<pre>
# Форма загрузки статьи
class AddPostForm(forms.ModelForm):  # создаётся экземпляр формы (когда отображается пустая форма в браузере)
    def __init__(self, *args, **kwargs):  # вызывается конструктор
        super().__init__(*args, **kwargs)  # вызывается конструктор базового класса Men
        self.fields['cat'].empty_label = 'Категория не выбрана'  # для поля cat меняем свойство - emply_label


    class Meta:
        model = Men  # связь с моделью Men
        # отображаем  поля модели Men (кроме тек что заполняются автоматически)
        # вместо списка можно сделать '__all__' - но не рекомендуется
        fields = ['title', 'slug', 'content', 'is_publisher', 'cat']
        widgets = {
            'title': forms.TextInput(attrs={'class': 'form-input'}),
            'content': forms.Textarea(attrs={'cols': 60, 'rows': 10}),
        }</pre>
			</li>
			<li>
				В men/views.py - def addpage - в конструкции try - меняем одну строчку
				<br>
				<pre>
Men.objects.create(**form.cleaned_data)  -->  form.save()</pre>
				Делаем проверку, сначало вводим неверно (например сушествующий slug/URL)
				<br>Всё работает отлично
			</li>
			<li>
				<span class="spec">form.save()</span><br>
				Сам делает все проверкти и конструкцию try можно убрать!
				<pre>
form.save()  # добавляем запись в базу данных Men - заменяет всю конструкцию try-except
return redirect('home')  # если добавление прошло, то возвращает path = name='home'</pre>
				<br>Полная функция представления addpage
				<pre>
def addpage(request):
    # 2) если уже была какая-то отправка
    if request.method == 'POST':  # если уже что то пытались отправить
        form = AddPostForm(request.POST)  # ?создаём экземпляр класса AddPostForm
        if form.is_valid():  # если заполнено правильно
            # print(form.cleaned_data)  - проверка в терминале
            form.save()  # добавляем запись в базу данных Men - заменяет всю конструкцию try-except
            return redirect('home')  # если добавление прошло, то возвращает path = name='home'
    # 1) при первом открывании формы
    else:
        form = AddPostForm()  # пустая форма
    return render(request, 'men/addpage.html', {'form': form, 'title': 'Добавление статьи'})</pre>
			</li>
			<li>
				Теперь отобразим поле фото в форме - это сделать проще всего с формами связанными с моделями - как у нас сейчас
				<br>1. Для этого в forms.py - AddPostForm - fields - добавляем поле photo
				<pre>fields = ['title', 'slug', 'content', 'photo', 'is_publisher', 'cat']</pre>
				<br>2. В views.py - def addpage - form  - добавляем (.., request.FILES )
				<pre> form = AddPostForm(request.POST, request.FILES)</pre>
				<br>3. В шаблоне - addpage.html - добавляем атрибут enctype='multipart/form-data' (внутри тега form)
				<pre>
# enctype="multipart/form-data"  -  случае получение файлов из формы обязательно!
&lt;form action="{%  url 'add_page' %}" method="post" enctype="multipart/form-data"></pre>
				<br><br>Сохраняем - проверяем
			</li>
			<li>
				Валидация - дополнительная,  на уровне формы. Механизм работы:
				<img src="images\valid_form.jpg" class="img-fluid">
				<br><br>
				-Стандартные - в базовой модели
				<br>-Пользовательские - в форме
			</li>
			<li>
				Делаем валидацию для title<br>
				В forms.py - class AddPostForm - в самом низу:
				<pre>
# валидация - title
def clean_title(self):
    title = self.cleaned_data['title']  # получаем данные по заголовку
    if len(title) > 200:  # если больше 200 символов
        # генерируется исключение - выводит сообщение об ошибке
        raise ValidationError('Длина превышает 200 символов')</pre>
				<br>обязательно сделать импорт
				<pre>
from django.core.exceptions import ValidationError</pre>
				<br>Проверяем - при превышении в 200 символов браузер выдаст - Длина превышает 200 символов
			</li>




			<br><br>
			<h4 class="title_text border">[15]. Классы представлений: ListView, DetailView, CreateView.</h4>
			
			<li>
				<span class="spec">CBV - Class Based Views</span>
			</li>
			<li>
				Использование классаов представлений вместо функцияй
			</li>
			<li>
				Например наша функция index - отображает список статей - её можно представить через класс ListView. Класс ListView - созадёт список чего то
			</li>
			<li>
				По умолчанию class ListView будет искать шаблон - по маршруту
				<pre>
[имя приложения]/[имя модели]_list.html</pre>
				В таком случае наь необходимо было разместить шаблон в - templates/men/men_list.html
				<br>Но мы так сейчас не делаем
			</li>
			<li>
				В men/views.py - импортируем ListView; И создаём класс MenHome - который будет отвечать за домашнюю страницу нашего сайта:
				<pre>
from django.views.generic import ListView  # класс функции представления</pre>
				<br>создаём класс представления
				<pre>
# класс - функция представления домашней страницы
class MenHome(ListView):
    model = Men  # связываемся с моделью Men (будет отображать список статей)</pre>
			</li>
			<li>
				Редактируем path name='home' в men/urls.py
				<pre>
# MenHome - ссылаемся на класс представления as_view()-вызываем функцию представления!
    path('', MenHome.as_view(), name='home'),</pre>
    			Пробуем запустить сервер, и получаем ошибку, о том что не находит men/men_list  - это стандартный путь и имя в django - но у нас уже есть свой шаблон под именем index.html
			</li>
			<li>
				Указываем имя шаблона idex.html - в  men/views.py - class MenHome(ListView): - добавляем атрибут template_name
				<pre>
# класс - функция представления домашней страницы
class MenHome(ListView):
    model = Men  # связываемся с моделью Men (будет отображать список статей)
    template_name = 'men/index.html'</pre>
    			Сохраняю, обновляю - но сайт пустой - то есть по сути есть только sidebar и navbar, то что прописывали в base.html  - в сё потому что у нас в шаблоне идёт цикл p in posts  - который прописывали в def index [posts = Men.objects.all() ]
			</li>
			<li>
				Обращение к записям из модели в шаблоне через функцию представления
				<br><span class="spec">object_list</span>
				<br>В шаблоне Index.html меняем одну строчку
				<pre>
{% for p in posts %}
на
# object_list по сути равно Men.object.all()
{% for p in object_list %}					
				</pre>
			</li>
			<li>
				Изменяем имя object_list - на любое которое нам необходимо
				<br>men/views.py - class MenHome - добавляем ещё один атрибут - context_object_name
				<br>
				<pre>
class MenHome(ListView):
    model = Men  # связываемся с моделью Men (будет отображать список статей)
    template_name = 'men/index.html'
    # Все записи в модели Men те. object_list или Men.objects.all()
    context_object_name = 'posts'  # к object_list можно обращаться как к posts</pre>
    			В шаблоне теперь можно обращаться как к object_list, так и к posts
			</li>
			<li>
				Необходимо указать заголовок title (также предавали ранее в def index)
				class MenHome(ListView): - добавляем атрибут
				<pre>
extra_context = {'title': 'Главная страница'} # передаваемый параметр в шаблон title</pre>
				через extra_context нельзя передавать изменяемые параметры (например списки), можно передавать строки, можно передавать числа.
			</li>
			<li>
				Так как menu  я сделал через вложенный тег, в целях обучени в views.py - сделал рандомный список заголовков
				<pre>
side = [{'title': 'Все категории', 'url_name': 'home'},
        {'title': 'О сайте', 'url_name': 'about'},
        {'title': 'Добавить статью', 'url_name': 'add_page'},
        {'title': 'Домашняя страницы', 'url_name': 'home'},
        ]</pre>
			</li>
			<li>
				Чтобы передать этот список параметров в шаблон  - добавляем функцию def get_context_data - в самом низу нашего класса представления - MenHome
				<br>Полностью функция представления
				<pre>
# класс - функция представления домашней страницы
class MenHome(ListView):
    model = Men  # связываемся с моделью Men (будет отображать список статей)
    template_name = 'men/index.html'
    # Все записи в модели Men те. object_list или Men.objects.all()
    context_object_name = 'posts'  # к object_list можно обращаться как к posts
    extra_context = {'title': 'Главная страница'}  # передаваемый параметр в шаблон title

    # Передаём параметры в шаблон (функция формирует и динамический и статический контекст)
    def get_context_data(self, *, object_list=None, **kwargs):

        # берём уже существующий контекст get_context_data =  ('posts' 'title')
        # **kwargs - распаковываем словарь kwargs
        context = super().get_context_data(**kwargs)  # на жтом моменте у нас уже есть posts+title
        context['side'] = side  # добавим в словарь context - список side и даём ему имя side
        return context  # передаём все параметры в шаблон posts+title+side</pre>
			</li>
			<li>
				В шаблоне обратимся к side - Для проверки
				<pre>
&lt;div style="color: red;">
    &lt;h2>side from vies.py&lt;/h2>

    {% for s in side %}
    &lt;li>&lt;a href="{% url s.url_name %}">{{s.title}}&lt;/a>&lt;/li>
    {% endfor %}
&lt;/div></pre>
				На главной странице будет список ссылок из side - всё работает отлично - вышеуказанный код можно удалить в итоге, ровно как и side
			</li>
			<li>
				Можно немного измениить функцию представления, 
				<br>extra_context - убрав сверху
				<br>context['title'] - добавив снизу
				<pre>
# класс - функция представления домашней страницы
class MenHome(ListView):
    model = Men  # связываемся с моделью Men (будет отображать список статей)
    template_name = 'men/index.html'
    # Все записи в модели Men те. object_list или Men.objects.all()
    context_object_name = 'posts'  # к object_list можно обращаться как к posts

    # Передаём параметры в шаблон (функция формирует и динамический и статический контекст)
    def get_context_data(self, *, object_list=None, **kwargs):

        # берём уже существующий контекст get_context_data =  ('posts')
        # **kwargs - распаковываем словарь kwargs
        context = super().get_context_data(**kwargs)  # на этом моменте у нас уже есть posts
        context['side'] = side  # добавим в словарь context - список side и даём ему имя side
        context['title'] = 'Главная страница'  # добавим в словарь передаваемых параметров title
        return context  # передаём все параметры в шаблон posts+title+side</pre>
			</li>
			<li>
				Ещё не зватает вункции cat_selected (чтобы все категории подсвечивались)
				ниже внутри def get_context_data - добавляем:
				<pre>
context['cat_selected'] = 0</pre>
			</li>
			<li>
				Сейчас - на главной странице отображаются все статьи не важно стоит галочка публикации или нет - сделаем так чтобы было видно только опубликованные на сайт статьи - добавляем метод в самом низу в class MenHome
				<pre>
    def get_queryset(self):
        # возвращаем то какие записи должны быть прочитаны из модели Men
        # будут прочитаны и отображены только с галочкой
        return Men.objects.filter(is_publisher=True)</pre>
        		Проверяю что метод работает, в админке убираю галочки с пару записей и обновляю - всё работает
			</li>
			<li>
				Итоговый вариант функции представления домашней странице MenHome
				<pre>
# класс - функция представления домашней страницы
class MenHome(ListView):  # ListView - класс представление / наш дочерний класс MenHome от класса ListView / 
    model = Men  # связываемся с моделью Men (будет отображать список статей)
    template_name = 'men/index.html'
    # Все записи в модели Men те. object_list или Men.objects.all()
    context_object_name = 'posts'  # к object_list можно обращаться как к posts

    # Передаём параметры в шаблон (функция формирует и динамический и статический контекст)
    def get_context_data(self, *, object_list=None, **kwargs):

        # берём уже существующий контекст get_context_data =  ('posts')
        # **kwargs - распаковываем словарь kwargs
        context = super().get_context_data(**kwargs)  # на этом моменте у нас уже есть posts
        context['side'] = side  # добавим в словарь context - список side и даём ему имя side
        context['title'] = 'Главная страница'  # добавим в словарь передаваемых параметров title
        context['cat_selected'] = 0
        return context  # передаём все параметры в шаблон posts+title+side

    def get_queryset(self):
        # возвращаем то какие записи должны быть прочитаны из модели Men
        # будут прочитаны и отображены только с галочкой
        return Men.objects.filter(is_publisher=True)</pre>
			</li>
			<li>
				Аналогично пишем функцию представления для отображения категорий (вмессто функции  - def show_category - её можно закомментировать)
			</li>
			<li>
				Создаём функцию представления
				<br>Во views.py:
				<pre>
					# функция представления домашней страницы категорий(музыканты актёры)
# функция представления домашней страницы категорий(музыканты актёры)
class MenCategory(ListView):  # ListView - класс представление / наш дочерний класс MenCategory от класса ListView /
    model = Men  # связываемся с моделью Men (будет отображать список статей)
    template_name = 'men/index.html'
    # Все записи в модели Men те. object_list или Men.objects.all()
    context_object_name = 'posts'  # к object_list можно обращаться как к posts

    # когда будет формироваться экземпляр запроса MenCategory, то через ссылку self
    def get_queryset(self):
        # Записи по фильтру 1 - self обращаемся к словарю kwargs, берём параметр маршрута из path - cat_slug,
        # is_publisher = True - только опубликованные
        # cat__slug - через cat из Men, ссылаемся уже в Category - и обращаемся к Category -полю slug
        return Men.objects.filter(cat__slug=self.kwargs['cat_slug'], is_publisher=True)</pre>
			</li>
			<li>
				Далее необходимо скорректировать путь в men/urls.py (path name='category'):
				<br>То есть в место функции def show_category - ссылаться на функцию представления class MenCategory
				<pre>
path('category/&lt;slug:cat_slug>/', show_category, name='category'),
	меняем на
path('category/&lt;slug:cat_slug>/', MenCategory.as_view(), name='category'),</pre>
				Почти всё должно работать, но есть ньюансы
				На данный момент мы не отображаем title - не отображаем cat_selected
			</li>
			<li>
				Дополняем вышеуказанные параметры через метод внутри функции представления -  метод: get_context_data
				<pre>
    # Передаём параметры в шаблон (функция формирует и динамический и статический контекст)
    def get_context_data(self, *, object_list=None, **kwargs):
        # берём уже существующий контекст get_context_data =  ('posts')
        # **kwargs - распаковываем словарь kwargs
        context = super().get_context_data(**kwargs)  # на этом моменте у нас уже есть posts
        context['side'] = side  # добавим в словарь context - список side и даём ему имя side
        # Добавим в словарь передаваемых параметров title
        # posts - object_list или Men.objects.all() - но с фильтром по слагу категории
        # str(context['posts'][0].cat) - обращаемся к первой записи из post, по параметру cat
        # - тот в свою очередь обращается в нужную категорию, а категория отображается по своему имени
        # - из-за get absolut. В итоге - выводится просто имя категории.
        context['title'] = 'Категория - ' + str(context['posts'][0].cat)
        # context['posts'][0].cat_id - аналогично с title - только будет выводится id категории
        context['cat_selected'] = context['posts'][0].cat_id
        return context  # передаём все параметры в шаблон posts+title+side</pre>
        		Всё работает, но если мы в url сами введём несуществующий - например ..../muzykanty3/  - то будет ошибка
			</li>
			<li>
				Для исправления ошибки - нам нет необходимости даже писать понструкцию if - для отображения 404, достаточно в функции представления добавить один  атрибут - allow_empty = False
			</li>
			<li>
				Полная функция представления категории
				<pre>
# функция представления домашней страницы категорий(музыканты актёры)
class MenCategory(ListView):  # ListView - класс представление / наш дочерний класс MenCategory от класса ListView /
    model = Men  # связываемся с моделью Men (будет отображать список статей)
    template_name = 'men/index.html'
    # Все записи в модели Men те. object_list или Men.objects.all()
    context_object_name = 'posts'  # к object_list можно обращаться как к posts
    allow_empty = False

    # когда будет формироваться экземпляр запроса MenCategory, то через ссылку self
    def get_queryset(self):
        # Записи по фильтру 1 - self обращаемся к словарю kwargs, берём параметр маршрута из path - cat_slug,
        # is_publisher = True - только опубликованные
        # cat__slug - через cat из Men, ссылаемся уже в Category - и обращаемся к Category -полю slug
        return Men.objects.filter(cat__slug=self.kwargs['cat_slug'], is_publisher=True)

    # Передаём параметры в шаблон (функция формирует и динамический и статический контекст)
    def get_context_data(self, *, object_list=None, **kwargs):
        # берём уже существующий контекст get_context_data =  ('posts')
        # **kwargs - распаковываем словарь kwargs
        context = super().get_context_data(**kwargs)  # на этом моменте у нас уже есть posts
        context['side'] = side  # добавим в словарь context - список side и даём ему имя side
        # Добавим в словарь передаваемых параметров title
        # posts - object_list или Men.objects.all() - но с фильтром по слагу категории
        # str(context['posts'][0].cat) - обращаемся к первой записи из post, по параметру cat
        # - тот в свою очередь обращается в нужную категорию, а категория отображается по своему имени
        # - из-за get absolut. В итоге - выводится просто имя категории.
        context['title'] = 'Категория - ' + str(context['posts'][0].cat)
        # context['posts'][0].cat_id - аналогично с title - только будет выводится id категории
        context['cat_selected'] = context['posts'][0].cat_id
        return context  # передаём все параметры в шаблон posts+title+side</pre>
			</li>
			<li>
				<span class="spec">DetailView</span>
				Его можно использовать например для отображения какого-нибудь поста.
				<br>Для начала импортируем DetailView внутри views.py
				<pre>
from django.views.generic import ListView, DetailView  # функции представления</pre>
			</li>
			<li>
				Комментируем  def show_post и создаём класс представления DetailView - class ShowPost. Всё во views.py
				<pre>
class ShowPost(DetailView):  # создаём класс ShowPost, наследуемся от DetailView
    model = Men  # связываемся с моделью Men
    template_name = 'men/post.html'  # ссылка на шаблон</pre>

			</li>
			<li>
				В men/urls.py - path name='post' - вместо обращения к функции show_post - обращаемся к функции представления - ShowPost
				<pre>
path('post/&lt;slug:post_slug>/', ShowPost.as_view(), name='post'),</pre>
				Будет ошибка, сейчас - django обращается  не к post_slug, а просто к slug(это стандартно)
			</li>
			<li>
				Для решение проблемы в ShowPost - добавляем аттрибут slug_url_kwarg
				<pre>
# отображение поста - функция представления
class ShowPost(DetailView):  # создаём класс ShowPost, наследуемся от DetailView
    model = Men  # связываемся с моделью Men
    template_name = 'men/post.html'  # ссылка на шаблон
    slug_url_kwarg = 'post_slug'  # чтобы post/&lt;slug:post_slug>/ - стандартно искал бы post/&lt;slug:slug>/
    # pk_url_kwarg = 'post_pk' -  аналогично если бы хотели пользоваться id вместо слага в url</pre>
			</li>
			<li>
				В ShowPost добалвяем context_object_name
				<pre>
context_object_name = 'post'</pre>
			</li>
			<li>
				Добавляем get_context_data - для передачи title и side(для примера) в ShowPost
				<pre>
# Передаём параметры в шаблон (функция формирует и динамический и статический контекст)
def get_context_data(self, *, object_list=None, **kwargs):
    # берём уже существующий контекст get_context_data =  ('posts')
    # **kwargs - распаковываем словарь kwargs
    context = super().get_context_data(**kwargs)  # на этом моменте у нас уже есть posts
    context['side'] = side  # добавим в словарь context - список side и даём ему имя side
    context['title'] = context['post']  # Имя поста в title
    # context['cat_selected'] = object_list.cat_id # НЕРАБОТАЕТ - ДОБАВЬ ПОТОМ
    return context  # передаём все параметры в шаблон posts+title+side</pre>
			</li>
			<li>
				<span class="spec">CreateView</span>
				<br>Например - для добовлении нового поста
				<br>Импортируем в men/views.py
				<pre>
from django.views.generic import ListView, DetailView, CreateView  # функции представления</pre>
			</li>
			<li>
				Вместо функции def addpage - создаём функцию представления
				<pre>
# Функция представления страницы формы добавления поста
class AddPage(CreateView):
    form_class = AddPostForm  # связываемся с встроенным классом формы AddPostForm
    template_name = 'men/addpage.html'  # ссылка на шаблон</pre>
			</li>
			<li>
				Корректируем path name='add_page' (в men/urls.py)
				<pre>
path('addpage/', AddPage.as_view(), name='add_page'),</pre>
				После этого в целом всё уже работает, только нехватает заголовка title
			</li>
			<li>
				Добавляем get_conytext_menu - для передачи в шаблон (title и side(для примера)).
				В men/views.py - class AddPage(CreateView):
				<pre>
    # Передаём параметры в шаблон (функция формирует и динамический и статический контекст)
    def get_context_data(self, *, object_list=None, **kwargs):
        # берём уже существующий контекст get_context_data =  ('posts')
        # **kwargs - распаковываем словарь kwargs
        context = super().get_context_data(**kwargs)  # на этом моменте у нас уже есть posts
        context['side'] = side  # добавим в словарь context - список side и даём ему имя side
        context['title'] = 'Добавление статьи'  # добавим в словарь передаваемых параметров title
        return context  # передаём все параметры в шаблон posts+title+side</pre>

			</li>
			<li>Сохраняем пост - и нам сразу же открывает страницу поста<br>
				Откуда django узнал что необходимо делать в AddPage? куда переправлять:
				<br>-Он обратился к модели Men
				<br>-В Men - добавил новую запись
				<br>-Воспользовался get - абсолют url
				<br>-который и вернул адресс - return reverse('post', kwargs={'post_slug': self.slug})
			</li>
			<li>
				Если у нас не было бы прописано get_absolut_url в Men, нам бы необходимо было указать атрибут / success_url = reverse_lazy('home')
				<pre>success_url = reverse_lazy('home')  # после добавления формы, перенаправит по пути path name='home'</pre>
				<br>Обязательно необходим import reverse_lazy во views.py
				<pre>from django.urls import reverse_lazy</pre>
			</li>
			<li>
				<span class="spec">reverse reverse_lazy</span>
				<br>функция reverse - строит маршрут
				<br>функция reverse_lazy - строит маршрут только в момент когда он понадобится
			</li>

			<br><br>
			<h4 class="title_text border">[16]. Основы ORM.</h4>
			
			<li>
				Основы ORM - API модели
				<br>В ORM-джанго очень богатый функционал - настолько что врятли когдато пригодится переходить на уровень SQL запросов
				<ul>
			
					<li>
						Будем работать в терминале django - (PyCharm) - чтобы запустить термина. В PyCharm терминал - в termonal - пишем команду
						<pre>python manage.py shell</pre>
					</li>
					<li>
						Загружамем все модели в термина
						<pre>from men.models import *</pre>
					</li>
					<li>
						Посмотреть все записи модели
						<pre>Men.objects.all()</pre>
						<pre>&lt;QuerySet [&lt;Men: Сергей Бодров>, &lt;Men: Марк Уолберг>, &lt;Men: Брэд Питт>, &lt;Men: Вячеслав Бутусов>, &lt;Men: Юрий Шевчук>, &lt;Men: Кеша Кешевич>]&lt;</pre>
						Записи будут отсортированы согласно спец классу Meta - в models.py
					</li>
					<li>
						Указать первые 2 записи
						<pre>Men.objects.all()[:2]</pre>
					</li>
					<li>
						просмотреть SQL запрос
						<pre>
from django.db import connection

connection.queries</pre>
					</li>
					<li>
						Посмотреть записи со второй по 4
						<pre>Men.objects.all()[2:5]</pre>
					</li>
					<li>
						Сортировка по pk или id
						<pre>Men.objects.order_by('pk')</pre>
					</li>
					<li>
						Сортировка по pk или id в обратном порядке
						<pre>Men.objects.order_by('-pk')</pre>
						ИЛИ
						<pre>Men.objects.reverse()</pre>
					</li>
					<li>
						Выбрать все записи у который первичный ключ меньше либо равен 2
						<pre>Men.objects.filter(pk__lte=2)</pre>
					</li>
					<li>
						Выбрать одну запись - метод <strong>get</strong>, так же выбирается 1 параметр по которому будет выбор обычно это pk или slug
						<pre>Men.objects.get(pk=2)</pre>
					</li>
					<li>
						При использовании фильтра filter - возвращается коллекция -QuerySet-
						<br>При использовании get - возвращается экземпляр класса (одна запись)
					</li>
					<li>
						Обработка связанных данных, обработка тсвязанныых таблиц
						<br>Для начала возьмум одну запись и присовим переменненнцю w.
						<pre>
							 w=Men.objects.get(pk=1)</pre>
							 <br>Теперь мы можем обращаться по следующим свойствам:
							 <br>-w.title/w.content...w.is_publisher (поля таблицы модели)
							 <br>-w.pk/w.ig - первичный ключ или id
							 <br>-w.cat_id - идентефикатор рубрики (id категории) - то есть это уже другая модель Category, но в модели Men мы сделали поле cat - отношение к категории
							 <br>-w.cat - объект класса Category, хранищий данные записи с id = cat_id
					</li>
					<li>
						Обращаемся к категории (из объекта Men)
						<pre>w.cat  -->  &lt;Category: Актёры></pre>
						Мы получаем 'Актёры' из за нашего метода __str__ - в models.py Category - этот метод возвращает имя категории - как мы и прописывали
					</li>
					<li>
						Обращаемся к полю Category через объект Men
						<pre>w.cat.name --> 'Актёры'</pre>
					</li>
					<li>Если идёт обращение к какому то полю к которому ранее не обращались, то для получения его значения джанго генерирует sql запрос</li>
					<li>
						-вторичная модель-_set
						<br>Используем первичную модель Category - для получения всех связанных с ней постов (по записи из категоррии актуры - выберем все записи из Men - которые относятся к актёрам)
					</li>
					<li>
						Для начала выберем одну запись из таблицы Category
						<pre>c=Category.objects.get(pk=1) --> &lt;Category: Актёры></pre>
					</li>
					<li>
						Теперь прочитаем все записи из Men - обращаясь через запись из Category
						<pre>c.men_set </pre>
						нам вернётся объект RelatedManager object at 0x000001878E15B0D0
					</li>
					<li>
						Выберем свех Актёров из Men
						<pre>c.men_set.all()
QuerySet [&lt;Men: Сергей Бодров>, &lt;Men: Марк Уолберг>, &lt;Men: Брэд Питт>]></pre>

					</li>
					<li>
						<strong>Фильтры полей</strong>
						<br>-имя атрибута-_gt/gte/lt/lte (gt (>), gte (>=), lt (<), lte (<=))
					</li>
					<li>
						Выбрать записи у которых в заголовке есть фрагмент 'че'
						<pre>Men.objects.filter(title__contains='че')</pre>
						Не важно где 'че' находится - в начале/середине/конце строки - найдёт всё
					</li>
					<li>
						Аналогичный поиск без учёта регистра
						<br><strong>!SQLite Не поддерживает учёт регистра для русских символов</strong>
						<br>В postgresql всё ок
						<pre>Men.objects.filter(title__icontains='ВЯ') --> QuerySet - Men - Вячеслав Бутусов></pre>
					</li>
					<li>
						Выбор записей по значениям - pk
						<pre>Men.objects.filter(pk__in=[2, 5, 11])</pre>
					</li>
					<li>
						Выбор записей по двум фильтрам
						<pre>Men.objects.filter(pk__in=[1,3,4], is_publisher=True)</pre>
						Т.е выберет только те что совпадают по двем параметрам одновременно.
						<br>То есть  pk=... and is_publisher = True
					</li>
					<li>
						Обращения к записям по внешнему ключу (по категории актёры и музыканты)
						<pre>Men.objects.filter(cat__in=[1,2])</pre>

					</li>
					<li>
						<strong>Класс Q</strong> при использовании с операторами:
						<br>-& - Логичесое И (приоритет 2)
						<br>-| - логическое ИЛИ (приоритет 3)
						<br>-~ - логическое НЕ (приоритет 1)
					</li>
					<li>
						Импортируем класс Q
						<pre>from django.db.models import Q</pre>
					</li>
					<li>
						ИЛИ в фильтрах - класс Q
						<pre>Men.objects.filter(Q(pk__lt=5) | Q(cat_id=2))</pre>
						pk <= 5 ИЛИ категория =2(музыканты)
					</li>
					<li>
						И в фильтрах - класс Q
						<pre>Men.objects.filter(Q(pk__lt=5) &  Q(cat_id=2))</pre>
						pk <= 5 И категория =2(музыканты)
					</li>
					<li>
						НЕ в фильтрах - класс Q
						<pre>Men.objects.filter(~Q(pk__lt=5) | Q(cat_id=2)) </pre>
						pk (<= 5) - ~ НЕ - т.е превратилось в  >= 5
						<br>ИЛИ категория =2(музыканты)
					</li>
					<li>
						Взять перыую запись из выборки (метод first())
						<pre>Men.objects.first()</pre>
						Он возьмёт первую запись в соответстии с сортировкой (сортировку прописывали в models.py)
					</li>
					<li>
						Берём первую запись отсортированную по pk
						<pre>Men.objects.order_by('pk').first()</pre>
					</li>
					<li>
						Берём последнюю запись из выборки (last())
						<pre>
Men.objects.last()</pre>
					</li>
					<li>
						Взять запись с самой поздней датой обновления (то есть обноалялвсь недавнее всех)
						<pre>Men.objects.latest('time_update')</pre>
					</li>
					<li>
						Взять запись с самой ранней датой обновления (то есть обноалялвсь давнее всех)
						<pre>Men.objects.earliest('time_update')</pre>
					</li>
					<li>
						Выбрать предыдущую или следующую запись относительно какойто
						<pre>
w = Men.objects.get(pk=5)  # выбираем 1 запись
w.get_previous_by_time_update()  # предыдущая запись (по времени обновления)
w.get_next_by_time_update()  # следущая запись относительно w (по времени обновления)</pre>
					</li>
					<li>
						Слудещая запись относительно w по времени обновления у которой id выше 3
						<pre>
w.get_next_by_time_update(pk__gt=3)</pre>
					</li>
					<li>
						exist() - проверка существования<br>

						count() - получение количества записей
					</li>
					<li>
						Добавление в таблицу Category ещё одной рубрики(записи)
						<pre>
Category.objects.create(name='Спортсмены', slug='sportsmens')</pre>
					</li>
					<li>
						Проверка наличии записи в Men - что соответствуют категории спортсмены
						<pre>
c3 = Category.objects.get(pk=3)  # выбрали запись спортсмены, в модели Category
c3.men_set.exists() --> False  # это означает что в модели Men - нет записей свызанных с категорие Спортсмены.</pre>
					</li>
					<li>
						Количество записей в Men, связанныъ с Category-спортсмены
						<pre>c3.men_set.count()  -->  записей 0</pre>
					</li>
					<li>
						Считаем количество записей в Men, у которых pk > 4
						<pre>Men.objects.filter(pk__gt=4).count()</pre>
					</li>
					<li>
						Выберем записи в Men - относящийся к Категории - по слагу Categort
						<pre>Men.objects.filter(cat__slug='aktyory')</pre>
						Здесь идёт вормирование <имя первичной модели>__<название поля первичной модели>
						<br>В нашем случае 1-мы обратились к нашему полю Men = cat.  2 - Это поле обратилось к конкретной категории. 3 - из за метода __str__ self.name - внутри Category - нам выдало поле name класса Category
						<br>slug -  это поле slug в Category
						<br><br>Повторюсь Category - Это первичная модель, Men - это вторичная модель
					</li>
					<li>
						Аналогично - обращаемся к категории, через запись в Men , по id - категории. - и получаем все записи Men, по категории id = 1
						<pre>Men.objects.filter(cat__in=[1])</pre>
					</li>
					<li>
						Выберем все записи Men - по имени категории 'Музыканты' (Через поля Men = cat __ Category = name)
						<pre>Men.objects.filter(cat__name='Музыканты')</pre>
						Всё это обращение к полю первичной модели, начиная от поля cat - вторичной модели
					</li>
					<li>
						В обращении к полю первичной модели, с дополнительным вильтром.
						<pre>Men.objects.filter(cat__name__contains='к')</pre>
						Покажет все записи Men, категорий = А-К-тёры, Музы-К-анты
					</li>
					<li>
						Выбрать все категории (первичная модель Category), которые связаны с записями вторичной модели Men
						<pre>
Category.objects.filter(men__title__contains='че')
-->  &lt;QuerySet [&lt;Category: Музыканты>]</pre>
						То есть мы выбрали все категории, которые связаны с записями из модели (таблицы) Men, в которых к заголовке (поле title Men) - присутствует отрывок 'че'  - В нашем случае это была запись Вячеслав Бутусов - которая относится к категории Музыканты, и соответственно нам выдаст всю категорию Музыканты - и отобразит 
					</li>
					<li>
						<pre>
Category.objects.filter(men__title__contains='е')
--> &lt;QuerySet [&lt;Category: Актёры>, <Category: Актёры>, <Category: Музыканты>, <Category: Музыканты>, &lt;Category: Музыканты>]></pre>
						длинный список и повторяющийся получился потому, что будет вывводится категория всякиц раз, когда в Men бузет находится объект в tittle которого будет 'е' - Сергей Бодров - Сузыканты, Марк Уолберг - Актёры, Вечеслав Бутосов - Музыканты, Брий Шевчук - Музыканты, Кеша Кешович - Музыканты.
					</li>
					<li>
						Что бы не было посторения, необходимо выбрать только уникальные категории, то есть отобразятся 1 раз если даже будет совпадение более одного раза
						<pre>
Category.objects.filter(men__title__contains='е').distinct()
--> &lt&ltQuerySet [&ltCategory: Актёры>, &ltCategory: Музыканты>]></pre>
					</li>
					<li>
						Функции агрегации Count, Min, Max, Sum
					</li>
					<li>
						Импортируем все функции из django.db.models
						<pre>from django.db.models import *</pre>
					</li>
					<li>
						Минимальный cat_id  - id категории в таблице Men
						<pre>
Men.objects.aggregate(Min('cat_id')) -->  {'cat_id__min': 1}
Men.objects.aggregate(Max('cat_id')) -->  {'cat_id__max': 2} (потому что в спортсменах id=3 - сейчас нет записей в Men)
Men.objects.aggregate(Max('pk')) -->  {'pk__max': 11}
Men.objects.aggregate(Min('pk')) -->  {'pk__min': 1}</pre>
					</li>
					<li>
						Получение сразу нескольких значений cat_id - в виде словаря
						<pre>
Men.objects.aggregate(Min('cat_id'),Max('cat_id'))
--> {'cat_id__min': 1, 'cat_id__max': 2}</pre>
					</li>
					<li>
						Если мы хотим переименовать ключи
						<pre>
Men.objects.aggregate(minimal_catid=Min('cat_id'), maximal_idcat=Max('cat_id'))
--> {'minimal_catid': 1, 'maximal_idcat': 2}</pre>
					</li>
					<li>
						С агрегирующими функциями можно выполнять математические операции
						<pre>
Men.objects.aggregate(result=Sum('cat_id')- Count('cat_id'))
--> {'result': 3}</pre>
						Из суммы cat_id вычли количество cat_id
						<br>result = (1+1+1+2+2+2) - 6(записей)
					</li>
					<li>
						Среднее арифметическое pk - записей Men
						<pre>
Men.objects.aggregate(sred_arifm=Avg('pk'))
--> {'sred_arifm': 4.333333333333333}</pre>
						sred_arifm = (1+2+3+4+5+11) / 6
					</li>
					<li>
						Возьмём среднее арифметическое cat_id только у записей у которых pk >=5
						<pre>
Men.objects.filter(pk__gte=5).aggregate(sred_arifm=Avg('cat_id'))
--> = 	{'sred_arifm': 2.0}</pre>
					</li>
					<li>
						Выбор записи и их конкретных полей
						<br>метод values()
					</li>
					<li>
						Возьмём одну из запись у которой pk -1, только два поля title slug и cut_id
						<pre>
Men.objects.values('title', 'slug', 'cat_id').get(pk=1)
--> {'title': 'Сергей Бодров', 'slug': 'sergej-bodrov', 'cat_id': 1}</pre>
					</li>
					<li>
						Получение имя Сategory из записи Men по pk записи Men = 11
						<pre>Men.objects.get(pk=11).cat.name</pre>
					</li>
					<li>
						Выберем:
						<br>-поле title - из Men
						<br>-поле name - из Category
						<br>-По ключу из Men
						<pre>
Men.objects.values('title','cat__name').get(pk=4)
-->	{'title': 'Вячеслав Бутусов', 'cat__name': 'Музыканты'}</pre>
					</li>
					<li>
						Выбрать все записи из таблицы Men, только Поля:
						<br>-title - из Men
						<br>-name - из Category
						<pre>Men.objects.values('title','cat__name')</pre>
					</li>
					<li>
						Выведем все записи по вышеуказанным параметрам - через цикл for
						<pre>
spisok_po_parametram = Men.objects.values('title','cat__name')
for zapis in spisok_po_parametram:
     print(zapis['title'], zapis['cat__name'])

-->
Сергей Бодров Актёры 
Марк Уолберг Актёры
Брэд Питт Актёры
Вячеслав Бутусов Музыканты
Юрий Шевчук Музыканты
Кеша Кешевич Музыканты</pre>
					</li>
					<li>
						<span class="spec">
							Если не понимаешь как получить какоето значение, какуюто переменную:
							<br>-запусти django shell в терминале - python manage.py shell
							<br>-в sell импортирую всё что нужно (модели, Q, функции Min, Max, Count,)
							<br>-Эксперементируй, в получении необходимых данных с помощью get(), filter(), values(), Category.men__set.all, cat__name, cat__slug и тд
						</span>
					</li>
					<li>
						Группировка записей и агрегирование с помощью метода annotate
					</li>
					<li>
						Сгруппировать записси по cat_id (выбрать записи для первой категории и для второй категории) - то есть получим две независимые группы записей - а затем к каждой группе применить агрегацию и получить искомые значения
						<pre>
Men.objects.values('cat_id').annotate(Count('id'))
-->
&lt;QuerySet [{'&lt;cat_id': 2, 'id__count': 3}, {'cat_id': 1, 'id__count': 3}]>	
						</pre>
						Метод - values - говорит что смотрим только поле cat_id. И в сочеттании с annotate - на уровне SQL запроса будет давать как - группировка по cat_id
						<br>Затем Count('id') - будет считать колиество записей в каждой категории
						<br>Получилось [{категория=2 количество записей=3},{категория=1 количество записей=3}]
					</li>
					<li>
						Количество записей в категории
						<pre>
c = Category.objects.annotate(Count('men'))
c --> &lt;QuerySet [&lt;Category: Актёры>, &lt;Category: Музыканты>, &lt;Category: Спортсмены>]>
c[0].men__count --> 3  # количество записей в Category: Актёры
c[1].men__count --> 3  # количество записей в Category: Музыканты
c[2].men__count --> 0  # количество записей в Category: Спортсмены</pre>
					</li>
					<li>
						Количество записей в категории через переменную
						<pre>
c = Category.objects.annotate(total=Count('men'))
c --> &lt;QuerySet [&lt;Category: Актёры>, &lt;Category: Музыканты>, &lt;Category: Спортсмены>]>
c[0].total --> 3  # количество записей в Category: Актёры
c[1].total --> 3  # количество записей в Category: Музыканты
c[2].total --> 0  # количество записей в Category: Спортсмены</pre>
					</li>
					<li>
						Количество записей (рубрик) в Сategory - (т.е Актёры, Музыканты, Спортсмены)
						<pre>
c = Category.objects.annotate(total=Count('men'))
len(c) --> 3</pre>
					</li>
					<li>
						Количество рубрик, у которых количество записей больше 0 (т.е количество актёров, количество музыкантов)
						<pre>
c = Category.objects.annotate(total=Count('men')).filter(total__gt=0)
c --> 	&lt;QuerySet [&lt;Category: Музыканты>, &lt;Category: Актёры>]>	
len(c) --> 	2</pre>
					</li>
					<li>
						<span class="spec">class F</span>
						<pre>
from django.db.models import F  # необходим импорт

Men.objects.filter(pk__gt=F('cat_id'))
# т.е  pk > cat_id ?? - покажет все записи Men кроме первой
# Эта операция искуственный пример - её врятли когдато придётся вызывать, очень нелогичный запрос.</pre>
					</li>
					<li>
						F можно использывать например для подсчёта числа просмотров, отдельного поста 
						<pre>
# views  # предположим в нашей модели Men есть поле views(количество просмотров)
Men.objects.filter(slig='bitusov').update(views=F('views')+1)
#При просмотре страницы бутусова, views будет обнавлятся как = views + 1</pre>
					</li>
					<li>
						Увеличение числа просмотров - другой вариант
						<pre>
w = Men.objects.get(pk=1)  # получаем запись с pk=1
w.views = F('views')+1  # добавляем количество просмотров
w.save()  # сохраняем запись (все изменения полей записи)</pre>
					</li>
					<li>
						В django - есть набор функций который позволяет делать вычисления на стороне СУБД
					</li>
					<li>
						Вычисляем длину строки
						<pre>
from django.db.models.functions import Length  # необходим импорт

ps = Men.objects.annotate(len=Length('content'))
ps -->  &lt;QuerySet [&lt;Men: Сергей Бодров>, &lt;Men: Марк Уолберг>, &lt;Men: Брэд Питт>, &lt;Men: Вячеслав Бутусов>, &lt;Men: Юрий Шевчук>, &lt;Men: Кеша Кешевич>]>
ps[0].len --> 1724  # Длина строки(количество символов) в поле контент, для записи Сергей Бодров
ps[5].len --> 4  # Длина строки(количество символов) в поле контент, для записи Кеша Кешевич</pre>
					</li>
					<li>
						Количество символов для каждой записи c помощью for:
						<pre>
ps = Men.objects.annotate(len=Length('content'))
# ps - получится список из всех записей, по порядку	, переменной len - присваемаем len(content)
>>> for p in ps: 
...     print('В записи', p, p.len, 'символов.') 
-->

В записи Сергей Бодров 1724 символов. 
В записи Марк Уолберг 3346 символов.
В записи Брэд Питт 2993 символов.
В записи Вячеслав Бутусов 812 символов.
В записи Юрий Шевчук 3638 символов.
В записи Кеша Кешевич 4 символов.</pre>

					</li>
					<li>
						raw SQL запросы - запросы не на уровне ORM Django - а на уровне SQL в чистом виде - необходимости в этом в 95% случаев нету
						<br>
						Manager.raw(< SQL Запрос >)
						<pre>
Men.objects.raw('SELECT * FROM men_men')  # это SQL запрос
-->	&lt;RawQuerySet: SELECT * FROM men_men>
w = _ --> сохроним в переменную w - то что возвратил SQL
for p in w:                              
    print(p.pk, p.title)                 
--> 
2 Марк Уолберг 
4 Вячеслав Бутусов
5 Юрий Шевчук
3 Брэд Питт
1 Сергей Бодров
11 Кеша Кешевич</pre>
					</li>
					<li>
						Очистить список SQL запросов
						<pre>
from django.db import reset_queries 
reset_queries() # очищаем список SQL запросов
connection.queries # смотрим список запросов
--> []  # список пуст</pre>
					</li>
					<li>
						Делаем SQL запрос и читаем:
						<pre>
w = Men.objects.raw('SELECT * FROM men_men')
connection.queries  --> [] # запрос пуст!</pre>
						<strong>До тех пор пока мы не пытались что то прочитать из переменной w, никакого SQL запроса выполнено не будет!</strong>
						<br>Читаем
						<pre>
w[0] -->  &lt;Men: Марк Уолберг>  # прочитали
connection.queries  --> смотрим SQL запрос
--> [{'sql': 'SELECT * FROM men_men', 'time': '0.000'}]  # это и есть SQL Запрос</pre>
					</li>
					<li>
						* - это все поля в SQL, но если обращатся не ко всем полям а к каомуто определенному полю - в запросе обязательно должно фигурировать поле id
						<pre>
w = Men.objects.raw('SELECT id, title FROM men_men')</pre>
					</li>
					<li>
						Передаём параметр в SQL запрос
						<pre>
#выбираем запись (заголовок) по слагу kesha
Men.objects.raw("SELECT id, title FROM men_men WHERE slug='kesha'")
# Этот запрос небезопасен, лучше сделать так как ниже
# безопасный путь
slug = 'kesha'
Men.objects.raw("SELECT id, title FROM men_men WHERE slug='%s'", [slug])</pre>
					</li>
					<li>
						Выходим из python shell
						<pre>exit()</pre>
					</li>
				</ul><!-- орм -->
			</li><!-- орм -->


			<br><br>
			<h4 class="title_text border">[17]. Mixins - убираем дублирование кода.</h4>
			<li>
				Mixins - убираем дублирование кода
				<br>Будем выночить общий код из классов представления - MenHome, MenCategory, AddPage - в отдельный класс - Mixin (англ. - примесь)
				<br>
				<img src="images\mixin.jpg" class="img-fluid">
				<br>
			</li>
			<li>
				Когда объявляем класс MenHome(DataMixin, ListView):  - DataMixin - это общий класс который мы создадим, его необходимо указывать первым чтобы Django  обраба его петывал его первым. (В Python - тот класс который записан первым - первым и будет обрабатываться)
			</li>
			<li>
				Для дополнительных и вспомогательных классов необходим отдельный файл - В men создаём utils.py
			</li>
			<li>
				Можно везде удалить side - из views.py, из шаблонов index.html
			</li>
			<li>
				В men/utils.py - переносим menu - это список названий и url_name - в navbar
				<pre>
menu = [{'title': 'О сайте', 'url_name': 'about'},
	{'title': 'Добавить статью', 'url_name': 'add_page'},
	{'title': 'Обратная связь', 'url_name': 'contact'},
	{'title': 'Войти', 'url_name': 'login'},
]</pre>
			</li>
			<li>
				В men/utils.py - прописываем новый вспомогательный класс - называем его DataMixin.
				<pre>
class DataMixin:
    # метод будет создавать context (передаваемые параметры) - для шаблонов
    def get_user_context(self, **kwargs):
        # формируем начальный словарь context - из именованных параметров переданной методу g_u_c
        context = kwargs
        cats = Category.objects.all()  # формируем список категорий
        context['menu'] = menu  # {'menu':menu}, {'ключ':'значение'}
        context['cats'] = cats
        if 'cat_selected' not in context:  # если cat_selected нету в context
            context['cat_selected'] = 0  # создаём cat_selected и присваиваем значение 0
        return context  # вернём словарь context(словарь передаваемых параметры в шаблоны)</pre>
				<br>
				Там же необходимо импортировать нашу модель Category (я сразу импортировал все)
				<pre>from men.models import *</pre>
			</li>
			<li>
				Из base.html - убираемм ссылку на наш вложенный тег - def show_categories(sort=None, cat_selected = 0)
				<pre>
{% show_categories 'name' cat_selected %}  -  удаляем</pre>
			</li>
			<li>
				В место этого копируем вывод категорий из шаблона list_categories
				<pre>
<!-- # cats = Category.objects.all() из utils.py/ class DataMixin -->
{% for c in cats %}
    {% if c.pk == cat_selected %} 
        &lt;li class="selected">{{ c.name }}&lt;/li>
    {% else %}
        &lt;li>&lt;a href="{{ c.get_absolute_url }}">{{ c.name }}&lt;/a>&lt;/li>
    {% endif %}
{% endfor %}</pre>
				По сути так было изначально - теперь мы не ссылаемся на наш вложенный тег def show_categories из men_tags.py
				<br>Мы будем ссылаться на class DataMixin - который вормирует все категории в context (то есть словарь передаваемых параметров в контексте)
			</li>
			<li>
				В men/views.py - импортируем наш файл - utils.py
				<pre>from .utils import *</pre>
			</li>
			<li>
				Изменяем class MenHome:
				<pre>
class MenHome(ListView): --> class MenHome(DataMixin, ListView):

-delet-delet-delet-delet-delet-delet-delet-delet-delet-
context['side'] = side  
context['title'] = 'Главная страница'
context['cat_selected'] = 0
-delet-delet-delet-delet-delet-delet-delet-delet-delet-

в место удалённого кода 1 строки:
# берём context = menu, cat_selected, cats из DataMixin, добавляем в context - title='Главная страница'
# через self - мы обращаемся к DataMixin
с_def = self.get_user_context(title='Главная страница')
# плюсуем то что было раньше в context(post) - и context из DataMixin + title
context = dict(list(context.items()) + list(c_def.items()))


return context
-->
# плюсуем то что было раньше в context(те post) - и context из DataMixin + title
# и передаём все параметры в шаблон posts+title+menu+cat_selected+cats
return dict(list(context.items()) + list(c_def.items()))</pre>
			</li>
			<li>
				из base.html - уберём ссылку на наш вложенный show_menu()
				<pre>
<!-- меню навбара вложенный тег -->
{% show_menu %}	  --> УДАЛЯЕМ</pre>
				<br>
				Вместо удалённого добавляем наш навбар из list_menu, то есть как было изначально - теперь мы будем ссылаться не на вложенный тег list_menu - а просто на передаваемые пораметры context - из функция представлений (в нашем лусучае классов представлений)  context которых равен, то что прописано в самих классах представления и в классе Datamixn
				<pre>
# Навбар -->
{% block mainmenu %}
    &lt;div class="header">
        &lt;ul  id="mainmenu" class="mainmenu">
            # Это лого внутри навбар -->
            &lt;li class="logo">&lt;a href="{% url 'home' %}">&lt;div class="logo">&lt;/div>&lt;/a>&lt;/li>
            # перебираем все в списке меню (men/views.py) -->
            {% for m in menu %}

                # если не последний -->
                {% if not forloop.last %}
                &lt;li>&lt;a href="{% url m.url_name %}">{{m.title}}&lt;/a>&lt;/li>
                {% else %}
                &lt;li class="last">&lt;a href="{% url m.url_name %}">{{m.title}}&lt;/a>&lt;/li>
                {% endif %}                                
            
            {% endfor %}
        &lt;/ul>
        &lt;div class="clear">&lt;/div>
    &lt;/div> # &lt;div class="header"> -->
# Конец Навбар -->
{% endblock mainmenu %}</pre>
			</li>
			<li>
				Во views.py полностью избавляемся от side (ctrl+f) - меняем на menu - везде. side - был в целях обучения
			</li>
			<li>
				Меняем класс представления  AddPage
				<pre>
class AddPage(ListView): -->  class AddPage(DataMixin, CreateView):

убираем дублирование кода
-delet-delet-delet-delet-delet-delet-delet-delet-delet-
context['menu'] = menu
context['title'] = 'Добавление статьи'
-delet-delet-delet-delet-delet-delet-delet-delet-delet-
-->
c_def = self.get_user_context(title='Добавление статьи')

return context
-->
# posts + cats + cat_selected + menu + title
return dict(list(context.items()) + list(c_def.items()))</pre>
			</li>
			<li>
				Аналогично делаем тоже самое в ShowPost:
				<br>-Добавлеям DataMixim
				<br>-Убираем дублирование кода - вставляем c_def
				<br>-Суммируем context из функции представления и класса DataMixin
				<br>Здесь тольк один ньюанс формирование заголовка на основе get_context_data - то есть название поста
				<pre>c_def = self.get_user_context(title=context['post'])</pre>
			</li>
			<li>
				Меняем class MenCategory(функция представления)
				<pre>
class MenCategory(DataMixin, ListView):</pre>
				<pre>
-delet-delet-delet-delet-delet-delet-
context['menu'] = menu
context['title'] = 'Категория - ' + str(context['posts'][0].cat)
context['cat_selected'] = context['posts'][0].cat_id
-delet-delet-delet-delet-delet-delet-
-->
c_def = self.get_user_context(title='Категория - ' + str(context['posts'][0].cat),
                                      cat_selected=context['posts'][0].cat_id)

return dict(list(context.items()) + list(c_def.items()))</pre>
			</li>
			<li>
				Теперь все классы представления  - ссылкаются на DataMixit - то есть главная страница, страница отдельного поста, страница, страница категории, страница добавления записи
			</li>
			<li>
				Есть стандартные микмины, например LoginRequeriedMixin - он будет запрещать смотреть страницы незарегестрированным пользователям
			</li>
			<li>
				Импортируем стандартный миксин LoginRequeriedMixin - во views.py
				<pre>from django.contrib.auth.mixins import LoginRequiredMixin</pre>
			</li>
			<li>
				Добавим в класс представления AddPage - миксин LoginRequiredMixin, чтобы запрещать просматривать эту страницу не авторизованным пользователям
				<pre>
class AddPage(LoginRequiredMixin, DataMixin, CreateView):</pre>
				Всё работает, теперь чтобы зайти на страницу, на данном этапе, необходимо авторизоватся из админки, потом перейти на сайт (позже будем добавлять и других пользователей)
				<br>Если в админке выйдем из аккаунта - попробуем зайти на страницу добавить статью - будет 404
			</li>
			<li>
				Добавим в AddPage - перенаправление на авторизацию (пока только с админки) - если полльзователь не авторизован.
				<br>Для этого во views.py - class AddPage добавим аттрибут - login_url
				<pre>login_url = '/admin/'</pre>
				<br>можно в место этого просто перенаправлять на домашнюю страницу
				<pre>login_url = reverse_lazy('home')</pre>
			</li>
			<li>
				Генерировать страницу 403 - доступ запрещён
			</li>
			<li>
				LoginRequiredMixin - работает только с классами представления, если мы хотим запрещать в функции представления, необходимо использовать декоратор
			</li>
			<li>
				ограничиваем доступ def about - с помошью декоратора
				<pre>
from django.contrib.auth.decorators import login_required  # запрет на функцию представления

@login_required
def about(request):  # о странице
    # (request, 'men/templates/men/about.html', {'ключ':'значение'})
    return render(request, 'men/about.html', {'menu': menu, 'title': 'О сайте'})</pre>
    			Будет страница 404
    			<br><strong>Убираем @login_required - он нам не нужен, показал просто для демонстрации</strong>
			</li>
			<li>
				Сделаем так, чтобы пункт в navbar - вообще не показывался бы в navbar если пользователь не авторизован
				<br>Для этого в utils.py - class DataMixin: меняем:
				<pre>
context['menu'] = menu - удаляем
-->
# копируем всё меню в новую переменную (когда будет вызываться метод get_user_context)
user_menu = menu.copy()
if not self.request.user.is_authenticated:  # если не авторизован:
    user_menu.pop(1)  # удаляем 'Добавить Меню' строчку полностью с URLom
context['menu'] = user_menu  # {'menu':'user_menu'} / {'ключ':'значение'}</pre>
				Всё работает как планировали
			</li>
			<li>
				Сделаем так, что если у рубрики нет не одного поста (в данном случае Спортсмены), эту рубрику не отображать в sidebar вовсе, пока там не появится хотябы отдной записи
				<br>Для этого - опять в DataMixin (из utils.py)
				<pre>
from django.db.models import Count  # импортируем count в utils.py

cats = Category.objects.all()  # формируем список категорий
---> меняем на --> 
 cats = Category.objects.annotate(Count('men'))  # количество постов в каждой рубрике</pre>
			</li>
			<li>
				В шаблоне base.html - добавляем ещё одну конструкцию if - в месте где отображаем категории
				<pre>
for c in cats без изменений					
{% if c.men__count > 0 %}
без изменений
{% endif %}
эндфор</pre>
			</li>
			<li>




			<br><br>
			<h4 class="title_text border">[18]. Постраничная навигация (пагинация).</h4>
			<li>
				Пагинация (пот лат. pagina - страница)
				<br>Например - когда у нас есть длинная страницы, и чтобы не отображать её сразу всю, снизу сделать цифры, которые и будут переключать
			</li>
			<li>
				class Paginator - отдельное использование
				<br>Можно использовать в ListView - встроеная функция
				<br>Пагинация в шаблоне
			</li>
			<li>
				Заходим в Python Console
				<br>PyDev console: starting.
				<br>В консоль импортируем Paginator
				<pre>
from django.core.paginator import Paginator</pre>
			</li>
			<li>
				Пишем какойто список из базы даееых например
				<pre>men = ['Сергей Бодров', 'Марк Уолберг', 'Брэд Питт', 'Вячеслав Бутусов', 'Юрий Шевчук', 'Кеша Кешевич', 'Кеша', 'Ксюша', 'Лексус', 'Симба', 'Кузя']</pre>
			</li>
			<li>
				Далее зоздаём экземпляр paginatora
				<pre>
p = Paginator(men, 3)
# где Paginator - это класс Paginatot
# men - список, который указывали ранее
# 3 - сколько элементов списка отображать на каждой странице (максимум)</pre>
			</li>
			<li>
				Узнаём количество элементов в списке
				<pre>p.count --> 10</pre><br>
				Узнаём количество страниц
				<pre>p.num_pages --> 4</pre><br>
				Писла по номерам наших страниц
				<pre>p.page_range --> range(1, 5)  # 1 2 3 4</pre><br>
				Получаем список для первой страницы, или для работы на первой странице
				<pre>
p1 = p.page(1)  # в переменную p1 - записали элементы списка первой страницы
p1.object_list  # посмотрели список элементов первой страницы
p1.has_next() --> True  # после этой страницы 1 существует страница 2
p1.has_previous() --> False  # До этой страницы нету страниц
p1.has_other_pages() --> True  # существует ли вообще разбивка по страницам --> Да
p1.next_page_number() --> 2  # Номер следующей страницы
p1.previous_page_number() --> ошиька  # Так как номера предудыщей строницы существовать не может</pre>
			</li>
			<li>
				Использование пагинации в классе представления MenHome - класс представления ListView - пагинация встроена в него!
				<br>Во views.py - class MenHome - добавляем спец атрибут пагинации - paginate_by = количество элементов списка на одной странице
				<pre>paginate_by = 2  # Количество отображаемых элементов на странице (пагинация)</pre>
			</li>
			<li>
				Использование пагинации в функции представления
				<br>Добавим код в def about во views.py
				<pre>
from django.core.paginator import Paginator  # необходим импорт class Paginator (во views.py)

def about(request):  # о странице
    contact_list = Men.objects.all()  # читаем список записей модели
    paginator = Paginator(contact_list, 3)  # создаём экземпляр Paginator, 3 - количество элементов на странице
    page_number = request.GET.get('page')  # получаем номер текущей страницы
    page_obj = paginator.get_page(page_number)  # содержит список элементов текущей страницы
    # (request, 'men/templates/men/about.html', {'ключ':'значение'})
    # передаём page_obj, menu, title в шаблон
    return render(request, 'men/about.html', {'menu': menu, 'title': 'О сайте', 'page_obj': page_obj})</pre>
			</li>
			<li>
				В самом шаблоне about.html отображаем список, через циклы for
				<pre>
{% for contact in page_obj %}
	<p>{{ contact }}</p>
{% endfor %}</pre>
				Проверяем, всё работает на - http://127.0.0.1:8000/about/
				<br>Чтобы отобразить следующие элементы списка в url необходимо доьавить - http://127.0.0.1:8000/about/?page=2
			</li>
			<li>
				Добавим ссылки снизу, для отображение url-s для отображения страницы
				<br>В about.html - добавляем:
				<pre>
&lt;nav>
	&lt;ul>
		#  page_obj - ссылка на конкр страницу пагинатора
		#  paginator - ссылка на сам класс пагинатор
		#  page_range - формирует range (от,до) - номера страниц
		#  p - по сути просто номер страницы
		{% for p in page_obj.paginator.page_range %}
		&lt;li>
			&lt;a href="?page={{ p }}">{{ p }}&lt;/a>
		&lt;/li>&lt;
		{% endfor %}
	&lt;/ul>
&lt;/nav></pre>
			</li>
			<li>
				Обновлю style.css - в static/men/css  - он обновлялся, чтобы не терять время, возьму в github - у зоздателя курса
			</li>
			<li>
				Добавим список номеров страниц в base.html - После block content/ endblock
				<pre>
# для пагинации -->
&lt;nav class="list-pages">
    &lt;ul>
   #  page_obj - ссылка на конкр страницу пагинатора
        #  paginator - ссылка на сам класс пагинатор
        #  page_range - формирует range (от,до) - номера страниц
        #  p - по сути просто номер страницы -->
        {% for p in page_obj.paginator.page_range %}
        &lt;li class="page-num">
            &lt;a href="?page={{ p }}">{{ p }}&lt;/a>
        &lt;/li>
        {% endfor %}
    &lt;/ul>
&lt;/nav># для пагинации --></pre>
				<strong>Сделали это в base.html (а не в index.html) - на будующее, чтобы не дублировать код</strong>
			</li>
			<li>
				Улучшим кнопки страниц (чтобы они отображались как выделенный текс, а не как выделенная страница) в Base.html - в тот же цикл for - добавим проверку if
				<br>base.html - полный код для ссылок страницы - пагинации
				<pre>
<!-- для пагинации -->
&lt;nav class="list-pages">
    &lt;ul>
   		#  page_obj - ссылка на конкр страницу пагинатора
        #  paginator - ссылка на сам класс пагинатор
        #  page_range - формирует range (от,до) - номера страниц
        #  p - по сути просто номер страницы -->
        {% for p in page_obj.paginator.page_range %}
        {% if page_obj.number == p %}
        &lt;li class="page-num page-num-selected">{{ p }}&lt;/li>
        {% else %}
        &lt;li class="page-num">
            &lt;a href="?page={{ p }}">{{ p }}&lt;/a>
        &lt;/li>
        {% endif %}
        {% endfor %}
    &lt;/ul>
&lt;/nav># для пагинации --></pre>
			</li>
			<li>
				Добавим пагинацию в класс представления - MenCategory - отображение статей по категориям
				<br>Можно было бы сделать точно так же добавив paginate_by - Но тогда мы будим дублировать код
				<br>По этому из class MenHome - удалим paginate_by - И перенесём его в class DataMixin: - из utils.py  - в самом верху - внутри класса
				<pre>
class DataMixin:
    paginate_by = 2  # Количество отображаемых элементов на странице (пагинация)</pre>
			</li>
			<li>
				Всё работает как надо - пагинация есть при отображении всех постов, при отображении постов по категориям
				<br>Но если пагинацию сделать большой (то есть отображать по 30записей например) - а у нас записей меньше 30, то внизу будет отображатся '1', По хорошему её необходимо убрать и не отображать
				<br>Для этого в base.html - Добавим проверку конструкцией if - сверху над nav
				<pre>
# если есть разбивка по страницам -->
{% if page_obj.has_other_pages %}
&lt;nav class="list-pages">
......
&lt;/nav># для пагинации -->
{% endif %}</pre>
			</li>
			<li>
				Если у пагинации будет очень много страниц, то это будет не очень практично
				<br>
				<img src="images\paginator.jpg" class="img-fluid">
				<br>
				Будем менять интервал страниц которые будут показываться 
				<br>base.html - добавим elif - Вместо else
				<pre>{% elif p >= page_obj.number|add:-2 and p <= page_obj.number|add:2 %}</pre>
			</li>
			<li>
				Добавим ещё кнопки - предыдущая и слудующая страница
				<br>В base.html - до цикла for добавляем проверку - и делаем кнопку предыдущей страницы
				<pre>
# существует ли предыдущая страница
{% if page_obj.has_previous %}
&lt;li class="page-num">
    # предыдущая страница
    &lt;a href="?page={{ page_obj.previous_page_number }}">&lt;&lt;/a>
&lt;/li>
{% endif %}</pre>
			</li>
			<li>
				Добавляем кнопку для слудующей страницы - аналогично - после цикла for
				<pre>
# существует ли следующая страница -->
{% if page_obj.has_next %}
&lt;li class="page-num">
    # кнопка предыдущая страница -->
    &lt;a href="?page={{ page_obj.next_page_number }}">&gt;&lt;/a>
&lt;/li>
{% endif %}</pre>
			</li>
			<li>
				<strong>Для пагинации желательно сортировать списки - ordering - в Модели - class Meta</strong>
			</li>
			<li>
				Итоговый кусок кода для пагинации (кнопок-ссылок) внутри шаблона base.html
				<pre>
# для пагинации -->

# если есть разбивка по страницам -->
{% if page_obj.has_other_pages %}
&lt;nav class="list-pages">
    &lt;ul>
        # существует ли предыдущая страница -->
        {% if page_obj.has_previous %}
        &lt;li class="page-num">
            # кнопка предыдущая страница -->
            &lt;a href="?page={{ page_obj.previous_page_number }}">&lt;&lt;/a>
        &lt;/li>
        {% endif %}


   		#  page_obj - ссылка на конкр страницу пагинатора
        #  paginator - ссылка на сам класс пагинатор
        #  page_range - формирует range (от,до) - номера страниц
        #  p - по сути просто номер страницы -->
        {% for p in page_obj.paginator.page_range %}
        {% if page_obj.number == p %}
        &lt;li class="page-num page-num-selected">{{ p }}&lt;/li>
        {% elif p >= page_obj.number|add:-2 and p <= page_obj.number|add:2 %}
        &lt;li class="page-num">
            &lt;a href="?page={{ p }}">{{ p }}&lt;/a>
        &lt;/li>
        {% endif %}
        {% endfor %}

        # существует ли следующая страница -->
        {% if page_obj.has_next %}
        &lt;li class="page-num">
            # кнопка слудующая страница -->
            &lt;a href="?page={{ page_obj.next_page_number }}">&gt;&lt;/a>
        &lt;/li>
        {% endif %}

    &lt;/ul>
&lt;/nav># для пагинации -->
{% endif %}</pre>
			</li>




			<br><br>
			<h4 class="title_text border">[19]. Регистрация пользователей на сайте | Django уроки.</h4>
			<li>
				Будем добалять регистрацию пользователей на сайт
			</li>
			<li>
				Для начала отобразим ссылку - 'войти' -  в base.html  - ввнутри block mainmenu - меняем конструкцию ссылок
				<pre>
<!-- перебираем все в списке меню (men/views.py) -->
{% for m in menu %}

&lt;li>&lt;a href="{% url m.url_name %}">{{m.title}}&lt;/a>&lt;/li>

{% endfor %}

&lt;li class="last">&lt;a href="{% url 'register' %}">Регистрация&lt;/a> | &lt;a href="{% url 'login' %}">Войти&lt;/a>&lt;/li></pre>
			</li>
			<li>
				В utils.py - уберём из списка menu  - строку для - 'Войти'
			</li>
			<li>
				В men/urls.py - добавим пути login и register (login уже быыл)
				<pre>
path('login/', login, name='login'),
path('register/', RegisterUser.as_view(), name='register'),
# RegisterUser.as_view() - класс представления - будем создавать</pre>
			</li>
			<li>
				Во views.py - прописываем class RegisterUser:
				<pre>
from django.contrib.auth.forms import UserCreationForm  # необходим импорт

# представление регистрации
class RegisterUser(DataMixin, CreateView):
    form_class = UserCreationForm  # UserCreationForm - стандартная форма регистрации django
    template_name = 'men/register.html'  # ссылка на шаблон
    success_url = reverse_lazy('login')  # при успешной регистрации - будем перенаправляться в path - login

    # формируем context (список передаваемых словарей в шаблон)
    def get_context_data(self, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)  # form_class - на данный момент
        c_def = self.get_user_context(title='Регистрация')
        # form_class + cats + cat_selected + menu + title
        return dict(list(context.items()) + list(c_def.items()))</pre>
			</li>
			<li>
				Создаём шаблон register.html - в men/templetes/men
				<br>В шаблоне наследуемся от base.html  - и внутри block content - добавляем форму
				<pre>
{% extends 'men/base.html' %}
{% block content %}
&lt;h1>{{ title }}&lt;/h1>
&lt;form method="post">
	{% csrf_token %}
	{{ form.as_p }}
	&lt;button type="submit">
		Регистрация
	&lt;/button>
&lt;/form>
{% endblock %}</pre>
				Форма в целом уже работает - но выглядит так себе, нет никакого выравнивания
			</li>
			<li>
				Изменяем вид в форме - внутри forms.py - лобавляем новый class
				<pre>
from django.contrib.auth.forms import UserCreationForm  # импорт класса формы
from django.contrib.auth.models import User  # импортируем модель User

# Форма регистрации
class RegisterUserForm(UserCreationForm):  # создаём экземпляр формы регистрации пользователя на базе UserCreationForm
    class Meta:
        model = User  # связь с моделью User (стандартная)
        # отображаем поля модели User
        # название полей - в админке - посмотреть код страницы - name
        fields = ('username', 'password1', 'password2')
        # оформление всех полей
        widgets = {
            'username': forms.TextInput(attrs={'class': 'form-input'}),
            'password1': forms.PasswordInput(attrs={'class': 'form-input'}),
            'password2': forms.PasswordInput(attrs={'class': 'form-input'}),
            }</pre>
            В views.py - class RegisterUser - form_class - меняем на нашу форму RegisterUserForm
            <pre>form_class = RegisterUserForm  # RegisterUserForm - наша форма из forms.py</pre>
            В итоге вид формы по сути не изменился.. В Django - почемуто не работает widgets - для полей формы регистрации
			</li>
			<li>
				Для исправления вышеуказанного прописываем поля в class RegisterUserForm - до class Meta - в forms.py, сразу добавим поле email
				<br>class RegisterUserForm - полностью:
				<pre>
# Форма регистрации
class RegisterUserForm(UserCreationForm):  # создаём экземпляр формы регистрации пользователя на базе UserCreationForm
    username = forms.CharField(label='Логин', widget=forms.TextInput(attrs={'class': 'form-input'}))
    email = forms.EmailField(label='Email', widget=forms.EmailInput(attrs={'class': 'form-input'}))
    password1 = forms.CharField(label='Пароль', widget=forms.PasswordInput(attrs={'class': 'form-input'}))
    password2 = forms.CharField(label='Повтор пароля', widget=forms.PasswordInput(attrs={'class': 'form-input'}))

    class Meta:
        model = User  # связь с моделью User (стандартная)
        # отображаем поля модели User
        # название полей - в админке - посмотреть код страницы - name
        fields = ('username', 'email', 'password1', 'password2')</pre>
        		Проверяем, вроде всё ок
			</li>
			<li>
				Улучшаем вид формы в шаблоне register.html, вместо вывода формы одной командой, выведем отдельные поля через цикл форм - чтобы вручную присвоить атрибуты внутри тегов
				<pre>
{{ form.as_p }} --> Удаляем
-->	
{% for f in form %}
&lt;p>
	&lt;label class="form-label" for="{{ f.id_for_label }}">{{f.label}}: &lt;/label>{{ f }}
&lt;/p>
&lt;div class="fo&lt;rm-error">{{ f.errors }}&lt;/div>
{% endfor %}</pre>
			</li>
			<li>
				Создадим - нового пользователя
				<br>Пароли для всех будут blog1234 - чтобы не запутаться
				Всё работает
			</li>
			<li>
				Тестируем ошибки - создадим ещё одного пользователя user1, с таким же emailom, пароли и проверка пароли разные
				<pre>
Пользователь с таким именем уже существует.
Введенные пароли не совпадают.</pre>
				Всё работает
			</li>
			<li>
				Создадим ещё одного пользователя user2
				<br>Просмотрим на них а админ панеле - пользователи
			</li>
			<li>
				<span class="spec">В документации изучить - как расширять стандартные модели User</span>
			</li>




			<br><br>
			<h4 class="title_text border">[20]. Делаем авторизацию пользователей на сайте.</h4>
			<li>
				Во views.py - пропишем новый класс представления, отвечающий за отображение формы авторизации
				<pre>
from django.contrib.auth.views import LoginView  # класс представления - авторизация
from django.contrib.auth.forms import AuthenticationForm  # форма аутентификации джанго

# Класс представления формы авторизации
# Логика работы базового класса LoginView + стандартная форма AuthenticationForm
class LoginUser(DataMixin, LoginView):
    form_class = AuthenticationForm  # форма стандартная форма django
    template_name = 'men/login.html'  # шаблон

    # формирование контекста для передачи в шаблон
    def get_context_data(self, *, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)
        c_def = self.get_user_context(title="Авторизация")
        return dict(list(context.items()) + list(c_def.items()))</pre>
			</li>
			<li>
				Создаём шаблон login.html - в men/templates/men, наследуемся от base.html - отображаем форму
				<pre>
{% extends 'men/base.html' %}

{% block content %}
&lt;h1>{{ title }}&lt;/h1>

&lt;form method="post">
	&lt;!-- # csrf_token - для защиты от csrf атак-->
	&lt;!-- # form.as_p - функция as_p() - отображает все поля формы -->
	{% csrf_token %}
	{% form.as_p %}

	&lt;!-- кнопка войти -->
	&lt;button type="submit">Войти&lt;/button>
&lt;/form>

{% endblock %}</pre>
			</li>
			<li>
				Связываем наш класс представления LoginUser - с url path - name='login'
				<br>В men/urls.py:
				<pre>path('login/', LoginUser.as_view(), name='login'),</pre> 
			</li>
			<li>
				Комментируем нашу функцию заглушки - Во views.py - def(login)
			</li>
			<li>
				Запускаем тестовый веб сервер - пробуем авторизоавться, залогиниваемся - и получаем ошибку 404 - наша форма по стандарту отправляет нас в - http://127.0.0.1:8000/accounts/profile/ - такой страницы у нас сейчас нету
				<br>Для изменения - в классе представления LoginUser - Добавим метод def_success_url (во views.py)
				<pre>
def get_success_url(self):
    return reverse_lazy('home') # после входа отправит домой</pre>
    			<span class="spec">Другой способ перенаправлять авторизованного пользователя на страницу - через settings.py</span>
    			<br>В самом низу settings.py добавляем
    			<pre>LOGIN_REDIRECT_URL = '/'  # При успешной аутентификации - перенаправление на home-page</pre>
			</li>
			<li>
				Улучшаем вид нашей формы, для этого в forms.py создаём новую форму
				<pre>
from django.contrib.auth.forms import AuthenticationForm

# Форма авторизации
class LoginUserForm(AuthenticationForm):
    username = forms.CharField(label='Логин', widget=forms.TextInput(attrs={'class': 'form.input'}))
    password = forms.CharField(label='Пароль', widget=forms.PasswordInput(attrs={'class': 'form.input'}))</pre>
			</li>
			<li>
				Во views.py - изменяем form_class - на нашу форму LoginUserForm
				<pre>form_class = LoginUserForm  # наша форма из forms.py</pre>
			</li>
			<li>
				В шаблоне login.html - в место вывода формы с помощью {{ form.as_p }} - выыедем её через цикл for - и зададим параметры
				<pre>
	&lt;!-- ошибки если неверный логин и пароль -->
	&lt;div class="form-error">
		{{ form.non_field_errors }}
	&lt;/div>

	&lt;!-- вывод Логин, Пароль и формы заполнения -->
	{% for f in form %}
	&lt;p>
		&lt;label class="form-label" for="{{ f.id_for_label }}">
			{{ f.label }}: 
		&lt;/label>
		{{ f }}
	&lt;/p>

	&lt;!-- ошибки если возникнут -->
	&lt;div class="form-error">
		{{ f.errors }}
	&lt;/div>
	{% endfor %}</pre>
				Тестируем по разному (неверный пароль), русские символы и тд
			</li>
			<li>
				Редактируем base.html - главное меню - залогиненому пользователю будем отображать Выйти и его имя - Для этого добавим конструкцию if  - в том месте где ссылки на войт|регистрация
				<pre>
{% if request.user.is_authenticated %}
&lt;li class="last"> {{ user.username }} | &lt;a href="{% url 'logout' %}">Выйти&lt;/a>&lt;/li>
{% else %}
&lt;li class="last">&lt;a href="{% url 'register' %}">Регистрация&lt;/a> | &lt;a href="{% url 'login' %}">Войти&lt;/a>&lt;/li>
{% endif %}</pre>

			</li>
			<li>
				Добаим маршрут 'logout' - в men/urls.py
				<pre>
path('logout/', LoginUser.as_view(), name='logout'),</pre>
			</li>
			<li>
				Создадим функцию представления logout_user 
				<br>Сразу поменяем маршрут в urls.py:
				<pre>
path('logout/', logout_user, name='logout'),</pre>
				<br>Во views.py - создаём функцию представления
				<pre>
from django.contrib.auth import logout

# функция представления - выхода из аккаунта
def logout_user(request):
    logout(request)
    return redirect('login') # перенаправляем на авторизацию</pre>
			</li>
			<li>
				<span class="spec">redirect делает перенаправление по сформированному маршруту, а reverse только формирует маршрут (без перенаправления)</span>
			</li>
			<li>
				Сделаем так что при успешной регистрации пользователя - он автоматически будет авторизовываться, для этого во views.py - в class RegisterUser - добавим метод form_valid
				<pre>
from django.contrib.auth import logout, login

# при успешной регистрации - автоматом залогинивает пользователя
def form_valid(self, form):
    user = form.save()  # сохраняем форму в БД
    login(self.request, user)  # авторизовывает пользователя
    return redirect('home')  # перенаправит домой</pre>
			</li>




			<br><br>
			<h4 class="title_text border">[21]. Оптимизация сайта с Django Debug Toolba</h4>
			<li>
				Критери работы web - приложения:
				<br>-скорость работы приложения
				<br>-нагрузка на СУБД (частоту и сложность запросов)
				<br>-корректность возвращаемых пользователю данных.
			</li>
			<li>
				Django Debug Toolbar - инструмент для анализа работы Web приложения
			</li>
			<li>
				Переходим <a href="https://pypi.org/">pypi.org</a>
				<br>В поиске вбиваем - django debug toolbar, открываем последнюю версию, и копируем команду для установки в терминале
			</li>

			<li>
				В терминале заходим в виртуальное окружение
				<pre>(venv2022) PS C:\Хранилище\IT\IT Разное\Обучение\YouTube_selfedu\djsite\coolsite> </pre>
				Устанавливаем инструмент
				<pre>pip install django-debug-toolbar</pre>
			</li>
			<li>
				'Прикручиваем' инструмент к нашему приложению  - для этого необходимо действовать по инструкции.
				<br>В settings.py - добавляем наше приложение - INSTALLED_APPS =[...] - после "django.contrib.staticfiles",
				<pre>
"debug_toolbar",  # добавили debug-toolbar</pre>
			</li>
			<li>
				В settings.py - TEMPLATES - APP_DIRS - проверим, должно стоять в положении True
				<pre>
'APP_DIRS': True,</pre>
			</li>
			<li>
				В settings.py - MIDDLEWARE - необходимо добавить строчку
				<pre>"debug_toolbar.middleware.DebugToolbarMiddleware",  # добавили debug-toolbar</pre>
			</li>
			<li>
				В settings.py - в конце добавим коллекцию
				<pre>
INTERNAL_IPS = [
    "127.0.0.1",
]</pre>
			</li>
			<li>
				В settings.py закончили
			</li>
			<li>
				Необходимо добавить маршрут для этого инструмента
				<br>Для этого в !! coolsite/urls.py - в if.DEBUG
				<pre>
# то есть в режиме отладки когда DEBUG = True
if settings.DEBUG:
    # для debug_toolbar
    import debug_toolbar
    urlpatterns = [
        path('__debug__/', include('debug_toolbar.urls')),
    ] + urlpatterns</pre>
			</li>
			<li>
				Запускаем тестовы web сервер - runserver и видим множество параметров
			</li>
			<li>
				Сейчас нам интересно количество SQL запросов, желательно избавится от дублей
				<pre>
 3 similar queries. Duplicated 3 times.</pre>
			</li>
			<li>
				Ленивый запрос (отложенный) - выполняются в момент непосредственного обращения данных, в нашем случае при выводе рубрик {{ p.cat }} - делает много дублей.  Категория: Актёры
			</li>
			<li>
				В django есть 2 метода:
				<br>-select_related(key) - 'жадная' загрузка связанных данных по внешнему ключу key, который имеет тип ForeignKey
				<br>-prefetch_related(key) - жадная' загрузка связанных данных по внешнему ключу key, который имеет тип ManyToManyField
			</li>
			<li>
				Используем select_related - во views.py - в class MenHome - в методе get_queryset
				<pre>return Men.objects.filter(is_publisher=True).select_related('cat')  # .select_related('cat') - оптимизация SQL запросов</pre>
				То есть с данными Men.objects.filter(is_publisher=True) - будут загруженны данные из таблицы Category (по нашему полю в men = cat)
				<br>cat  - связывает нашу вторичную модель Men - c первичной моделью Category
				<br><strong>После вышеуказанных манипуляций, количество SQL запросов сократилось с 12 до 3 - то есть мы убрали все дубликаты SQL запросов</strong>
			</li>
			<li>
				Аналогично поправим класс представления по категориям - в views.py - class MenCategory - def get_queryset:
				<pre>return Men.objects.filter(cat__slug=self.kwargs['cat_slug'], is_publisher=True).select_related('cat')  # оптимизация SQL</pre>
			</li>
			<li>
				В class MenCategory - остались ещё дубликаты, для этого немного подкорректируем get_context_data
				<pre>
c_def = self.get_user_context(title='Категория - ' + str(context['posts'][0].cat),  --> Удаляем	
--->
c = Category.objects.get(slug=self.kwargs['cat_slug'])
c_def = self.get_user_context(title='Категория - ' + str(c.name), cat_selected=c.pk)</pre>
			</li>




			<br><br>
			<h4 class="title_text border">[22]. Включаем кэширование данных</h4>
			<li>
				Операция по формированию страницы делается для каждого клиента, клиентов может быть тысячи, и сервер должен справляться со всеми запросами одновременно, для того чтобы разгрузить работу сервера - делают кэширование страниц, то есть при первой загрузке страницы клиентом, у него в браузер сохраняются некоторые данные страницы, что бы при повторном заходе на страницу - не было необходимости загружать её из сервера заново.
			</li>
			<li>
				Кэш можно реализовать на уровне:
				<br>-Паямяти
				<br>-БД (очень редко)
				<br>-Файлов (наиболее часто)
			</li>
			<li>
				Делаем кэширование на уровне файлов
				<br>Для начала добавляем CACHES - в settings.py - в самом низу
				<pre>
# кэширование на уровне файлов
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.filebased.FileBasedCache',
        'LOCATION': BASE_DIR / 'coolsite_cashe',  # где будет храниться кэш
    }
}</pre>
			</li>
			<li>
				После обязательно создаём эту папку BASE_DIR / 'coolsite_cashe'<br>
				...djsite/coolsite/coolsite-cache
			</li>
			<li>
				Делаем кэширование на уровне представления. Будем реальзовывать кэш на классах представления
				<br>Переходим в men/urls.py 
				<pre>
# импортируем декоратор
from django.views.decorators.cache import cache_page
				</pre>
				<br>Кэширеум домашнюю страницу
				<pre>
path('', MenHome.as_view(), name='home'),
-->					
path('', cache_page(60)(MenHome.as_view()), name='home'),
# 60 сегунд</pre>
			</li>
			<li>
				Запускаем сервер - при включённом debug - смортим количество sql запросов - 3 штуки, количество Кэш 3 шт
				<br>В течении 60 секунд обновляем и видим SQL 60сек  - Кэш 2. Т.Е. вся страница перезагрузилась из Кэша, никак не нагружая БД
			</li>
			<li>
				Можем вернуть path name='home' - в исходное стостояние, так как будем пробывать другой способ
				<pre>
path('', MenHome.as_view(), name='home'),</pre>
			</li>
			<li>
				Кэширование на уровне шаблонов, будем Кэшировать Sidebar - в base.html
				<br>В base.html 
				<pre>
{% load cache %}  # вверху или прям над sidebar	

{% cache 60 sidebar %}  # до циклов if-ов
#  60 - секунд,  sidebar - название кэша придумываем сами

{% endcache %}  # после вормирования sidebar</pre>
				сохраняем - делаем проверку
			</li>
			<li>
				Кэширование с использованием API низкого уровня
				<br>cache.set() cache.get() cache.add() cache.get_or_set() cache.delete()  cache.clear()
				<br>
				<img src="images\cache.jpg" class="img-fluid">
				<br>
			</li>
			<li>
				Будем делать (Кэширование с использованием API низкого уровня) - во utils.py - class DataMixin: - в def get_user_context(self, **kwargs): - после context = kwargs
				<pre>
from django.core.cache import cache

cats = cache.get('cats')  # вызываем cache, пытаемся прочитать из cats из кэша
if not cats: # если cats не были прочитаны
    #  читаем данные из БД
    cats = Category.objects.annotate(Count('men'))  # количество постов в каждой рубрике
    cache.set('cats', cats, 60)  # записываем кэш на 60 сек</pre>
			</li>
			<li>
				Иннструмент Кэширование стоит включать только на конечном этапе разработки сайта!
			</li>


			<br><br>
			<h4 class="title_text border">[23]. Использование капчи captcha</h4>
			<li>
				Комментируем функцию представления страницы Обратная связь - def contact(request): - во vievs.py
			</li>
			<li>
				Делаем класс представления для формирования этой страницы - во vievs.py
				<pre>
from django.views.generic import ..., FormView 

class ContactFormView(DataMixin, FormView):  # FormView - базовый класс - не привязан к модели
    form_class = ContactForm  # наш класс из form.py
    template_name = 'men/contact.html'  # ссылка на шаблон
    success_url = reverse_lazy('home')  # при успешном заполнении формы - направит домой

    def get_context_data(self, *, object_list=None, **kwargs):  # формируем context - для шаблона
        context = super().get_context_data(**kwargs)
        c_def = self.get_user_context(title='Обратная связь')
        return dict(list(context.items()) + list(c_def.items()))

    def form_valid(self, form):  # если пользователь правильно заполнит формы
        print(form.cleaned_data)
        return redirect('home')</pre>
			</li>
			<li>
				В forms.py прописываем форму ContactForm:
				<pre>
# форма контактов
class ContactForm(forms.Form):  # наследуемся от базового класса форма
    # поля формы
    name = forms.CharField(label='Имя', max_length=255)
    email = forms.EmailField(label='Email')
    content = forms.CharField(label='Контент', widget=forms.Textarea(attrs={'cols': 60, 'rows': 10}))</pre>
			</li>
			<li>
				Связываем маршрут path - name='contact' - с классом представления ContactFormView - в men/urls.py
				<pre>
path('contact/', ContactFormView.as_view(), name='contact'),</pre>
			</li>
			<li>
				Добавляем шаблон contact.html - в men/templates/men - наследуемся от base.html, csrf token - вызывваем форму через цикл:
				<pre>
{% extends 'men/base.html' %}

{% block content %}
&lt;h1>{{ title }}&lt;/h1>

&lt;form method="post">
	{% csrf_token %}
	&lt;div class="form-error">{{ form.non_field_errors }}&lt;/div>

	{% for f in form %}&lt;
	&lt;p>
		&lt;label class="form-label" for="{{ f.id_for_label }}">
			{{ f.label }}: 
		&lt;/label>
		{{ f }}
	&lt;/p>
	&lt;div class="form-error">{{ f.errors }}&lt;/div>
	{% endfor %}

	&lt;button type="submit">Отправить&lt;/button>
&lt;/form>

{% endblock %}</pre>
			</li>
			<li>
				Добавим капучу - графическую картинку с кодом, который необходимо ввести для отправки формы, делают её для защиты от ботов
			</li>
			<li>
				Переходим в pypi.org -  впоиске ищем - django-simple-captcha, открываем её - копируем код установки в терминал, устанавливаем в виртуальном окружении в терминале
				<pre>pip install django-simple-captcha</pre>
			</li>
			<li>
				По ссылке в pyorg - ищем документацию этого модуля и читаем её
			</li>
			<li>
				Добавляем в settings.py в коллекции INSTALLED_APPS - над нашим приложением
				<pre>'captcha',  # добавили каптчу</pre>
			</li>
			<li>
				далее необходимо выполнить миграцию, так как у каптчи есть своя модель которую необходимо внести в базу данных - можно делать сразу migrate (без makemigrations)
				<pre>python manage.py migrate</pre>
			</li>
			<li>
				Добавляем маршрут для каптчи - в глобальный urls.py - coolsite/coolsite/urls.py - в основном urlpatterns - добавим маршрут
				<pre>
path('captcha/', include('captcha.urls')),</pre>
				Теперь каптча привязана к нашему приложению и мы можем её применять
			</li>
			<li>
				Капчу необходимо использовать в форме, в forms.py - ContactForm дубем добавлять атрибут там где поля ввода
				<pre>
from captcha.fields import CaptchaField  # необходим импорт в forms.py

captcha = CaptchaField()					
				</pre>
			</li>
			<li>
				Мы можем менять отображение формы каптчи (размер шрифта, сам шрифт, цвет фона, свет текста - можно сделать даже собственное оформление и тд) - всегда необходимо читать жокументацию к приложению
			</li>


			<br><br>
			<h4 class="title_text border">[24]. Тонкая настройка админ панели</h4>
			<li>
				Настройка админ панели, по подробной настройке описано в документации django
			</li>
			<li>
				Меняем стиль админ панели - для того чтобы она была в тех же тонах что и наш основной сайт.
				<br>Запускаем сервер, заходим в админ панель, в debug-toolbar - ищем вкладку шаблоны и открываем  -  там видно, какие шаблоны используются для админки и видно пути к этим шаблонам
				<br>Например C:\\Хранилище\\IT\\IT Разное\\Обучение\\YouTube_selfedu\\djsite\\venv2022\\Lib\\site-packages\\django\\contrib\\admin\\templates\\admin\\index.html
			</li>
			<li>
				Мы можем открыть шаблон прямо по этому пути в виртуальном окружении, но так лечше не делать никогда! - все файл пакетов python, django и тд рекомендуется оставлять без изменения
				<br>По этому лучше сделать просто переопределение!
			</li>
			<li>
				В создаём новую папку в корне проекта djsite/coolsite/ - templates/admin
			</li>
			<li>
				Если в подкаталоге templates/admin - точно такой же шаблон base_site.html - то это файл будет переопределять файл из виртуального окружения!
			</li>
			<li>
				templates/admin - создаём новый шаблон - base_site.html
			</li>
			<li>
				В settings.py - прописываем путь к нестандартной дирректории шаблонов TEMPLATES - DIRS
				<pre>
'DIRS': [BASE_DIR / 'templates'],</pre>
				Перезапускаем сервер - заходим в админку и видим полностью пустую страницу, это означает что шаблон для отображения страницы админки уже берётся из нашего файла
			</li>
			<li>
				Копируем всё из шаблона вирутального окружения base_site.html - наш шаблон coolsite/templates/admin/base_site.html
				<pre>
{% extends "admin/base.html" %}

{% block title %}{% if subtitle %}{{ subtitle }} | {% endif %}{{ title }} | {{ site_title|default:_('Django site admin') }}{% endblock %}

{% block branding %}
&lt;h1 id="site-name">&lt;a href="{% url 'admin:index' %}">{{ site_header|default:_('Django administration') }}&lt;/a>&lt;/h1>
{% endblock %}

{% block nav-global %}{% endblock %}</pre>
				Заходим в админку, и видим что админка выглядит в полностью стандартном виде
			</li>
			<li>
				Из шаблона виртуального окружения base.html - копируем строчку кода и вставляем в наш шаблон base_site.html - над block title
				<pre>
{% block extrastyle %}

....будем добавлять стили

{% endblock %}</pre>
				Ту да же добавим ссылку на наши стили css admin.css (добавим позже), и загрузим наши статические файлы.
				<br>Получилось так
				<pre>
{% load static %}
{% block extrastyle %}
&lt;link rel="stylesheet" href="{% static 'css/admin.css' %}">
{% endblock %}</pre>
			</li>
			<li>
				В подкаталоге men/static - создаём папку css
			</li>
			<li>
				В men/static/css - создаём admin.css
			</li>
			<li>
				Загружаем наш сайт в Google Chrome - заходим в админку - пкм - посмотреть код страницы, в панели справа мы можем наволить мышку, и в сайте будет видно для чего какой элемент будет использован
			</li>
			<li>
				Наводим на id='header' - это назоловок - теперь чтобы обратится в нём в нашем css файле - пришем #header {..., ...,}
			</li>
			<li>
				В admin.css - сменим фор у пары элементов
				<pre>
#header, .module caption  {
    background: #5e3a00;
}</pre>
			</li>
			<li>
				Чтобы заменить сам заголовок - Администрирование Django - изменения лучше делать в python файлах
				<br>men/admyn.py в самом низу, просто допишем 2 параметра
				<pre>
# заголовки в админке
admin.site.site_title = 'Админ-панель Mello'
admin.site.site_header = 'Админ-панель Mello'</pre>
				Полный смписок необходимо смотреть в документации
			</li>
			<li>
				Отображение миниатюр картинок вместо ссылок на них в админ панеле
				<br>Для этого в admin.py в class MenAdmin(admin.ModelAdmin): - добавим метод для отображения html кода -
				<pre>
from django.utils.safestring import mark_safe

# отобажение миниматюр фото в админке
def get_html_photo(self, object):
    if object.photo:  # если фото есть
        return mark_safe(f"&lt;img src='{object.photo.url}' width=50>")  # mark_safe - не экранирует теги

list_display = ('id', 'title', 'time_create', 'photo', 'is_publisher') -->удаляем
--> 
list_display = ('id', 'title', 'time_create', 'get_html_photo', 'is_publisher')</pre>
				Можем сохранять, и смотреть. Если фото есть будет миниатюра, если фото нету будет прочерк
				<br>
				Там же добавим строчку чтобы вместо столбца под именем Get html photo - было миниатюра.
				<br>неже def get_html_photo внутри class MenAdmin
				<pre>get_html_photo.short_description = "Миниатюра"</pre>
			</li>
			<li>
				Так же отобразим миниатюру - во время редактирования поста
				<br>Для этого в admin.py - в class MenAdmin - добавим 2 атрибута
				<pre>
# список полей которые стоит отображать в форме редактирования
fields = ('title', 'slug', 'cat', 'content', 'photo', 'get_html_photo', 'is_publisher', 'time_create', 'time_update')
# не редактируемые поля (только после этой строчки можно добавить из в fields)
readonly_fields = ('time_create', 'time_update', 'get_html_photo')</pre>
				<br>Продублируем панель с кнопками сверху (удобно если не хочется проматывать вниз)
				<pre>save_on_top = True  # панель сверху(дубль)</pre>
			</li>


			<br><br>
			<h4 class="title_text border">[25]. Начинаем развертывание Django-сайта на хостинге</h4>
			Кратко
			<li>
				<a href="https://beget.com/ru">https://beget.com/ru</a>
			</li>
			<li>
				SSH ДОСТУП
			</li>
			<li>
				<img src="images\host.jpg" class="img-fluid">
			</li>
			<li>
				Устанавливаем локальную версию Python - которую использовали в виртуальном окружении проекта
			</li>
			<li>
				Far Manager - программа для работы с файлами на серваре/локальном ПК
			</li>
			<li>
				Слудуем инструкции хостинга
			</li>
			<li>
				После установки Python на сервере устанавливаем виртуальное окружение на сервере
			</li>
			<li>
				pip install django==4.1.12   -  установка django определённой версии, необходимо установить внутри виртуального окружения на сервере
			</li>
			<li>
				На сервере стартуем проект
			</li>
			<li>
				На сервере необходимо создать passenger_wsgi.py - для связи с проектом и сервером
			</li>
			<li>
				Настраиваем settings.py - на сервере
			</li>







			<br><br>
			<h4 class="title_text border">[26]. Завершаем развертывание Django-сайта на хостинге</h4>
			Кратко
			<li>
				На сервере необходимо в виртуальное окружение установить все пакеты которые используются в проекте
			</li>
			<li>
				<span class="spec">Получение списка всех покетов проекта! - pip freeze > requirements.txt</span>
				<br>На своём пк в терминале pycharm - внутри виртуального окружения
				<pre>pip freeze > requirements.txt</pre>
				<br>В корневом каталоге проекта создастся txt файл, содержащий все пакеты и версии необходимые для работы сатйта
				<pre>
asgiref==3.5.2
Django==4.1.3
django-debug-toolbar==3.7.0
django-ranged-response==0.2.0
django-simple-captcha==0.5.17
Pillow==9.3.0
psycopg2==2.9.5
pydevd==2.9.1
sqlparse==0.4.3
tzdata==2022.6</pre>
			</li>
			<li>
				requirements.txt - необходимо переместить на сервер - для дальнейшей установки всех необходимых пакетов (из списка можно удалить django - т.к его уже установили)
			</li>
			<li>
				Устанавливаем через SSH клиент, через доекер, и устанавливаем все пакеты, что указаны в txt - одной команды
			</li>
			<li>
				Устанавливаем MySQL клиент - если на хостинге такая БД
			</li>
			<li>
				Настраиваем settings.py на рервере
			</li>
			<li>
				Создаём базу данных на сервере, делаем миграции на сервере
			</li>
			<li>
				Для корректной отдачи статических файлов есть свои заморочки, либо их необходимо переместить в определённый каталог хостинга либо прописать путь в urls.py - где их искать 
			</li>
			<li>
				<span class="spec">Переносим записи из БД пк - в БД на сервере</span>
				<br>В локальном ПК - в терминале
				<pre>
python manage.py dumpdata > db.json  # перенос всех записей всех таблиц с пк в 1 файл</pre>
				<br>Но две таблицы будут личними, будут проблемы на сервере, по этому их необходимо исключить
				<br>Переносим все данные таблиц БД локального пк в 1 файл, кроме двух таблиц которые не нужно переносить. В терминале (venv2022) ..\djsite\coolsite>
				<pre>python manage.py dumpdata --exclude auth.permission --exclude conten
ttypes > db.json</pre>
				После этого должен создасться файл db.json - но скорее всего он создасться из SQlite - стандартной БД - необходимо посмотреть как сделать тоже самое для postgreSQL.
				<br>Хотя скорее всего всё получилось и этой командой мы взяли и запокавали файлы из postgress
			</li>
			<li>
				db.json необходимо перевести в кодировку UTF8
			</li>
			<li>
				db.json - копируем на хостинг
			</li>
			<li>
				Распаковываем данные db.json на сервере и заносим в БД уже на сервер
				<pre>
python manage.py loaddata db.json</pre>
			</li>
			<br>









		</ol><!-- общий список -->
	</div><!-- container-md all -->
&lt; &lt; &lt;

# Ctrl + Alt + L 


<!-- JS Bootstrap 5 -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-gtEjrD/SeCtmISkJkNUaaKMoLD0//ElJ19smozuHV6z3Iehds+3Ulb9Bn9Plx0x4" crossorigin="anonymous"></script>


</body>
</html>