<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- css bootstrap 5 -->
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x" crossorigin="anonymous">

	<title>Автоблог - конспект работы</title>

	<style type="text/css">
		
		pre{
			color: black;
			background: #ffe2e2;
			margin-right: 30px;
			margin-left: 15px;
			margin-bottom: 2px;
			margin-top: 5px;
		}
		
		.all{
			background: #003802;
			color: white;

		}

		.all_2{
			background: black;
			color: white;

		}
		
		body{
			background: #c1ffcb;
		}
		
		.spec {
			font-size: 18px;
			letter-spacing: .2em;
			font-weight: 500;
/*			text-transform: uppercase;*/
			color: #ff7575;
			margin-top: 15px;
			margin-bottom: 2px;
		}

		.title_text {
			letter-spacing: .1em;
			font-weight: 500;
			color: #f2cb71;
			font-size: 25px;

		}

	</style>


&lt; &lt; &lt;
</head>


<body>
<!-- 	<p><a href="https://www.youtube.com/@selfedu_rus">selfedu</a></p>
	<p><a href="https://www.youtube.com/watch?v=FyTL1bnUx5I&list=PLA0M1Bcd0w8xO_39zZll2u1lz_Q-Mwn1F">Django 3 для Python(плейлист)</a></p> -->
	<p><a href="https://proproprogs.ru/django">https://proproprogs.ru/django</a></p>
	<p><a href="https://django.fun/ru/articles/tutorials/">Статьи о Django</a></p>
	<p><a href="https://habr.com/ru/post/514348/">Шесть Python-пакетов, которые рекомендуется использовать в каждом веб-приложении на Django</a></p>
	<p><a href="https://django.fun/ru/docs/">Документация по фреймворку и библиотекам Django</a></p>
	<p><a href="https://translated.turbopages.org/proxy_u/en-ru.ru.5b0ed4c9-6378aa3f-3f4ce05c-74722d776562/https/hackr.io/blog/top-django-interview-questions-and-answers">50 лучших вопросов и ответов для интервью Django на 2022 год</a></p>
	<p><a href="https://pypi.org/">pypi.org</a></p>


	<div class="container-md all"><!-- container-md all ОБЩИЙ -->
		<h1 class="title_text border">Автоблог</h1><br>
		<hr>

		<!-- <img src="images\avtoblog\host.jpg" class="img-fluid"><br> -->



		<ol><!-- общий список -->


			<li>
				<span class="title_text">Старт проекта</span>
				<hr>
				<ol>

					<li>
						Сделал окружение
					</li>
					<li>
						Создаём Новый проект в PyCharm - C:\Хранилище\IT\IT Projects\avtoblog-project
						<br>Окружение venv_2022 - указывал путь к venv_2022\Scripts\python.exe
					</li>
					<li>
						Внутри окружения уже есть большинство пакетов которые будут необходимы:
						<br>-Pillow - для работы с изображениями
						<br>-django-crycpy-forms - использовал в eccomerce
						<br>-Django 4.1.3
						<br>-psycopg2 - для работы с PostgreSQL
						<br>-virtuslenv
						<br>-pip
						<br><br>Консоль работает, должно быть всё норм
					</li>
					<li>
						Стартую проект django
						<pre>django-admin startproject avtoblog</pre>
						<br>В ручную подкорректировал папки в проекте:
						<br>-IT Projects\avtoblog-project\avtoblog (manage.py в avtoblog, .idea - в avtoblog-project)
						<br>-В Pycharm - папке avtoblog-project - присвоил source root
					</li>
				</ol>
			</li>

			<li>
				<span class="title_text">Git, .gitignore, База данных, настройка времени языка</span>
				<hr>
				<ol>

					<li>
						Из <a href="www.toptal.com">www.toptal.com</a> генерируем .gitignore  - и помещаем в avtoblog-project
						<br>Раскомментируй .idea/ поставь сверху
					</li>
					<li>
						Создаём Базу данных DB - Для проекта в SQL Shell (PostgreSQL)
						<pre>
Server [localhost]:
Database [postgres]:
Port [5432]:
Username [postgres]:
Пароль пользователя postgres:blog1234

psql \! chcp 1251  # для отображении кириллицы
\l смортрим список всех DB
CREATE DATABASE avtoblogdb;  # создали базу данных - avtoblogdb
-->CREATE DATABASE
\l - смотрим DB создана
				</pre>
					</li>
					<li>
						Сразу привыязваем наш проект к базеданных postgreSQL - avtoblogdb - в settings.py
						<pre>
DATABASES = {
    'default': {
        # 'ENGINE': 'django.db.backends.sqlite3',  # стандартная БД
        # 'NAME': BASE_DIR / 'db.sqlite3',  # стандартная БД
        'ENGINE': 'django.db.backends.postgresql',  # БД PostrgeSQL
        'NAME': 'avtoblogdb',  # Имя нашей БД
        'USER': 'postgres',  # пользователь postgres - который создал БД
        'PASSWORD': 'blog1234',  # пароль в PostgreSQL, для пользователя postgres
        'HOST': '127.0.0.1',  # либо просто - 'localhost'
        'PORT': '5432',  # стандартный порт
    }
}</pre>
					</li>
					<li>
						В settings.py сразу настроим часовой пояс и русский язык в админке
						<pre>
LANGUAGE_CODE = 'ru-Ru'  # русский язык в admin

TIME_ZONE = 'Europe/Moscow'  # время по МСК</pre>
					</li>
					<li>
						На github - создадим репозиторий - avtoblog
					</li>
					<li>
						Инициализируем git репозиторий на PC, и запушим первый коммит
						<pre>
git –v  # посмотреть версию git
git init  # инициализируем git репозиторикй- папку на pc
git status  # смотрим какие файлы не отслеживаются на данный момент
git add .  # добавляем все файлы
git status  # смотрим что теперь всё отслеживается
git commit -m "имя коммита(что сделали/стадия)"  # создаём коммит
git remote add origin  - https://github.com/Mello134/репозиторий.git  # туда будем загружать
git branch -M main
git push -u origin main  # отправили на github - в репозитор</pre>
					</li>

				</ol>
			</li>


			<li>
				<span class="title_text"> Создание и регистрация приложения<br>Расшарение маршрутов urls.py [ inclide() ]</span>
				<hr>
				<ol>

				
					<li>
						Создаём приложение blog в avtoblog-project
						<pre>python manage.py startapp blog</pre>
					</li>
					<li>
						Регистрируем приложение blog в settings.py - INSTALLED_APPS. Информацию берём из blog/apps.py
						<pre>'blog.apps.BlogConfig',  # наше приложение blog</pre>
					</li>
					<li>
						Создадим urls.py в blog в него сразу импортируем path и views.py
						<pre>
from django.urls import path
from .views import *</pre>
						Создаём свой список urlpatterns, запишим первый путь
						<pre>
urlpatterns = [
    path('', home, name='home'),
]</pre>
					</li>
						Расширим основной avtoblog/urls.py  + avtoblog/urls.py (include)
						<br>Для этого добавляем маршрут к urls.py из blog  + имортируем include()
						<pre>
from django.urls import path, include

path('', include('blog.urls')),  # путь к путям приложения blog
				</pre>

				</ol>
			</li>

			

			<li>
				<span class="title_text">Первые функции представления (заглушки) - первые маршруты, динамические маршруты по id</span>
				<hr>
				<ol>

					<li>
						Создадим первую функцию представления во blog/views.py
						<pre>
from django.http import HttpResponse
						</pre>
					</li>
					<li>
						Добавим две функции представления категорий и отдельной машины. В blog/views.py
						<pre>
# страница категорий
def categories(request):
    return HttpResponse('Страница категорий')


# страница отдельной машины
def car(request):
    return HttpResponse('Страница отдельной машины')</pre>
					</li>
					<li>
						Сразу пропишем маршруты к ним в url.py
						<pre>
path('category/', categories, name="category"),
path('car/', car, name='car'),</pre>
					</li>
					<li>
						Увеличим функции представления и маршруты catregory/1-2-3.. и car/1-2-3
						<br>Во views.py
						<pre>
# страница категорий
def categories(request, category_id):  # в скобках то что получаем в запросе
    # в return то что отдаём для отображения
    return HttpResponse(f'&lt;h1>Страница категорий&lt;/h1>&lt;p>№ {category_id}&lt;/p>')


# страница отдельной машины
def car(request, car_id):
    return HttpResponse(f'&lt;h1>Страница отдельной машины&lt;/h1>&lt;p>№ { car_id }&lt;/p>')</pre>
						<br>В urls.py
						<pre>
path('category/&lt;int:category_id>/', categories, name="category"),
path('car/&lt;int:car_id>/', car, name='car'),</pre>
					</li>
					<li>
						<span class="spec">Искочения и 404 не далал на данном этапе. П33 КОНСПЕКТА SELFEDU</span>
					</li>

				</ol>
			</li>



			
			<li>
				<span class="title_text">Модели, миграции, суперпользователь, регистрация моделей в админке</span>
				<hr>
				<ol>

					<li>
						Пропишим 2 модели Сar, Category в models.py
						<pre>
class Car(models.Model):
    # Id прописывать не нужно - Model Это делает автоматически
    title = models.CharField(max_length=255, verbose_name='Заголовок')  # длина 255 символов
    # unique=True - поле уникально, db_index=True - индексируемое (для ускорения поиска, verbose_name - отображение в адм.)
    slug = models.SlugField(max_length=255, unique=True, db_index=True, verbose_name='URL')
    content = models.TextField(blank=True, verbose_name='Текст статьи')  # текстовое поле без ограничений, blank=True - поле может быть пустым
    tth = models.TextField(blank=True, verbose_name='Технические характеристики авто')
    photo = models.ImageField(upload_to='photos/%Y/%m', verbose_name='Фото')  # загружать будем в photos/год/месяц
    time_create = models.DateTimeField(auto_now_add=True, verbose_name='Время создания')
    time_update = models.DateTimeField(auto_now=True, verbose_name='Время изменения')
    is_published = models.BooleanField(default=True, verbose_name='Публикация')  # default=True
    # cat_id - id добавится автоматом, ForeignKey - связь Car - c Category
    cat = models.ForeignKey('Category', on_delete=models.PROTECT, verbose_name='Категории')


class Category(models.Model):
    # db_index - для того чтобы поле было индексированным, поиск по небу будет происходить быстрей
    name = models.CharField(max_length=100, db_index=True, verbose_name='Категория')
    slug = models.SlugField(max_length=255, unique=True, db_index=True, verbose_name='URL')</pre>
					</li>
					<li>
						Сделаем первую миграцию и применим её - без этого путь admin не работает!
						<pre>
python manage.py makemigrations
python manage.py migrate</pre>
					</li>
					<li>
						Создадим superuser
						<pre>
python manage.py createsuperuser  # создаём суперюзера

Имя пользователя: Mello
Адрес электронной почты: elproject220@yandex.ru
Password:blog1234
Password (again):blog1234
Superuser created successfully.  # пользователь создан</pre>
					</li>
					<li>
						Зарегистрируем наши модели в админке. в blog/admin.py
						<pre>
admin.site.register(Car)
admin.site.register(Category)</pre>
					</li>
				</ol>
			</li>



			<li>
				<span class="title_text">MEDIA_ROOT, MEDIA_URL, STATIC_URL, STATIC_ROOT, STATICFILES_DIRS, if settings.DEBUG:</span>
				<hr>
			
				<ol>

					<li>
						Настраиваем MEDIA_ROOT - MEDIA_URL в settings.py
						<pre>
MEDIA_ROOT = BASE_DIR / 'media'  # будет загружать медиа в папку media
MEDIA_URL = '/media/'  # добавили url - будет отображаться в браузере</pre>
			</li>
					<li>
						Для эмуляции работы сервер для получения ранее загруженных файлов, и передачи их нашему приложению.
						<br>В avtoblog/urls.py добавим маршруты к статическим файлам и к медиафайлам
						<pre>
from django.conf.urls.static import static  # пути к статическим файлам
from . import settings  # для MEDIA_URL MEDIA_ROOT

if settings.DEBUG:
    # к путям добавляем путь к статическим данным, графическим данным
    # на реальных серверах обычно это не используется
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)</pre>
					</li>
					<li>
						Настраиваем STATIC_URL STATIC_ROOT STATICFILES_DIRS
						<br>-STATIC_URL - префикс URL-адреса
						<br>-STATIC_ROOT - путь к общей статической папке, используемый реальым веб-сервером
						<br>-STATICFILES_DIRS - список дополнительных(нестандартных) путей к статическим файлам, используемых для сбора и для рещима отладки
						<br><br>в settings.py
						<pre>
STATIC_URL = 'static/'  # стандартно
# STATIC_ROOT добавили, в эту папку при collectstatic - django перемещает все статические файлы
# путь avtoblog-project/avtoblog - из этой папке, статический файлы будут пользоваться в режиме эксплуатации сайта на сервере
STATIC_ROOT = BASE_DIR / 'static'
# добавили пустой список, список нестандартных путей, пока у нас нет, оставим пустым
STATICFILES_DIRS = []</pre>
					</li>
				</ol>
			</li>



			
			<li>
				<span class="title_text">Папки статических фалов, первые шаблоны, base.html, функции представления, context, {% load static %}, {% extends 'blog/base.html' %}, Bootstrap5</span>
				<hr>

				<ol>


					<li>
						Создам вручную папку для статических фалов. В blog:
						<br>blog/static
						<br>blog/static/blog
						<br>blog/static/blog/css 
						<br>blog/static/blog/images - туда буду загружать иконки
						<br>blog/static/blog/js
					</li>
					<li>
						Создам файл стилей styles.css - в blog/static/blog/css 
					</li>
					<li>
						Создам вручную папку для шаблонов фалов. В blog:
						<br>blog/templates
						<br>blog/templates/blog
					</li>
					<li>
						Создам base.html - в blog/templates/blog
					</li>
					<li>
						Привяжу функцию представления def home - к base.html, в vievs.py
						<pre>
# домашняя страница
def home(request):
    context = {
        'title': 'Базовый шаблон',
        'ключ 2': 'Значение2',        
    }
    return render(request, 'blog/base.html', context=context)</pre>
					</li>
					<li>
						В base.html  - чтото напишу для проверки
						<pre>
&lt;!DOCTYPE html>
&lt;html>
&lt;head>
	&lt;meta charset="utf-8">
	&lt;meta name="viewport" content="width=device-width, initial-scale=1">
	&lt;title>{{ title }}&lt;/title>
&lt;/head>
&lt;body>
	&lt;h1>{{ title }}&lt;/h1>
&lt;/body>
&lt;/html></pre>
					</li>
					<li>
						Далее верстаю страницу base.html, Добавляю bootstrap, ссылку на css, подкгружаю статические файлы - В base.html - будет navbar, sidebar, footer
				<pre>
---в самом верху---
{% load static %}

---до title, в head---
ссыылка BOOTSTRAP CSS -->
ссыылка к нашему css файлу -->
ссылка для отображении иконки в браузере (где title) -->

---в title---
{% block title %} {% endblock %}

---до закрытия body---
ссыылка BOOTSTRAP JS --></pre>
					</li>
					<li>
						Сделал навбар, сайдбар и футер в base.html - указал промежуток {% block content %}
					</li>
					<li>
						Создал home.html в нём унаследовался от base.html - указал block kontent с минимальным содержимым
						<pre>
{% extends 'blog/base.html' %} 

{% block title %} 
	{{ title }}
{% endblock %}

{% block content %}
&lt;h1>{{ title }}&lt;/h1>
&lt;p>{{ key_2 }}&lt;p>
{% endblock %}</pre>
					</li>
					<li>
						Подгорректировал def home во views.py
						<pre>
# домашняя страница
def home(request):
    context = {
        'title': 'Главная страница',
        'key_2': 'Значение2',
    }
    return render(request, 'blog/home.html', context=context)</pre>
					</li>
				</ol>
			</li>



			<li>
				<span class="title_text">Методы __str__, class Meta:</span>
				<hr>

				<ol>


					<li>
						Пропишим метод __str__ в моделях Car, Category - чтобы при обращении к категории или посту нам отображался title Car, name - Category
						<pre>
--class Car--
# с помощью метода запись нашего класса будет выводиться по её заголовку
def __str__(self):
    return self.title

--class Category--
# будем обращаться к категории по полю name
def __str__(self):
    return self.name</pre>
					</li>
					<li>
						В модели дпбавим класс Meta - для нормального отображенияв админ панели и сортировки
						<pre>
--class Car--
class Meta:
    verbose_name = "Автомобиль"
    verbose_name_plural = "Автомобили"
    ordering = ['-time_create', 'title']  # сортировка, сначала по дате создания, потом по имени

--class Category--
class Meta:
    verbose_name = "Категория"
    verbose_name_plural = "Категории"
    ordering = ['id']  # сортировка, сначала по id</pre>
					</li>
				</ol>
			</li>



			<li>
				<span class="title_text">Отображение в админке/настройка</span>
				<hr>
				<ol>


					<li>
						Отобразим на нормальном языке наше приложение в админке
						<br>В blog/apps.py - class BlogConfig - добавим 1 поле
						<pre>verbose_name = 'Авто блог'  # отображение названия приложения</pre>
					</li>
					<li>
						Добавим пару записей в категорию и посты
					</li>
					<li>
						Для отображения столбцов в админ панеле в admin.py добавим классы, и опишем их
						<pre>
class CarAdmin(admin.ModelAdmin):
    # список отображаемых столбцов в админ-панели
    list_display = ('id', 'title', 'time_create', 'photo', 'is_published')
    prepopulated_fields = {'slug': ('title',)}  # автозаполнение слага по имени поста
    # список полей на которые можно кликнуть - для редактирования
    list_display_links = ('id', 'title')
    # список полей - ко которым можно вести поиск
    search_fields = ('title', 'content')
    # редактирование поля публикации - в списке - в админке
    list_editable = ('is_published',)  # запятая - если 1 поле!
    # фильтр по полям - публикация, время изменения.
    list_filter = ('is_published', 'time_create')</pre>
		    			<pre>
class CategoryAdmin(admin.ModelAdmin):
    prepopulated_fields = {'slug': ('name',)}  # автозаполнение слага по имени категории
    list_display = ('id', 'name')
    list_display_links = ('id', 'name')
    search_fields = ('name',)  # ЗАПЯТАЯ В КОНЦЕ- при одном поле</pre>
		    			<pre>
admin.site.register(Car, CarAdmin)
admin.site.register(Category, CategoryAdmin)</pre>
					</li>
					<li>
						<span class="spec">get_html_photo</span><br>
						Для отображения миниатюр фото вместо ссылки на фото добавим метод get_html_photo (назвали сами) - там же в class CarAdmin(admin.ModelAdmin):
						<pre>
from django.utils.safestring import mark_safe

list_display = ('id', 'title', 'time_create', 'get_html_photo', 'is_published')

# отображение миниатюр фото в админке
    def get_html_photo(self, object):
        if object.photo:  # если фото есть
            # mark_safe - не экранирует теги
            return mark_safe(f"}&lt;img src='{object.photo.url}' width=50>")</pre>
					</li>
				</ol>
			</li>



			<li>
				<span class="title_text">Страницы отдельного поста, get_absolute_url, динамический марщрут по слагу</span>
				<hr>
				<ol>

					<li>
						Создам шаблон для отображения 1 поста car.html, наследуюсь от base.html
						<pre>
{% extends 'blog/base.html' %} 

{% block title %} 
	{{ title }}
{% endblock %}

{% block content %}
&lt;h1>{{ title }}&lt;/h1><
{% endblock %}</pre>
					</li>
					<li>
						Изменю функцию представления def car
						<pre>
# страница отдельной машины
def car(request, car_slug):
    car = Car.objects.get(slug=car_slug)
    context = {
        'car': car,
    }
    return render(request, 'blog/car.html', context=context)</pre>
					</li>
					<li>
						Добавлю метод get_absolute_url - для Модели Car - для получения маршрута по слагу
						<pre>
from django.urls import reverse

# функция формирования маршрута к ссылке
def get_absolute_url(self):  # self - ссылка на один экземпляр(строку) таблицы модели
    # получаем путь('path name=car, 'car/&lt;slug:car_slug>/) = 127/car/supra)
    return reverse('car', kwargs={'car_slug': self.slug})  # self.slug - атрибут slug</pre>
			</li>
					<li>
						Изменяем маршрут в urls.py  name='car'
						<pre>
path('car/&lt;slug:car_slug>/', car, name='car'),</pre>
					</li>
					<li>
						Отображаю все поля на в шаблоне car.html
						<pre>
{% extends 'blog/base.html' %} 

{% block title %} 
	{{ car.title }}
{% endblock %}

{% block content %}

&lt;h1>{{ car.title }}&lt;/h1>
{% if post.photo %}
&lt;img src="{{ car.photo.url }}" class="img-fluid">&lt;br>
{% endif %}

&lt;p>Производство: {{ car.cat }}&lt;/p>
&lt;h3>Технические характеристики&lt;/h3>
&lt;p>{{ car.tth|linebreaks}}&lt;/p>&lt;br>
&lt;h3>Описание модели&lt;/h3>
&lt;p>{{ car.content|linebreaks }}&lt;/p>&lt;br>
&lt;p>Время обновления поста: {{ car.time_update }}&lt;/p>
&lt;
{% endblock %}</pre>
					</li>
					<li>
						Занимаемся оформлением шаблона car.html
					</li>
				</ol>
			</li>



			<li>
				<span class="title_text">
					Вывод всех записей и запизей по поределённому фильтру (категории) - в один шаблон, по разным функциям представления. (home / categories)
				</span>
				<hr>
				<ol>

					<li>
						Делаем отображение на главной странице (будут показывать все записи в модели)
					</li>
					<li>
						Во views.py - передаём в шаблон, все записи модели Car - в функции представления
						<pre>
# домашняя страница
def home(request):
    cars = Car.objects.all()
    context = {
        'title': 'Главная страница',
        'cars': cars,
    }
    return render(request, 'blog/home.html', context=context)</pre>
					</li>
					<li>
						Выводим все записи в шаблоне home.html
						<br>Оформляем шаблон home.html
					</li>
					<li>
						Пишем get_absolute_url - Category  - по слагу - в models.py
						<pre>
# функция формирования маршрута к ссылке
def get_absolute_url(self):
    return reverse('category', kwargs={'cat_slug': self.slug})</pre>
					</li>
					<li>
						Меняем маршрут по слагу urls.py
						<pre>path('category/&lt;slug:cat_slug>/', categories, name="category"),</pre>
					</li>
					<li>
						Меняем функцию представления views.py
						<pre>
# вывод записей Car - по выбранной категории
def categories(request, cat_slug):  # в скобках то что получаем в запросе
    # cat__slug - обращение из модели Car - к полю slug модели Category
    # cat_slug - значение поля slug - выбранной категории - см get_abs_url Category
    cars = Car.objects.filter(cat__slug=cat_slug)
    context = {
        'title': f'Производство: {category_1}',
        'cars': cars,
    }
    return render(request, 'blog/home.html', context=context)</pre>
					</li>
					<li>
						Выводим информацию в шаблон - в home.html
						<br>Ничего менять не нужно - будут отображаться только выбранные по категории авто
					</li>
				</ol>
			</li>	



			<li>
				<span class="title_text">Sidebar, cat_selected, Вывод категорий в панель навигации из бады данных</span>
				<hr>
				<ol>

					<li>
						Sidebar вывожу в отдельный шаблон sidebar.html
						<br>Просто удаляю всё из base.html - переношу в sidebar.html
						<br>В base.html - 1 строка в нужном месте
						<pre>{% include 'blog/sidebar.html' %}</pre>
					</li>
					<li>
						Выводим категории (ссылки в sidebar)
						views.py  - создаём переменную all_categories - выше всех функций представления
						<pre>
		all_categories = Category.objects.all()</pre>
						<br>В context - Каждой функции представления добавим all_categoryies - чтобы при "вызове" функции представления на html - страницах отображались категории
						<pre>
# домашняя страница
def show_home(request):
    cars = Car.objects.all()
    context = {
        'cat_selected': 'all',
        'all_categories': all_categories,
        'title': 'Все модели',
        'cars': cars,
    }
    return render(request, 'blog/home.html', context=context)


# вывод записей Car - по выбранной категории
def show_categories(request, cat_slug):  # в скобках то что получаем в запросе
    # cat__slug - обращение из модели Car - к полю slug модели Category
    # cat_slug - значение поля slug - выбранной категории - см get_abs_url Category
    cars = Car.objects.filter(cat__slug=cat_slug)
    category_1 = Category.objects.get(slug=cat_slug)
    context = {
        'all_categories': all_categories,
        'cat_selected': category_1.slug,
        'title': f'Производство: {category_1}',
        'cars': cars,
    }
    return render(request, 'blog/home.html', context=context)


# страница отдельной машины
def show_car(request, car_slug):
    car = Car.objects.get(slug=car_slug)
    context = {
        'all_categories': all_categories,
        'car': car,
    }
    return render(request, 'blog/car.html', context=context)</pre>
					</li>
					<li>
						В шаблоне sidebar.html  - сделаем вывод всех категорий, через цикл фор, так же добавим конструкцию if (сравниваем cat_selected) -  для отображания ссылки в виде активной ссылки либо в виде уже выбранной категории, причем будем сравнивать отдельно для кнопки  Все категории, и отдельно для остальных категорий
						<pre>
{% if cat_selected != 'all' %}
&lt;li class="nav-item">
&lt;a class="nav-link active" aria-current="page" href="{% url 'home' %}">Все категории&lt;/a>
&lt;/li>
{% else %}
&lt;li class="nav-item">
&lt;a class="nav-link disabled" href="{% url 'home' %}" tabindex="-1" aria-disabled="true">Все категории&lt;/a>
&lt;/li>
{% endif %}	


{% for category in all_categories %}


{% if cat_selected == category.slug %}
&lt;li class="nav-item">
&lt;a class="nav-link disabled" href="{{ category.get_absolute_url }}" tabindex="-1" aria-disabled="true">{{ category.name }}&lt;/a>
&lt;/li>
{% else %}
&lt;li class="nav-item">
&lt;a class="nav-link" href="{{ category.get_absolute_url }}">{{ category.name }}&lt;/a>
&lt;/li>
{% endif %}

{% endfor %}</pre>
					</li>
				</ol>
			</li>




			<li>
				<span class="title_text">Динамический маршрут с двумя слагами (cat_slug/car_clug)<br>Делаю путь для отдельной машины - http://127.0.0.1:8000/category/japan/nissan-silvia-s14</span>
				<hr>
				<ol>
					<li>
						Самое важное, models.py - class Car - get_absolute_url
						<pre>
def get_absolute_url(self):
    return reverse('car', kwargs={'cat_slug': self.cat.slug, 'car_slug': self.slug})</pre>
    					<strong>ПОРЯДОК cat_slug/car_slut - важен, точно такой эе как и в маршруте!</strong>
					</li>
					<li>
						Меняем маршрут urls.py
						<pre>path('category/&lt;slug:cat_slug>/&lt;slug:car_slug>', show_car, name='car'),</pre>
					</li>
					<li>
						Меняем функцию представления для отдельной машины
						<br><strong>на входе необходимо принимать как car_slug так и cat_slug</strong>
						<br>car/cat_slug - это ключи в get_absolute_url - models.py - class Car
						<pre>
# страница отдельной машины
def show_car(request, car_slug, cat_slug):
    car = Car.objects.get(slug=car_slug)
    context = {
        'all_categories': all_categories,
        'car': car,
    }
    return render(request, 'blog/car.html', context=context)</pre>
					</li>
					<li>
						Всё работает! Но последним штрихом def show_car - добавлю cat_selected в context
						<pre>
# страница отдельной машины
def show_car(request, car_slug, cat_slug):
    car = Car.objects.get(slug=car_slug)
    context = {
        'cat_selected': cat_slug,
        'all_categories': all_categories,
        'car': car,
    }
    return render(request, 'blog/car.html', context=context)</pre>
					</li>
				</ol>
			</li>

		

			<li>
				<span class="title_text">Делаем пагинацию главной страницы и отображения категорий</span>
				<hr>
				<ol>
					<li>
						View.py
						<pre>
from django.core.paginator import Paginator

# домашняя страница
def show_home(request):
    cars = Car.objects.all()

    paginator = Paginator(cars, 4)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    context = {
        'page_obj': page_obj,
        'cat_selected': 'all',
        'all_categories': all_categories,
        'title': 'Все модели',
        # 'cars': cars,
    }
    return render(request, 'blog/home.html', context=context)

# вывод записей Car - по выбранной категории
def show_categories(request, cat_slug):  # в скобках то что получаем в запросе
    # cat__slug - обращение из модели Car - к полю slug модели Category
    # cat_slug - значение поля slug - выбранной категории - см get_abs_url Category
    cars = Car.objects.filter(cat__slug=cat_slug)
    category_1 = Category.objects.get(slug=cat_slug)

    paginator = Paginator(cars, 2)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    context = {
        'page_obj': page_obj,
        'all_categories': all_categories,
        'cat_selected': cat_slug,
        'title': f'Производство: {category_1}',
        # 'cars': cars,
    }
    return render(request, 'blog/home.html', context=context)</pre>
					</li>
					<li>
						В шаблоне home.html - для отображения кнопок (делал bootstrap) - из коробки html тоже приемлимый вид
						<pre>
	&lt;div class="pagination justify-content-center">
    	&lt;span class="step-links">
    		&lt;ul class="pagination justify-content-center ">
    	
	    	{% if page_obj.has_previous %}
	    		&lt;&lt;li>
	            	&lt;&lt;a class="page-link bg-dark"  href="?page=1">&laquo; Первая&lt;&lt;/a>
	            &lt;&lt;/li>
	            &lt;&lt;li>
	            	&lt;&lt;a class="page-link bg-dark" href="?page={{ page_obj.previous_page_number }}">Предыдущая&lt;&lt;/a>
	            &lt;&lt;/li>
	        {% endif %}&lt;&lt;

	        &lt;li class="page-item disabled">
		        &lt;span class="page-link bg-dark">
		            Страница {{ page_obj.number }} из {{ page_obj.paginator.num_pages }}.
		        &lt;/span>
		    &lt;/l&lt;i>


	        {% if page_obj.has_next %}
	        	&lt;li>
	            	&lt;a class="page-link bg-dark" href="?page={{ page_obj.next_page_number }}">Следующая&lt;/a>
	            &lt;/li>&lt;
	            &lt;li>	
	            	&lt;a class="page-link bg-dark" href="?page={{ page_obj.paginator.num_pages }}">Последняя &raquo;&lt;/a>
	            &lt;/li>
	        {% endif %}
	        &lt;/ul>
    	&lt;/span>
    &lt;/div></pre>
				</ol>
			</li>




			<li>
				<span class="title_text">Регистрация пользователя</span>
				<hr>
				<ol>
					<li>
						В base.html - делаю ссылки для регистрация и войти
						<pre>
&lt;span class="navbar-text">
	&lt;a class="nav-link active" href="{% url 'register' %}">Регистрация&lt;/a> | 
	&lt;a class="nav-link active" href="{% url 'login' %}">Войти&lt;/a>
&lt;/span></pre>
					</li>
					<li>
						Прописываем марщруты в urls.py
						<pre>
path('', show_login, name='login'),
path('', RegisterUser.as_view(), name='register'),</pre>
					</li>
					<li>
						Создаю шаблоны login.html +  register.html - в них наследуюсь от base.html
						<pre>
{% extends 'blog/base.html' %} 

{% block title %} 
	Регистрация пользователя
{% endblock %}

{% block content %}

Форма для регистрации

{% endblock %}</pre>
						Аналогично для формы аутентификации
					</li>
					<li>
						Создам класс Mixin - для формирования первоначальных контектсов всех функций представления, в будущем перейду на них
					</li>
					<li>
						в avtoblog-project/blog создам utils.py - и добавим Mixin для формирования общего контекста
						<pre>
from blog.models import Category  # наша модель

all_categories = Category.objects.all()  # общий для всех список в sidebar


# общий класс
class DataMixin:
    # формируем общий контекст
    def get_user_context(self, **kwargs):
        # контекст будет словарём {'ключ':'значение'}
        context = kwargs
        # в словарь контекст добавили { 'all_categories' : Category.objects.all()}
        context['all_categories'] = all_categories
        # if 'cat_selected'
        return context</pre>
					</li>
					<li>
						Деляю класс представления для регистрации пользователя во views.py - перед этим импортировав всё что нужно
						<pre>
from django.views.generic import CreateView  # класс представления
from django.contrib.auth.forms import UserCreationForm  # форма django
from django.urls import reverse_lazy  # перенаправление на маршрут
from .utils import DataMixin  # наш Mixin


# класс представления RegisterUser
class RegisterUser(DataMixin, CreateView):
    form_class = UserCreationForm  # стандартная форма django
    template_name = 'blog/register.html'  # шаблон куда передаём
    success_url = reverse_lazy('login')  # При успешной регистрации направит path 'login'

    # формируем полный словарь context
    def get_context_data(self, object_list=None, **kwargs):
        # берём контекст из этого класса представления
        context = super().get_context_data(**kwargs)  # на данный момент form_class
        # берём контекст из DataMixin - и в него сразу добавляем title
        c_def = self.get_user_context(title='Регистрация')
        # передаём в шаблон общий контекст (RegisterUser + DataMixin)
        return {**context, **c_def}
        # или
        # return dict(list(context.items()) + list(c_def.items()))</pre>
					</li>
					<li>
						В шаблоне register.html - выведем стандартную форму django
						<pre>
{% block content %}

&lt;form method="post">
	{% csrf_token %}
	{{ form.as_p }}
	&lt;button type="submit">
		Зарегистрироваться
	&lt;/button>
&lt;/form>	
{% endblock %}</pre>
						Форма уже рабочая но фид у неё так себе
					</li>
					<li>
						Создадим свою форму (на основе стандартной просто изменим вид, отцентруем и так далее).
						<br>Формы будем создавать в отдельном файле - создаём blog/forms.py
					</li>
					<li>
						В forms.py - создаём свою форму на основе стандартной формы django - UserCreationForm
						<pre>
from django.contrib.auth.forms import UserCreationForm  # стандартная форма django
from django.contrib.auth.models import User  # из djando достаём записи модели User (все пользователи)
from django import forms  # модуль forms - для написания полей


# форма регистрации
class RegisterUserForm(UserCreationForm):
    # прописываем все необходимые поля, самостоятельно
    # тк django в meta их не видит почему-то без этого
    # название полей можно посмотреть в коде html - или в документации
    username = forms.CharField(label='Логин', widget=forms.TextInput(attrs={'class': 'form-input'}))
    email = forms.EmailField(label='Email', widget=forms.EmailInput(attrs={'class': 'form-input'}))
    password1 = forms.CharField(label='Пароль', widget=forms.PasswordInput(attrs={'class': 'form-input'}))
    password2 = forms.CharField(label='Повтор пароля', widget=forms.PasswordInput(attrs={'class': 'form-input'}))

    class Meta:
        model = User  # связываемся с моделью User
        # отображаем поля модели User
        fields = ('username', 'email', 'password1', 'password2')</pre>
					</li>
					<li>
						Во views.py изменим  в классе представление связь с формой - class RegisterUser - form_class = RegisterUserForm
						<pre>
from .forms import *  # наш forms.py

form_class = RegisterUserForm  # наша форма из forms.py</pre>
						Форма работает, но вид можно ещё улучшить
					</li>
					<li>
						В styles.css  - добавим стилей form-label/form-input/form-error/form-button
						<br>Отступы, размеры, цыет, выравнивание а такдалее
					</li>
					<li>
						Улучшаем вид в register.html - будем выводить все поля через цикл for
						<pre>
{% for f in form %}
&lt;p>
&lt;label class="form-label" for="{{ f.id_for_label }}">{{f.label}}: &lt;/label>{{ f }}
&lt;/p>
&lt;div class="form-error">{{ f.errors }}&lt;/div>
{% endfor %}</pre>
						Форма рабочая, с подобающим видом
					</li>

				</ol>
			</li>



			<li>
				<span class="title_text">Делаю авторизацию пользователя (login+logout)</span>
				<hr>
				<ol>
					<li>
						Сразу создам свою форму аутентификации в forms.py на основе стандартной формы AuthenticationForm, пропишем 2 поля логин и пароль
						<pre>
from django.contrib.auth.forms import AuthenticationForm  # стандартные формы

# Форма авторизации
class LoginUserForm(AuthenticationForm):  # AuthenticationForm - стандартная форма
    username = forms.CharField(label='Логин', widget=forms.TextInput(attrs={'class': 'form.input'}))
    password = forms.CharField(label='Пароль', widget=forms.PasswordInput(attrs={'class': 'form.input'}))</pre>
					</li>
					<li>
						Во views.py - сделю класс представления авторизацтт
						<pre>
from django.contrib.auth.views import LoginView  # стандартная логика авторизации

# Класс представления формы авторизации
# Логика работы базового класса LoginView + сама форма LoginUserForm
class LoginUser(DataMixin, LoginView):
    form_class = LoginUserForm  # наша форма из forms.py
    template_name = 'blog/login.html'  # шаблон
    
    # формируем полный контекст
    def get_context_data(self, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)  # распаковываем изначальный контекст
        c_def = self.get_user_context()  # переменная контекста DataMixin
        return {**context, **c_def}  # в шаблон передаём полный контекст</pre>
					</li>
					<li>
						Поправляем маршрут login - ссылкаемся на класс представления LoginUser
						<br>В urls.py
						<pre>path('login/', LoginUser.as_view(), name='login'),</pre>
					</li>
					<li>
						Выводим в шаблон login.html - нашу форму, По сути можно скопировать код из register.html - только изменить имя кнопки, так же добавил ошибки сверху и снизу
						<pre>
&lt;form method="post">
	{% csrf_token %}

	<!-- ошибки если неверный логин и пароль -->
	&lt;div class="form-error">
		{{ form.non_field_errors }}
	&lt;/div>
	&lt;
	{% for f in form %}
	&lt;p>
	&lt;label class="form-label" for="{{ f.id_for_label }}">{{f.label}}: &lt;/label>{{ f }}
	&lt;/p>
	&lt;div class="form-error">{{ f.errors }}&lt;/div>
&lt;
	<!-- ошибки если возникнут -->
	&lt;div class="form-error">
		{{ f.errors }}
	&lt;/div>


	{% endfor %}

	&lt;button type="submit" class="btn btn-primary btn-lg">
		Войти
	&lt;/button>
&lt;/form></pre>
					</li>
					<li>
						<span class="spec">Страница аккаунта - сделаю позже!</span>
					</li>
					<li>
						Стандартно после залогинивания - пренаправляет по url - http://127.0.0.1:8000/accounts/profile/ - Но такого маршрута нету, по этому будем перенаправлять на домашнюю страницу
						<br>
						Для этого в views.py - в классе представления LoginUser - в самом инзу добавим метод для перенаправление при успешной авторизации
						<pre>
def get_success_url(self):
    return reverse_lazy('home')  # при успешном входе перенаправит домой</pre>
    			<br><strong>Второй вариант сделать перенаправление через settings.py</strong>
    			<pre>
LOGIN_REDIRECT_URL = '/'  # При успешной аутентификации - перенаправление на home-page
LOGOUT_REDIRECT_URL = 'home'  # При выходе из акккунта перенаправление домой
    			</pre>
					</li>
					<li>
						Для залогиненого пользователя, вместо регистрации и войти в навбар будем отображать - имя пользователя и выйти
						<br>Редактируем base.html - добавляя конструкцию if

						<pre>
  	&lt;span class="nav-text text-light">

  		<!-- если пользователь залогиненый -->
  		{% if request.user.is_authenticated %}
  		&lt;span class="text-info" style="letter-spacing: .2em; font-size: 30px;">{{ user.username }} &lt;/span> &lt;a class="nav-link active text-warning" href="{% url 'logout' %}">Выйти&lt;/a>

  		<!-- иначе пользователь незалогинен -->
  		{% else %}
      	&lt;a class="nav-link active" href="{% url 'register' %}">Регистрация&lt;/a>
      	&lt;a class="nav-link active" href="{% url 'login' %}">Войти&lt;/a>
      	{% endif %}

  	&lt;/span></pre>
					</li>
					<li>
						Делаем маршрут и функцию представляния для logout
						<br>Во views.py
						<pre>
from django.contrib.auth import logout  # выход пользователя django
from django.shortcuts import ..., redirect

# выход из аккаунта
def logout_user(request):
    logout(request)  # стандартный выход пользователя
    return redirect('login')  # перенаправляет залогиниться</pre>
						<br>
						В urls.py
						<pre>path('logout/', logout_user, name='logout'),</pre>
						<br>
						<span class="spec">redirect делает перенаправление по сформированному маршруту, а reverse только формирует маршрут (без перенаправления)</span>
					</li>
					<li>
						Добавлю вункцию чтобы при успешной регистрации  - пользователь сразу был залогинен
						<br>Для этого во views.py - в классе представления RegisterUser - добавим метод form_valig
						<pre>
from django.contrib.auth import logout, login  # выход/вход пользователя django

# автозалогинивание при успешной регистрации
def form_valid(self, form):
    user = form.save()  # сохраняем данные пользователя в БД (User)
    login(self.request, user)  # авторизовывает пользователя
    return redirect('home')  # перенаправляет домой</pre>
					</li>
					<li>
						Немного подкорректирую шаблон login.html
					</li>
				</ol>
			</li>



			<li>
				<span class="title_text">Вынесу аутентификацию пользователей в отдельное приложение</span>
				<hr>
			<ol>
					<li>
						В двух словах, нежны свои urls.py, forms.py, templates, vievs.py
					</li>
					<li>
						Создам новой приложение account.
						<pre>python manage.py startapp account</pre>
					</li>
					<li>
						В settings.py - регистрирую приложение
						<pre>
INSTALLED_APPS = [ 
....,
'account.apps.AccountConfig',  # наше приложение аккаунт
]</pre>
					</li>
					<li>
						В account/urls.py добавляем пути - перемещаем  всё необходимое из blog/urls.py
						<pre>
from django.urls import path
from .views import *

urlpatterns = [
    path('login/', LoginUser.as_view(), name='login'),
    path('logout/', logout_user, name='logout'),
    path('register/', RegisterUser.as_view(), name='register'),
]</pre>
					</li>
					<li>
						В Главном urls.py - расширимся путями из account/urls.py
						<pre>path('', include('account.urls')),  # путь к путям приложения account</pre>
					</li>
					<li>
						blog/forms.py - полностью переносим в account/urls.py (сейчас там только формы регистрации и автоиризации)
					</li>
					<li>
						В account  - создаём подкаталоги templates/account. В него переносим наши шаблоны login.html, register.html
					</li>
					<li>
						Из blog/views.py переносим все классы и функции представления в account/views.py, связанные с пользователем  - Везде где указан путь к шаблону меняем путь
						<pre>
'account/register.html'
template_name = 'account/login.html'</pre>
						<br>Все функции и класса представления в account views.py
						<pre>
# Create your views here.
# класс представления RegisterUser
class RegisterUser(DataMixin, CreateView):
    form_class = RegisterUserForm  # наша форма из forms.py
    template_name = 'account/register.html'  # шаблон куда передаём
    success_url = reverse_lazy('login')  # При успешной регистрации направит path 'login'

    # формируем полный словарь context
    def get_context_data(self, object_list=None, **kwargs):
        # берём контекст из этого класса представления
        context = super().get_context_data(**kwargs)  # на данный момент form_class
        # берём контекст из DataMixin - и в него сразу добавляем title
        c_def = self.get_user_context(title='Регистрация')
        # передаём в шаблон общий контекст (RegisterUser + DataMixin)
        return {**context, **c_def}
        # или
        # return dict(list(context.items()) + list(c_def.items()))

    # автозалогинивание при успешной регистрации
    def form_valid(self, form):
        user = form.save()  # сохраняем данные пользователя в БД (User)
        login(self.request, user)  # авторизовывает пользователя
        return redirect('home')  # перенаправляет домой


# Класс представления формы авторизации
# Логика работы базового класса LoginView + сама форма LoginUserForm
class LoginUser(DataMixin, LoginView):
    form_class = LoginUserForm  # наша форма из forms.py
    template_name = 'account/login.html'  # шаблон

    # формируем полный контекст
    def get_context_data(self, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)  # распаковываем изначальный контекст
        c_def = self.get_user_context(title='Авторизация')  # переменная контекста DataMixin
        return {**context, **c_def}  # в шаблон передаём полный контекст

    def get_success_url(self):
        return reverse_lazy('home')  # при успешном входе перенаправит домой


# выход из аккаунта
def logout_user(request):
    logout(request)  # стандартный выход пользователя
    return redirect('login')  # перенаправляет залогиниться</pre>
					</li>
					<li>
						Выделенные красным мктоды, классы, формы  - импортируем в account/views.py - Это очень просто сделать в PyCharm.  - он почти всегда знает что откуда импортировать
						<pre>
from django.contrib.auth import logout, login
from django.contrib.auth.views import LoginView
from django.shortcuts import render, redirect
from django.urls import reverse_lazy
from django.views.generic import CreateView

from account.forms import RegisterUserForm, LoginUserForm
from blog.utils import DataMixin</pre>
					</li>
					<li>
						Пробуем запускать сервер и в терминале читаем ошибки, что и где не состыковывается
						<br>В blog.views.py - удаляем ИМПОРТ forms.py
						<pre>from .forms import *  # наш forms.py  -  УДАЛЯЕМ</pre>
						<strong>Всё работает! Точно так же как и до создания прилодения account и переноса туда всеи информации!</strong>
					</li>
					<li>
						Финальнцы штрих - удалим все неиспользуемые импорты в blog/Views.py
						<pre>
---DELETE---DELETE---DELETE---DELETE---DELETE---DELETE---
from django.contrib.auth import logout, login  # выход/вход пользователя django
from django.contrib.auth.forms import UserCreationForm  # форма django
from django.contrib.auth.views import LoginView  # стандартная логика авторизации
from django.http import HttpResponse

from django.urls import reverse_lazy  # перенаправление на маршрут
from django.views.generic import CreateView  # класс представления

from .utils import DataMixin  # наш Mixin

from django.shortcuts import redirect
---DELETE---DELETE---DELETE---DELETE---DELETE---DELETE---</pre>
						<br>Даже если что то и понадобится в будующем - импортируем заново
					</li>
				</ol>
			</li>
			





			<li>
				<span class="title_text">Добавляем страницу добавления поста - пользователем сайта</span>
				<hr>
			
				<ol>

					<li>
						В blog/forms.py - создаём форму - по сути ссылаемся на нашу модель Car, и указываем какие поля будем отображать
						<pre>
from django import forms
from blog.models import Car


class CarForm(forms.ModelForm):
    class Meta:
        model = Car  # наша модель
        # поля отображаемые в форме
        fields = ['slug', 'title', 'content', 'tth', 'photo', 'cat']</pre>
					</li>
					<li>
						Создаём шаблон add_post.html - по стандарту, расщиряемся от base.html , block content, block title
					</li>
					<li>
						Создаём функция представления show_add_post
						<pre>
from .forms import CarForm			

def show_add_post(request):
    form = CarForm()
    context = {
        'all_categories': all_categories,
        'form': form,
    }
    return render(request, 'blog/add_post.html', context=context)</pre>
					</li>
					<li>
						Добавляем маршрут name='add_post'
						<pre>path('add_post/', show_add_post, name='add_post'),</pre>

					</li>
					<li>
						Добавим ссылку в навбар для добавления поста (base.html)
						<pre>href="{% url 'add_post' %}</pre>
					</li>
					<li>
						<span class="spec">Внутри шаблона обязательно сразу указать form method='POST' и csrf_token - Без этого ничего сервер не запустится!</span>
						<pre>
&lt;h1>New post&lt;/h1>
&lt;form method="POST" class="post-form">
	{% csrf_token %}
    {{ form.as_p }}
    &lt;button type="submit" class="save btn btn-default">Save&lt;/button>
&lt;/form></pre>
					</li>
					<li>
						На данном этапе, форма уже отображается, только при её заполнении ничего не происходит так как у нас по сути нет кода чтобы сохранить её, так же нужно сделать валидацию данных
					</li>
					<li>
						Во первых в шаблоне add_post - необходимо обязательно добавить в тегах форм
						<pre>
&lt;form action="{%  url 'add_post' %}" method="post" enctype="multipart/form-data"></pre>
					</li>
					<li>
						Добавим параметры отображения полей (по сути автозаполнение тегов при пережаче в шаблон)
						<br>
						В forms.py - class CarAddForm(forms.ModelForm): -  class Meta: - widgets
						<pre>
widgets = {
        'slug': forms.TextInput(attrs={'class': 'form-control, col-5'}),
        'title': forms.TextInput(attrs={'class': 'form-control, col-10'}),
        'content': forms.Textarea(attrs={'rows': 6, 'class': 'form-control, col-10'}),
        'tth': forms.Textarea(attrs={'rows': 4, 'class': 'form-control, col-10'}),
    }</pre>
					</li>
					<li>
						В add_post - отобразим  ошибка форм - сразу после csrf -{{ form.non_field_errors }} / до закрытия цикла фор - {{ f.errors }}
						<br>
						Готовй шаблон add_post.html
						<pre>
&lt;h1>{{ title }}&lt;/h1>
&lt;form action="{%  url 'add_post' %}" method="post" enctype="multipart/form-data">
	{% csrf_token %}
	
&lt;div class="form-error">{{ form.non_field_errors }}&lt;/div>
	
	{% for f in form %}

	&lt;p>
		&lt;label class="form-label" for="{{ f.id_for_label }}">{{ f.label }}:&lt;/label>{{ f }}
	&lt;/p>

&lt;div class="form-error">{{ f.errors }}&lt;/div>

{% endfor %}

&lt;button type="submit" class="btn btn-primary btn-lg">
	Сохранить запись
&lt;/button>

{% endblock %}</pre>
					</li>
					<li>
						Готовая функция представления (добавление поста)
						<pre>
def show_add_post(request):
    if request.method == 'POST':  # если уже введены какие-то данные
        # request.FILES - Обязательно если есть файлы, изображения и ТД
        form = CarAddForm(request.POST, request.FILES)  # форма = заполненная форма
        if form.is_valid():  # проверка правильности формы, если форма заполнена правильно
            form.save()  # сохраняет запись в БД
            return redirect('home')  # перенаправление домой при успешном заполнении
    else:  # если никаких данный пользователь ещё не вводил
        form = CarAddForm()  # отображаем пустую форму для заполнения

    context = {
          'title': 'Добавление статьи',
          'all_categories': all_categories,
          'form': form,
      }
    return render(request, 'blog/add_post.html', context=context)</pre>
					</li>
				</ol>
			</li>




			<li>
				<span class="title_text">Редактирование поста через класс представления UpdateView</span>
				<hr>
				
				<ol>

					<li>
						Создаю форму в forms.py - на данном этапе почти такаяже как и добавление поста - но не указываю slug в полях
						<pre>
# форма редактирования поста
class CarUpdateForm(forms.ModelForm):
    <span class="spec"># Чтобы не отображалось - На данный момент: http:///...</span>
    photo = forms.ImageField(widget=forms.FileInput)
    # photo = forms.ImageField(required=False, widget=forms.FileInput)
    class Meta:
        model = Car  # связываемся с моделью Car
        # поля отображаемые в форме - URL - не указываю!
        # c photo не всё так просто, коряво + обязательно необходимо изменить изображение
        fields = ['title', 'content', 'tth', 'cat', 'photo']
        widgets = {
            'title': forms.TextInput(attrs={'class': 'form-control, col-12'}),
            'content': forms.Textarea(attrs={'rows': 15, 'class': 'form-control, col-12'}),
            'tth': forms.Textarea(attrs={'rows': 10, 'class': 'form-control, col-12'}),
        }</pre> 
					</li>
					<li>
						Делаем класс представления c помощью. UpdateView, во views.py
						<pre>
# редактирование Поста
class UpdatePostView(DataMixin, UpdateView):
    model = Car  # связываемся с моделью Car
    form_class = CarUpdateForm  # связываемся с формой
    # указываем только car_slug - из get_absolute_ur
    # несмотря на то что в пути есть и car_slug ? почему так хз
    slug_url_kwarg = 'car_slug'
    template_name = 'blog/update_post.html'  # путь к шаблону

    # формируем полный контекст
    def get_context_data(self, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)  # распаковываем изначальный контекст
        c_def = self.get_user_context(title='Изменение поста')  # переменная контекста DataMixin + title
        return {**context, **c_def}  # в шаблон передаём полный контекст</pre>
					</li>
					<li>
						Маршрут urls.py 
						<pre>
		path('category/&lt;slug:cat_slug>/&lt;slug:car_slug>/update/', UpdatePostView.as_view(), name='update_post'),</pre>
					</li>
					<li>
						Cоздаём шаблон  - лучше сделать отдельный update_post.html - по сути внитри всё тоже самое что и в add_post.html - но очень важная особенность, в тегах form в action=' ' получение пути по слагу!'
						<br><span class="spec">{%  url 'update_post' car_slug=car.slug cat_slug=car.cat.slug %}</span>
						<br><span class="spec"> = http://127.0.0.1:8000/category/japan/nissan_gt-r/</span>
						<pre>
&lt;form action="{%  url 'update_post' car_slug=car.slug cat_slug=car.cat.slug %}" method="post" enctype="multipart/form-data">

# {%  url 'update_post' car_slug=car.slug cat_slug=car.cat.slug %} - для получения пути ../&lt;slug: cat_slug>/&lt;slug:car_slug>/.../
# method="post" - для отправки информации на сервер (исопльзовать в форме отправки)
№ enctype="multipart/form-data" - при отправке не только текста но и файлов (например изображенией)</pre>
					</li>
					<li>
						Тот же шаблон update. html - отображаем изображение внизу вместо ссылки<br>
						<span class="spec">КРИТИЧЕСКИИЯ ФАЖНАЯ ИНФОРМАЦИЯ - ОТОБРАЖЕНИЕ ФОТО С СЕРВЕРА, ПОЛУЧЕНИЕ ССЫЛКИ НА НЕЁ, ФОТО ОТНОСЕЩИЕСЯ К ОПРЕДЕЛЕННОЙ ЗАПИСИ</span>
						<br>Для начала будем выводить все поля кроме фото, фото стоит последним полем в форме UpdatePostView
						<br>-Ниже выводим отдельно поле фото - вместе с текущи изображение
						<pre>
&lt;form action="{%  url 'update_post' car_slug=car.slug cat_slug=car.cat.slug %}" method="post" enctype="multipart/form-data">
	{% csrf_token %}
	
	&lt;!-- # &lt;div class="form-error"> form.non_field_errors }}&lt;/div> -->
    &lt;!-- # одибки сверху см add_post.html - нажна ли? -->

	{% for f in form %}

	{% if not forloop.last %}

	&lt;p>
		&lt;label class="form-label" for="{{ f.id_for_label }}">{{ f.label }}:&lt;/label>{{ f }}
	&lt;/p>

    {% else %}
    &lt;br>

<span class="spec">
# ССЫЛКА НА ИЗОБРАЖЕНИЕ ОБЪЕКТА (записи модели из БД) <br>(вставлять в &lt;img src='ссылка') : <br>{{object.photo.url }}</span>

    	&lt;label class="form-label" for="{{ f.id_for_label }}">
    		&lt;img src="{{object.photo.url }}" class="img-fluid" style="max-width: 50%;">&lt;br>

    		&lt;p class="text-info">- Если хотите оставить указанное фото, &lt;br>в этом поле не нужно ничего изменять.&lt;/p>{{ f }}
    	&lt;/label>
  

	{% endif %}

	&lt;!-- # &lt;div class="form-error"> f.errors }}&lt;/div> -->
    &lt;!-- # ошибки снизу см add_post.html нужна ли? -->

	{% endfor %}
	
	&lt;br>&lt;br>
	&lt;button type="submit" class="btn btn-primary btn-lg">
		Сохранить изменения
	&lt;/button>
&lt;/form></pre>
					</li>
					<li>
						Кнопка 'Редактировать' - в шаблоне car.html - важно так же указать car_slug cat_clug
						<br><span class="spec">href="{% url 'update_post' car_slug=car.slug cat_slug=car.cat.slug %}"</span>
						<br><span class="spec"> = http://127.0.0.1:8000/category/japan/nissan_gt-r/</span>
						<pre>
&lt;a class="btn btn-warning" href="{% url 'update_post' car_slug=car.slug cat_slug=car.cat.slug %}">Редактировать статью&lt;/a></pre>
					</li>
				</ol>
			</li>



			<li>
				<span class="title_text">Удаление статьи пользователем сайта</span>
				<hr>
				<ol>
					<li>
						Пишем маршрут в blog/urls.py
						<pre>path('category/&lt;slug:cat_slug>/&lt;slug:car_slug>/delete/', DeletePostView.as_view(), name='delete_post'),</pre>
					</li>
					<li>
						Во views.py пишим класс представления - для удаления статьи
						<pre>
from django.views.generic import ..., DeleteView  # представление для удаления
from django.urls import reverse_lazy  # перенаправление

# Представление для удаления статьи
class DeletePostView(DataMixin, DeleteView):
    model = Car  # модель из models.py
    template_name = 'blog/delete_post.html'  # шаблон
    success_url = reverse_lazy('home')  # после удаления отправит домой

    # !указываем только car_slug - из get_absolute_ur
    # !несмотря на то что в пути есть и car_slug ? почему так хз
    slug_url_kwarg = 'car_slug'
    
    # form_class = не нужно никакой формы

    # формируем полный контекст
    def get_context_data(self, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)  # распаковываем изначальный контекст
        c_def = self.get_user_context(title='Удаление поста')  # переменная контекста DataMixin + title
        return {**context, **c_def}  # в шаблон передаём полный контекст</pre>
						<br><span class="spec">Обрати внимаание на комменатрии к slug_url_kwarg = 'car_slug'</span>
					</li>
					<li>
						Создаём шаблон delete_post.html - в нем расширяемся от base.html + block title + block content
						<br>В блок контент добавим - кнопку удалить, проверку аутентификации пользователя, альтернативный вариант (войти/зарегестрироваться)
						<br>Форма простая просто method = 'post'
						<pre>
{% block content %}

&lt;h1>{{ title }}&lt;/h1>&lt;br>

&lt;!-- если пользователь залогиненый -->
{% if request.user.is_authenticated %}

&lt;&lt;div class="form-error">Удалить статью: "{{ object }}"!?&lt;/div>
&lt;br>
<span class="spec"># {{ object }} - это запись в таблице, отображает Сar - title
обрещение к записи через {{ object }} - вроде как в классах представления или формах</span>


&lt;form method="post">

	{% csrf_token %}
	
	&lt;button type="submit" class="btn btn-danger btn-lg">
		Удалить статью
	&lt;/button>
&lt;/form>

{% else %}
&lt;div class="form-error">
	&lt;p>Только авторизованные пользователи могут удалть статьи.</p>
	&lt;br>&lt;br>
	&lt;p>
		Пройдите авторизацию: &lt;a href="{% url 'login' %}" class="btn btn-primary btn-sm">Войти</a>
	&lt;/p>
	&lt;p>
		Либо зарегистрируйтесь:&lt;a href="{% url 'register' %}" class="btn btn-warning btn-sm">Регистрация&lt;/a>
	&lt;/p>
&lt;/div>

{% endif %}
{% endblock %}
						</pre>
					</li>
					<li>
						Добавим кнопку/ссылку удалить на страницу отдельной статьи - car.html
						<pre>
&lt;a class="btn btn-danger" href="{% url 'delete_post' car_slug=car.slug cat_slug=car.cat.slug %}">Удалить статью&lt;/a></pre>
						<br><span class="spec">Обрати внимание, для написания динамической ссылки в шаблоне, где есть id/pk или slug - все их необходимо указывать в href!</span>
					</li>
				</ol>
			</li>



			<li>
				<span class="title_text">
					Добавление поля autor - в модель Car (связь User - Car)
				</span>
				<hr>

				<ol>
					<li>
						В models.py - добавляем поле author
						<pre>
from django.contrib.auth.models import User

class Car(models.Model):
	...
	author = models.ForeignKey(User, on_delete=models.SET_NULL, verbose_name='Автор', blank=True, null=True)
						</pre>
					</li>
					<li>
						Сделаю и применю миграции для добавления поля в Базу данных
						<pre>
python manage.py makemigrations
python manage.py migrate</pre>
					</li>
					<li>
						Смотрим в pgAdmin 4 - добавилось поле, значение для каждой статьи null
					</li>
					<li>
						В админке - можно определить автора - в редактировании статьи, расставлю для всех стаей - автора
					</li>
					<li>
						Для удобства добавлю поле author - в сприске статьей в админке - для этого в  admin.py - class CarAdmin(admin.ModelAdmin 
						<pre>
list_display = ('id', 'title', 'time_create', 'get_html_photo', 'is_published', 'author')
list_editable = ('is_published', 'author')  # запятая - если 1 поле!</pre>
					</li>
					<li>
						Выведу в шаблон car.html - поле автор
						<pre>
&lt;p class="text_desc">Автор: {{ car.author }}&lt;/p></pre>
					</li>
					<li>
						Сделаю так что автоматически автором статьию будет админ - если удалим пользователя, то автором статьи автоматически будет администратор (чтобы не удалисть статьи при удалении автора)
						<br>Для этого - в models.py - class Car(models.Model): - меняю поле - author
						<pre>
# автор - (связь с моделью User, при удалении автора - статья переходит админу, стандартно автором будет админ,
# поле автор не может быть пустым)
author = models.ForeignKey(User, on_delete=models.SET_DEFAULT, verbose_name='Автор', default=1, blank=False)</pre>
					</li>
					<li>
						В функцию представления -show_add_post добавлю строчки кода
						<pre>
if form.is_valid():  # проверка правильности формы, если форма заполнена правильно
    car = form.save(commit=False)  # commit=False - когда нужно внести изменение в поле модели не из формы!
    car.author = request.user  # поле автора заполняется автоматически (залогиненый пользователь)
    car.save()  # сохраняем модель</pre>
    					<br>Полная функция представления дополненияя нового коста
    					<pre>
# добавление нового поста
def show_add_post(request):
    if request.method == 'POST':  # если уже введены какие-то данные
        # request.FILES - Обязательно если есть файлы, изображения и ТД
        form = CarAddForm(request.POST, request.FILES)  # форма = заполненная форма
        if form.is_valid():  # проверка правильности формы, если форма заполнена правильно
            car = form.save(commit=False)  <span class="spec"># commit=False - когда нужно внести изменение в поле модели не из формы!</span>
            car.author = request.user  # поле автора заполняется автоматически (залогиненый пользователь)
            car.save()  # сохраняем модель
            return redirect('home')  # перенаправление домой при успешном заполнении
    else:  # если никаких данный пользователь ещё не вводил
        form = CarAddForm()  # отображаем пустую форму для заполнения

    context = {
        'title': 'Добавление статьи',
        'all_categories': all_categories,
        'form': form,
      }
    return render(request, 'blog/add_post.html', context=context)</pre>

					</li>
					<li>
						Сделаю так что отображать ссылку для редактирования и удаления статью будут только автору статьи или администратору.
						<br>
						Для этого в car.html - добавляем конструкцию if
						<pre>
&lt;h3>Автор: {{ car.author }}&lt;/h3>
&lt;p class="text-muted">Время обновления поста: {{ car.time_update }}&lt;/p>

{% if car.author == request.user or request.user.id == 1 %}

&lt;a class="btn btn-warning" href="{% url 'update_post' car_slug=car.slug cat_slug=car.cat.slug %}">Редактировать статью&lt;/a>
&lt;a class="btn btn-danger" href="{% url 'delete_post' car_slug=car.slug cat_slug=car.cat.slug %}">Удалить статью&lt;/a>

{% else %}

&lt;p class="text-info">Вы не можете редактировать эту статью&lt;/p>

{% endif %}</pre>
					</li>
					<li>
						Для дополнительной безопасности (чтобы через url - не автор статьи не смог удалить статью через url) добавим проверку,  если пользователь автор статьи или администатор
						<br>В delete_post и create_post - аналогично в двух формах
						<pre>
<!-- если это автор статьи или администратор -->
{% if car.author == request.user or request.user.id == 1 %}

блок кода - форма удаления или редактирования статьи

<!-- если пользователь не автор статьи и не администратор -->
{% else %}

блок кода - ошибка, вы не автор статьи

{% endif %}</pre>
					</li>
				</ol>
			</li>

			<li>
				<span class="title_text">Переделаю функцию представления show_car - на класс представления ShowCar</span>
				<hr>

				<ol>
					<li>
						Во views.py - комментируем функцию представления show_car, и пишем новый класс представления для определённой машины
						<pre>
from django.views.generic import .., .., DetailView

# страница отдельной машины
class ShowCar(DataMixin, DetailView):
    model = Car
    template_name = 'blog/car.html'
    # !указываем только car_slug - из get_absolute_ur
    # !несмотря на то что в пути есть и car_slug ? почему так хз
    slug_url_kwarg = 'car_slug'  # !для пути 'category/&lt;slug:cat_slug>/&lt;slug:car_slug>/'
    context_object_name = 'car'  # обращаемся в шаблоне {{ car.поле }} - вместо object

    # формируем полный контекст
    # kwargs = {'cat_slug': self.cat.slug, 'car_slug': self.slug}
    # kwargs (пример из одного поста) = {'cat_slug': 'italy', 'car_slug': 'ferrari-488-gtb'}
    def get_context_data(self, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)  # распаковываем изначальный контекст
        c_def = self.get_user_context(cat_selected=self.kwargs['cat_slug'])
        return {**context, **c_def}  # в шаблон передаём полный контекст
						</pre>
						<br><span class="spec">
							Что здесь важно:<br>
							1. slug_url_kwarg = 'car_slug' - этого достаточно в классе представления чтобы получить путь - 'category/&lt;slug:cat_slug>/&lt;slug:car_slug>/ - то есть cat_slug указываеть не нужно (как в функции представления)
							<br>2. context_object_name = 'car' - чтобы в шаблоне к обхекту обращатся не как object (по стандарту) - а как car. car  = Car.object.get(slug=car_slug)
							<br>3. kwargs = {'cat_slug': self.cat.slug, 'car_slug': self.slug}<br>kwargs (пример из одного поста) = {'cat_slug': 'italy', 'car_slug': 'ferrari-488-gtb'}
							<br>4. Для получения cat_selected  - он должен быть равен cat_slug - добавляем в c_def: c_def = self.get_user_context(cat_selected=self.kwargs['cat_slug'])
						</span>
						<br><br>
					</li>
					<li>
						Корректируем маршрут, т.е обращаемся не к def show_car, а к классу представления class ShowCar
						<pre>path('category/&lt;slug:cat_slug>/&lt;slug:car_slug>/', ShowCar.as_view(), name='car')</pre>
					</li>
					<li>
						Всё страница отдельной статьи - работает как и раньше, букваньно за 2 действия.
				</ol>	
			</li>


			<li>
				<span class="title_text">Добавление комментариев к постам (модель Comment)</span>
				<hr>

				<ol>
					<li>
						Проришем модель Comment - в models.py
						<pre>
# класс комментарии
class Comment(models.Model):
    # отношение к определенному посту (записи в Car)
    car_post = models.ForeignKey(Car, on_delete=models.CASCADE, verbose_name='Статья', blank=True, null=True, related_name='comment_car')
    # автор - связь с моделью User
    author_comment = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='Автор комментария', blank=True, null=True)
    # дата создания комментария
    time_create_comment = models.DateTimeField(auto_now_add=True, verbose_name='Время создания комментария')
    # текст комментария
    text_comment = models.TextField(verbose_name='Текст комментария')
    # статус комментария (видно/не видно)
    status_comment = models.BooleanField(verbose_name='Видимость комментария', default=True)</pre>
					</li>
					<li>
						Создаём и принимаем миграции
						<pre>
python manage.py makemigrations  # создаём
python manage.py migrate  # принимаем
						</pre>						
					</li>
					<li>
						Создадим форму для создания статьи. В forms.py
						<pre>
# форма для комментария
class CommentForm(forms.ModelForm):
    class Meta:
        model = Comment  # наша модель
        # поля отображаемые в форме
        fields = ['text_comment']
        widgets = {
            'text_comment': forms.Textarea(attrs={'rows': 1, 'class': 'form-control'}),
        }</pre>
					</li>
					<li>
						Делаем представление, буду делать с помощью класса представлени DetailView
						<br>Во views.py - добавлю - расширяем класс представления ShowCar - стандартным миксином, FormMixin, так как DetailView - изначально не может иметь форм
						<br><strong>FormMixin -Предоставляет возможность показать и обработать форму в запросе.</strong>
						<pre>
from django.views.generic.edit import FormMixin

class ShowCar(DataMixin, DetailView, FormMixin):
	...
	...</pre>
						<br><span class="spec">
							Важную информацию можно брать с репозитория github django
						</span>	
						<br><a href="https://github.com/django/django">https://github.com/django/django</a>
					</li>
					<li>
						Выводим форму в классе представления class ShowCar, так как мы расширились от миксина django - FormMixin  - у нас есть возможность в свой класс представления добавлять атрибут - form_class = (имя формы)
						<br>В views.py- class ShowCar
						<pre>
from .forms import ...., ..., CommentForm	# наши формы forms.py

form_class = CommentForm  # наша форма для комментариев</pre>
						Теперь можем выводить форму - в шаблоне!
					</li>
					<li>
						Выводим форму в шаблон car.html.
						<pre>
<!-- Комментарии -->
&lt;br>&lt;br>&lt;br>&lt;br>
&lt;h3 class="text_desc">Комментарии к посту&lt;/h3>
&lt;hr>

&lt;p>Добавить комментарий&lt;/p>
&lt;form action="" method="post" id="add_comment" enctype="multipart/form-data">
{% csrf_token %}
&lt;div class="col-12">{{ form.as_p }}&lt;/div>
&lt;/form>

&lt;button form="add_comment" type="submit" class="btn btn-primary btn-md">
	Добавить комментарий
&lt;/button></pre>
					<br>
					<span class="spec">
						Что здесь важно:
						<br>1. &lt;form action="" - означает что ссылаемся на ту страницу где находимся!
						<br>2. Необходимо связать форму, с кнопкой. В тегах формы создаём id, в тегах кнопке ссылаемся на это id:
						<br> - &lt;form ... id="add_comment" ..>
						<br> - &lt;button form="add_comment" ...>
					</span>
					</li>
					<li>
						Для того чтобы кнопка добавить заработала, необходимо в классе представления переопределить метод post.
						<pre>
    # переопределяем метод пост (для того чтобы сохранялись комментарии)
    # self - это все объекты класса
    # request- запрос от пользователя
    def post(self, request, **kwargs):
        form = self.get_form()  # получить форму
        if form.is_valid():
            return HttpResponse('работает')
        else:
            return HttpResponse('не валидна')</pre>
            			промежуточный вариант - для понимания что делаем всё правильно и post - работает,  при отправке комментария - в браузере должно выводится 'работает'
					</li>
					<li>
						Полный класс представления
						<pre>
# страница отдельной машины
class ShowCar(DataMixin, DetailView, FormMixin):
    model = Car
    template_name = 'blog/car.html'
    # !указываем только car_slug - из get_absolute_ur
    # !несмотря на то что в пути есть и car_slug ? почему так хз
    slug_url_kwarg = 'car_slug'  # !для пути 'category/&lt;slug:cat_slug>/&lt;slug:car_slug>/'
    # context_object_name = 'car'  # обращаемся в шаблоне {{ car.поле }} - вместо object
    form_class = CommentForm  # наша форма для комментариев
    # success_msg = 'Комментарий создан!'  # сообщение при успешном создании комментария - РАЗБЕРИСЬ

    # определим перенаправление на нашу страницу, после отправки комментария, так как в пути у нас есть cat_slug, car_slug
    def get_success_url(self, **kwargs):
        # get_object() - это по сути Car.objects.get(1 штука)
        # kwargs - мы добавляем /&lt;slug:cat_slug>/&lt;slug:car_slug>/
        # полный наш путь равен пути path = 'car' - для этого и добавляли cat_slug car_slug
        # То есть при успешном заполнении формы (отправка комментария, нас оставит на этой же странице)
        return reverse_lazy('car', kwargs={'cat_slug': self.get_object().cat.slug, 'car_slug': self.get_object().slug})
  
    # переопределяем метод пост (для того чтобы сохранялись комментарии)
    # self - это все объекты класса
    # request- запрос от пользователя
    def post(self, request, **kwargs):
        form = self.get_form()  # в переменной форм занесли ту форму которую отправили
        # 2
        if form.is_valid():  # проверка правильности формы
            return self.form_valid(form)  # выполняется после form_valid - передаёт уже сохранённую форму
        else:
            return self.form_invalid(form)  # иначе вернёт что у нас неправильно

    # 1
    def form_valid(self, form):  # берём форму
        self.object = form.save(commit=False)
        self.object.car_post = self.get_object()  # получение и запись экземпляра статьи (одной машины)
        self.object.author_comment = self.request.user  # получение и запись имени автора
        self.object.save()  # форма пересохраняется с новыми данными
        return super().form_valid(form)  # форма передаётся в базу данных и программа продолжит свои действия

    # формируем полный контекст
    # kwargs = {'cat_slug': self.cat.slug, 'car_slug': self.slug}
    # kwargs (пример из одного поста) = {'cat_slug': 'italy', 'car_slug': 'ferrari-488-gtb'}
    def get_context_data(self, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)  # распаковываем изначальный контекст
        c_def = self.get_user_context(cat_selected=self.kwargs['cat_slug'])
        return {**context, **c_def}  # в шаблон передаём полный контекст</pre>
        				<br>
        				<span class="spec">
        					Что здесь важно:<br>
        					1. Для переопределения параметров, которые запонили не в форме (например автоматическое имя аавтора) блок кода - def form_valid(self, form):
        					<br>2. Для получения формы и сохранения в бд, переопределяем Post - который в габлоне в тегах form
        					<br>3. Для того чтобы остаться на той же странице, после успешного заполнения формы - def get_success_url(self, **kwargs):
        					<br>4. Передача параметров в путь, где есть слаги - return reverse_lazy('car', kwargs={'cat_slug': self.get_object().cat.slug, 'car_slug': self.get_object().slug})
        					<br>5. В остальном всё по старому - необходимо будет добавить высплывающее окно, что комментарий создан
        				</span><br><br>
					</li>
					<li>
						Отображаем комментарии, автора комментария, дату публикации в шаблоне
						<br>Шаблон car.html
						<pre>
&lt;p>Комментарии: {{ car.comment_car.all.count }}&lt;/p> # количество комментариев
...
...	
&lt;!-- Обращение к комментарию из объекта с помощью related_name='comment_car'
из class Comment(models.Model): - car_post &lt;p>{{ car.comment_car.all }}&lt;/p> -->
{% for сom_element in car.comment_car.all reversed  %}

&lt;ul class="list-group">
	&lt;li class="list-group-item list-group-item-info">Автор комментария: {{ сom_element.author_comment }}&lt;/li>
	&lt;li class="list-group-item list-group-item-light">{{ сom_element.text_comment|linebreaks }}&lt;/li>
	&lt;li class="list-group-item list-group-item-secondary">Дата создания: {{ сom_element.time_create_comment }}&lt;/li>
&lt;/ul>

&lt;br>&lt;br>


{% endfor %}</pre>
					    <span class="spec">
							Что здесь важно:<br>
							1. car.comment_car.all - обращение к комментарию из Car в Comment, c помощью Comment - car_post - related_name='comment_car'
							<br>2. Цикл for в шаблоне с конца (для отображения свежих коментариев в начале) - {% for i in list reversed  %}
							<br>3. {{ сom_element.text_comment|linebreaks }} - Авто абзац
							<br>4. &lt;/hr> - линия подчеркивание
						</span><br><br>
					</li>
					<li>
						Далее делал проверки аутентификации, и отображал что нужно кому нужно, с помощью проверки - {% if request.user.is_authenticated %} - авторизован ли пользователь:
						<br>-Комментарии могут видить все
						<br>-Комментировать могут только авторизоавнные пользователи
						<br>-Не авторизованному пользователю вывел ссылки войти или загегистрироваться
					</li>
				</ol>

			</li>



			<li>
				<span class="title_text">Переделаю представления home.html - вместо функциий представления с помощтю класса ListView</span>
				<hr>
				<ol>
					<li>
						def show_home(request): - комментирую - и делаю класс представления - class CarsAllShow(DataMixin, ListView):
						<pre>
# домашняя страница
class CarsAllShow(DataMixin, ListView):
    paginate_by = 6  # пагинация
    model = Car  # модель cars = Car.objects.all()
    template_name = 'blog/home.html'  # шаблон
    context_object_name = 'cars'  # objects = cars (просто имя)

    # формируем полный контекст
    def get_context_data(self, *, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)  # контекст Car.object.all()
        c_def = self.get_user_context(cat_selected='all',
                                      title='Все модели')  # наш контекст + DataMixin
        return {**context, **c_def}  # в шаблон передаём полный контекст</pre>
					</li>
					<li>
						Правлю маршрут name='home'
						<pre>path('', CarAllShow.as_view(), name='home'),</pre>
					</li>
					<li>
						Немного подкорректировал шаблон (3 столбца вместо двух)
						<br>Пагинацию в шаблоне вообще не трогал всё работает как работало
						<br><br><strong>Всё буквально два действия и вместо функции представления -класс, который более предпочтительней и удобный</strong>
					</li>
				</ol>
			</li>


&lt;

			<li>
				<span class="title_text">Переделаю представления category.html - вместо функциий представления с помощтю класса ListView</span>
				<hr>
				<ol>
					<li>
						Для начала сделал отдельный шаблон category.html - так как хочу что отображение по категориям было бы в другом стиле (дело не в пагинации, выводе некоторых авто или чтом то другом - просто стиль шаблона)
					</li>
					<li>
						Комментирую/ удаляю функцию представления - def show_categories(request, cat_slug):
					</li>
					<li>
						Делаю класс представление - CarsCategoryShow
						<pre>
# вывод машин по категориям
class CarsCategoryShow(DataMixin, ListView):
    paginate_by = 2
    model = Car
    template_name = 'blog/category.html'
    context_object_name = 'cars'
    allow_empty = False  # для отображения 404

    # параметры вывода (выводим записи только определенной категории)
    def get_queryset(self):
        return Car.objects.filter(cat__slug=self.kwargs['cat_slug'])

    # полный контекст
    def get_context_data(self, *, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)
        # получение выбранной категории - для получения параметров категории
        select_category = Category.objects.get(slug=self.kwargs['cat_slug'])
        c_def = self.get_user_context(cat_selected=select_category.slug,
                                      title=f'Производство: {select_category.name}')
        return {**context, **c_def}</pre>
					</li>
					<li>
						Корректирую маршрут name='category'
						<pre>path('category/&lt;slug:cat_slug>/', CarsCategoryShow.as_view(), name="category"),</pre>
					</li>
				</ol>
			</li>


&lt;



			<li>
				<span class="title_text">Добавлю всплываюшее сообщение, при успешном создании комментария</span>
				<hr>
				<ol>
					<li>
						Добавляем в форму сообщение - (всплывающее сообщение при успешном создании комментария)
						<br>views.py - class ShowCar
						<pre>
# SuccessMessageMixin- миксин для сообщения, при работе с любыми формами!		
class ShowCar(SuccessMessageMixin, ..., ..., FormMix...):
	......
	# всплывающий комментарий {% if messages %} - {% for m in messages %}
	success_message = "Комментарий успешно создан!"</pre>
						<span class="spec">
							Важно! SuccessMessageMixin - должен быть первым в списке базовых классов! - чтобы всплывающее сообщение срабатывало!
						</span>
					</li>
					<li>
						В шаблоне отображаем само сообщение
						<br>car.html - в любом месте, я отображаю прям под кнопкой 'добавить комментарий'
						<pre>
&lt;!-- Всплывающий комментарий -->
&lt;div class="bg-success">
	{% if messages %}
		{% for m in messages %}
			&lt;h3>{{ m }}&lt;/h3>
		{% endfor %}
{% endif %}
&lt;/div></pre>
					</li>
					<li>
						Теперь при создании комментария - будет выведено сообщение - "Комментарий успешно создан!" - после другого действия на странице, или обновления страницы, сообщение исчезнет. Т.е всё как и планировал!
					</li>
				</ol>
			</li>


&lt;





			<li>
				<span class="title_text">Регистрирую модель в админ панеле (Comment)</span>
				<hr>
				<ol>
					<li>
						Приведу в подобающий вид отображение комментов (в админке), добавив Meta и __str__.
						<br>models.py - class Comment
						<pre>
class Comment(models.Model):
	....
    class Meta:
    verbose_name = "Комментарий"
    verbose_name_plural = "Комментарии"
    ordering = ['-time_create_comment']  # сортировка

    # отображение записи по данным
    def __str__(self):
        return f'Авто: {self.car_post}, Коммент: {self.text_comment}'</pre>
					</li>
					<li>
						Рагистрирую модель в админ панеле
						<br>admin.py
        				<pre>admin.site.register(Comment)</pre>
					</li>
				</ol>
			</li>


&lt;


			<li>
				<span class="title_text">Добавляем лайки к комментарием</span>
				<hr>
				<ol>
					<li>
						Добавляю модель в models.py для лайков коммтария
						<pre>
# Лайки на Комменты
# Буду считать количество LikeComment.objects.filter(comment=comment.pk)
class LikeComment(models.Model):
    # Связь с пользователем
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='Лайкнувший пользователь')
    # Связь c определённым комментарием
    comment = models.ForeignKey(Comment, on_delete=models.CASCADE, verbose_name='Комментарий для лайка', related_name='comment_like')

    class Meta:
        verbose_name = "Лайк комментария"
        verbose_name_plural = "Лайки комментария"
        # db_table = 'LikeComment'  # для названия таблицы в DB

    def __str__(self):
        return f'ЛАЙК_К - {self.comment},' \
               f'Пользователь: {self.user}.'</pre>
					</li>
					<li>
						Создам и сделаю миграции
					</li>
					<li>
						Зарегистрирую модель LikeComment - в admin.py
						<pre>admin.site.register(LikeComment)</pre>
					</li>
					<li>
						Создал пару фальшивых лайков через админку - (2 записи модели - LikeComment)
					</li>
					<li>
						<span class="spec">
							Выводим количество лайков в шаблоне
						</span>
						<br>В представлении ничего менть не нужно!
						<br>Шаблон car.html
						<pre>
{% for сom_element in car.comment_car.all reversed  %}
&lt;ul class="list-group">
	&lt;li class="list-group-item list-group-item-info">
_______всё что выше без изменения_______

		# если количество лайков больше 0
		{% if сom_element.comment_like.all|length > 0 %}
		Количество лайков {{ сom_element.comment_like.all|length }}
		{% endif %}
		
		Автор комментария: {{ сom_element.author_comment }}

	&lt;/li>
	&lt;li>
		..Текст коммента
	&lt;/li>
	&lt;li>
		..дата комета
	&lt;/li></pre>
						<span class="spec">
							Что здесь важно - связи related_mane - Сar-->Comment-->LikeComment - т.е через 1 класс можно обратится к третьему!:
							<br><br>
							- car.comment_car.all = Записи Сomment-ForeingKey-Car (related_name=comment_car)<br>
							- &lt;QuerySet><br>
							-то есть все записи Comment связанные к определённой записи Car
							<br><br>
							- сom_element - это одна запись (1 комментарий)
							<br><br>
							- сom_element.comment_like.all = Запись LikeComment-ForeignKey-Comment (related_name=comment_car)<br>
							- &lt;QuerySet><br>
							- то есть все записи относящиеся к определённому комментарию
							В нашем случае одна запись это 1 лайк
							<br>
							<br>
							- ...|length }} - длина QuerySeta - то есть количество записей!
							<br><br>
						</span>
					</li>
					<li>
						Добавлю одну функцию кнопки лайк (добавить/убрать) - (По сути записей  модели LikeComment)
						<br>Необходим будет маршрут url - для функции, но переходить на эту страницу нет необходимости
						<br>-Но сами функции будут возвращать на страницу поста - редирект, то есть мы будем всегда на одной странице - маршруты фикция
					</li>
					<li>
						В моделе - Comment - добавлю метод get_absolute_url - для получения urlа для кнопики "ЛАйК" - к каждому комментарию. (По сути необходимо создать маршрут для каждого комментария)
					</li>
					<pre>
class Comment(models.Model):
	....
	....
	# функция формирования маршрута к ссылке
    def get_absolute_url(self):  # self - ссылка на один экземпляр(строку) таблицы модели
        # reverse('имя пути', kwargs={ Category-slug, Car-slug, Comment-slug}
        return reverse('like_button_comment', kwargs={'cat_slug': self.car_post.cat.slug,
                                                      'car_slug': self.car_post.slug,
                                                      'com_id': self.pk})</pre>
                        <span class="spec">
                        	<br>-like_button_comment - path name='__'
							<br>-self.car_post.cat.slug = Category - поле slug
							<br>-self.car_post.slug = Car - поле slug
							<br>-self.self.pk = Comment - поле slug

							<br>-где car_post = ForeignKey Car | cat = ForeignKey Category
							<br>-То есть самой удалённой модели дошли до первой, с помощью ForeingKey	
                        </span><br><br>
					<li>
						Пишу представление для кнопки лайк комментария (поиведие - при нашатии на неё)
						<br>views.py
						<pre>
# поведение кнопки лайк
@login_required
def like_button_comment(request, cat_slug, car_slug, com_id):
    # или 404 или Comment.objects.get(pk=com_id)
    # comment - жто поле модели LikeComment-> ForeingKey -> Сomment
    comment = get_object_or_404(Comment, pk=com_id)
    author_comment = comment.author_comment  # только для вывода во всплывающем сообщении

    # получаем или создаём запись в модели LikeComment (то есть лайк)
    like_comment, created = LikeComment.objects.get_or_create(
        comment=comment,
        user=request.user
    )

    # если запись не создалась (т.е она уже была)
    if not created:
        like_comment.delete()
        messages.info(request, f"Вам больше не нравится комментарий от пользователя - {author_comment}")
    else:  # если запись добавилась - (лайкнули)
        like_comment.save()  # сохраняем лайк (запись LikeComment) в БД
        messages.info(request, f'Вам понравился комментарий от пользователя - {author_comment}')
    # остаёмся на странице поста, через запятую все динамические параметры (получали с реквестом)
    return redirect('car', cat_slug, car_slug)</pre>
    				<br>
    					<span class="spec">
    						Очень интересная функция, множество функционала, при лаконичном исполнении!
    						<br>- Приём трёх динамических параметров (slug/slug/pk)
    						<br>- Только залогиненый может пользоваться
    						<br>- 404 или объект
    						<br>- Достаём поле из записи модели, для передачи в шаблоне
    						<br>- Проверка, ставили ли лайк или нет
    						<br>- Запись в БД и удаление, при одном и том же действии
    						<br>- Всплывающее сообщение
    						<br>- f строка, передача значения из бд в сообщение
    						<br>- Остаёмся на той же странице
    						<br>- Передача динамических параметров slug/slug - в redidect
    					</span>
    					<br><br>
					</li>
					<li>
						Для функции представления нужен маршрут, даже если на него мы не будем попадать (маршрут фикция)
						<br>urls.py
						<pre>path('category/&lt;slug:cat_slug>/&lt;slug:car_slug>/&lt;int:com_id>/', like_button_comment, name='like_button_comment'),</pre>
					</li>
					<li>
						В шаблоне car.html - добавляем кнопку лайк - причем так чтобы она выглядела по разному, если пользователь ставил лайк или неставил
						<br><br>-Для этого необходимо найти сами символы  - беру из <a href="https://fonts.google.com/icons?icon.style=Rounded&icon.query=like&icon.platform=web">https://fonts.google.com/</a>
						<br><br>-Беру ссыллку на символы и добавляю в head base.html
						<br><br>-Беру "настройки" css с сайта и загружаю в blog/static/blog/css/styles.css
						<br><br>Отображаю в самом шаблоне car.html - иконка будет ссылкой, кнопки лайк, и вышлядить будет по разному в зависимости от того - нажат лайк или нет
						<br>Весь блок кода, для отображения всего комментария (с кнопками и счётчиком лайка) - car.html
						<pre>
&lt;!-- ПЕРЕБИРАЮ ВСЕ КОММЕНТАРИИ К ПОСТУ	 -->
{% for сom_element in car.comment_car.all reversed  %}

{% if request.user.is_authenticated %} &lt;!-- если залогинен -->

&lt;ul class="list-group">&lt;!--  начало списка (1 комментарий) -->
	&lt;li class="list-group-item list-group-item bg-secondary bg-gradient text-white">

		&lt;div class="d-flex bd-highlight mb-0">
			&lt;div class="p-0 bd-highlight" style="font-size: 1.5em">{{ сom_element.author_comment }}&lt;/div>


			&lt;div class="p-0 bd-highlight ms-auto">

				&lt;!-- перебираю все LikeComment записи (все лайки к коменту) -->
				{% for user_likes in сom_element.comment_like.all %}
													
				&lt;!-- ЕСЛИ ПОСТАВИЛ ЛАЙК -->
				{% if request.user == user_likes.user %}						
				&#9989;
				{% endif %}&lt;!-- ЕСЛИ ПОСТАВИЛ ЛАЙК -->

				
				{% endfor %}&lt;!-- перебираю все лайки к коменту-->
				
				
				&lt;!-- ЛАЙК КНОПКА -->
				&lt;a class="btn" href="{{ сom_element.get_absolute_url }}">
					&lt;span class="material-symbols-rounded">thumb_up&lt;/span>
				&lt;/a>
				
				&lt;!-- кнопка на будущее , вместо галочки рядом со сделанным лайком -->
				&lt;!-- &lt;a class="btn" href="{{ сom_element.get_absolute_url }}">
					&lt;span class="material-symbols-outlined">thumb_up&lt;/span>
				&lt;/a>-->						

				&lt;!-- если количество лайков больше 0 - ПОКАЖУ КОЛИЧЕСТВО -->
				{% if сom_element.comment_like.all|length > 0 %}
				&lt;span style="font-size: 1.2em" class="text-white">  {{ сom_element.comment_like.all|length }} &lt;/span>
				{% endif %} &lt;!-- если количество лайков больше 0 -->

			&lt;/div>
		&lt;/div>
	&lt;/li>
	&lt;!-- ТЕКСТ КОММЕНТАРИЯ -->
	&lt;li class="list-group-item list-group-item-light">{{ сom_element.text_comment|linebreaks }}&lt;/li>
	&lt;!-- ДАТА КОММЕРИЯ -->
	&lt;li class="list-group-item list-group-item-secondary">{{ сom_element.time_create_comment }}&lt;/li>

&lt;/ul> 

&lt;br>&lt;br>

{% endif %} &lt;!-- если  залогинен -->


{% endfor %}&lt;!-- ПЕРЕБИРАЮ ВСЕ КОММЕНТАРИИ К ПОСТУ	 --></pre>
						<br><strong> На данный момент получилось только чтобы при нажатии лайка - появлялась галочка рядом со значком лайка - необходимо сделать чтобы менялся сам занчёк (так как приходится делать через цикл) - исправь</strong>
					</li>
				</ol>
			</li>


&lt;





			<li>
				<span class="title_text">Убираю комментарии (+лайки к ним) в отдельное приложение</span>
				<hr>
				<ol>
					<li>
						Создаю приложение
						<pre>python manage.py startapp comments </pre>
					</li>
					<li>
						Регистрирую приложение в settings.py
						<pre>
INSTALLED_APPS = [
	....
	'comments.apps.CommentsConfig',  # наше приложение comments
]</pre>
					</li>
					<li>
						В основном urls.py (avtoblog) расширяю urlpatterns - из приложения comments
					</li>
					<li>
						Переношу все необходимые модели (Comment, LikeComment) - из blog/models.py - в comments/models.py
						<br>Сразу импортирую всё седостающие модели (Car, Category, User)
						<pre>
from django.contrib.auth.models import User
from django.db import models
from django.urls import reverse
from blog.models import Car


# Create your models here.
# класс комментарии
class Comment(models.Model):
    # отношение к определенному посту (записи в Car)
    car_post = models.ForeignKey(Car, on_delete=models.CASCADE, verbose_name='Статья', blank=True, null=True,
                                 related_name='comment_car')
    # автор - связь с моделью User
    author_comment = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='Автор комментария', blank=True,
                                       null=True)
    # дата создания комментария
    time_create_comment = models.DateTimeField(auto_now_add=True, verbose_name='Время создания комментария')
    # текст комментария
    text_comment = models.TextField(verbose_name='Текст комментария')
    # статус комментария (видно/не видно)
    status_comment = models.BooleanField(verbose_name='Видимость комментария', default=True)

    class Meta:
        verbose_name = "Комментарий"
        verbose_name_plural = "Комментарии"
        ordering = ['time_create_comment']  # сортировка

    # отображение записи по данным
    def __str__(self):
        return f'Авто: {self.car_post}, ' \
               f'Коммент: {self.text_comment}'

    # функция формирования маршрута к ссылке
    def get_absolute_url(self):  # self - ссылка на один экземпляр(строку) таблицы модели
        # reverse('имя пути', kwargs={ Category-slug, Car-slug, Comment-slug}
        return reverse('like_button_comment', kwargs={'cat_slug': self.car_post.cat.slug,
                                                      'car_slug': self.car_post.slug,
                                                      'com_id': self.pk})


# Лайки на Комменты
# Буду считать количество LikeComment.objects.filter(comment=comment.pk)
class LikeComment(models.Model):
    # Связь с пользователем
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='Лайкнувший пользователь')
    # Связь с определённым комментарием
    comment = models.ForeignKey(Comment, on_delete=models.CASCADE, verbose_name='Комментарий для лайка',
                                related_name='comment_like')

    class Meta:
        verbose_name = "Лайк комментария"
        verbose_name_plural = "Лайки комментария"
        # db_table = 'LikeComment'  # для названия таблицы в DB

    def __str__(self):
        return f'ЛАЙК_К - {self.comment},' \
               f'Пользователь: {self.user}.'</pre>
					</li>
					<li>
						В comments - cоздаю каталог templates, для шаблонов и внтурири подкаталог - с названием приложения - comments
						<pre>comments/templates/comments</pre>
					</li>
					<li>
						В этот подкаталог переношу все шаблоны которые необходимы  - оказалось на данный момент их нет
						<strong>оказалось на данный момент их нет</strong>  - но скорее всего появится (сделаю пользовательский тег шаблонов для комментария)
					</li>
					<li>
						Из blog/views.py - в comments/views.py - перенесу все представления которые необходимы (like_button_comment)  - но добавление комментария осталось в классе представления - ShowCar
						<br><br>Сразу импортирую все функции и класса в comments/views.py
						<pre>
from django.contrib.auth.decorators import login_required
from django.shortcuts import get_object_or_404, redirect
from comments.models import Comment, LikeComment


# поведение кнопки лайк
@login_required
def like_button_comment(request, cat_slug, car_slug, com_id):
    # или 404 или Comment.objects.get(pk=com_id)
    # comment - жто поле модели LikeComment-> ForeignKey -> Comment
    comment = get_object_or_404(Comment, pk=com_id)
    # author_comment = comment.author_comment  # только для вывода во всплывающем сообщении

    # получаем или создаём запись в модели LikeComment (то есть лайк)
    like_comment, created = LikeComment.objects.get_or_create(
        comment=comment,
        user=request.user
    )

    # если запись не создалась (т.е она уже была)
    if not created:
        like_comment.delete()
        # messages.info(request, f"Вам больше не нравится комментарий от пользователя - {author_comment}")
    else:  # если запись добавилась - (лайкнули)
        like_comment.save()  # сохраняем лайк (запись LikeComment) в БД
        # messages.info(request, f'Вам понравился комментарий от пользователя - {author_comment}')
    # остаёмся на странице поста, через запятую все динамические параметры (получали с request)
    return redirect('car', cat_slug, car_slug)</pre>
					</li>
					<li>
						Создаю свой urls.py - в приложении comments<br>
						Перемещаем все маршруты из blog/urls.py в comments/urls.py
						<pre>
from django.urls import path
from comments.views import like_button_comment

urlpatterns = [
    path('category/&lt;slug:cat_slug>/&lt;slug:car_slug>/&lt;int:com_id>/', like_button_comment, name='like_button_comment'),</pre>
					</li>
					<li>
						Из blog/admin.py в comments/admin.py - переношу вме админ модели комментариев и лайков 
						<pre>
from django.contrib import admin

from comments.models import Comment, LikeComment


class CommentAdmin(admin.ModelAdmin):
    list_display = ('id', 'car_post', 'author_comment', 'text_comment')

    
admin.site.register(Comment, CommentAdmin)
admin.site.register(LikeComment)</pre>
					</li>
					<li>
						Добавлю verbose_name - для приложения comments - в comments/apps.py - class CommentsConfig
						<pre>
class CommentsConfig...:
	....
	verbose_name = 'Приложение Комментарии'  # для отображения в админке
						</pre>
					</li>
					<li>
						Пробую запустить сервер  - чтобы увидеть ошибки (то есть что забыли подправить)
						<br>Переносим форму для комментариев - из blog/forms.py - в comments/forms.py  - предварительно создав сам forms.py в приложении comments
						<pre>
from django import forms
from comments.models import Comment


# форма для комментария
class CommentForm(forms.ModelForm):
    class Meta:
        model = Comment  # наша модель
        # поля отображаемые в форме
        fields = ['text_comment']
        widgets = {
            'text_comment': forms.Textarea(attrs={'rows': 1, 'class': 'form-control'}),
        }</pre>
					</li>
					<li>
						Корректируем расположение формы для создания комментария в представлении ShowCar - CommentForm.
						<br>blog/views.py
						<pre>from comments.forms import CommentForm  # наши формы forms.py (comments app)</pre>
					</li>
					<li>
						Создаю и применяю миграции
						<pre>
python manage.py makemigrations
python manage.py migrate</pre>
					</li>
					<li>
						Запускаем сервер - проверяем функционал, (комментарии, лайки) - пробуем различные действия с разных акаунтов.
					</li>
					<li>
						По итогу всё работает как и было, так же важно понимать что старые модели (Комментарии и Лайки) - из приложения blog будут удалены, то есть и все записи и все таблицы
					</li>
					<li>
						Даже не пришлось что то корректировать внутри шаблонов, то есть те отображения orm внутри шаблонов остались ровно такиме же!
					</li>
				</ol>
			</li>


&lt;



			<li>
				<span class="title_text">Удаление комментария</span>
				<hr>
				<ol>
					<li>
						Будет возможность удалять комментарий только пользователю который создал комментарий или админу
					</li>
					<li>
						Делаю представление кнопки удаления комментария
						<br>comments/views.py
						<pre>
# кнопка удаления комментария
def delete_button_comment(request, cat_slug, car_slug, com_id):
    # получаю 1 комментарий (по id коммента)
    comment = get_object_or_404(Comment, pk=com_id)
    # если пользователь автор коммента или админ (id 1)
    if request.user.id == comment.author_comment.id or request.user.id == 1:
        # Удаляем комментарий
        comment.delete()
    else:  # если не автор и не админ
        # Вывожу сообщение
        messages.warning(request, 'Вы не можете удалить не свой комментарий')
    # перенаправляюсь на страницу поста
    # обязательно указать динамические параметры
    return redirect('car', cat_slug, car_slug)</pre>
					</li>
					<li>
						Делаю маршрут для кнопки удаления комментария - comments/urls.py
						<pre>
path('category/&lt;slug:cat_slug>/&lt;slug:car_slug>/&lt;int:com_id>/delete_comment',
     delete_button_comment,
     name='delete_comment'),</pre>
					</li>
					<li>
						Отображаю кнокру удалить комментарий в цикле перебора всех комментариев.
						<br>car.html
						<pre>
<!-- Если пользователь автор коммента или админ (id 1) -->
{% if request.user.id == one_coment.author_comment.id or request.user.id == 1 %}

&lt;!-- КНОПКА УДАЛЕНИЕ КОММЕНТАРИЯ -->
&lt;li class="list-group-item list-group-item-secondary">
	&lt;a href="{% url 'delete_comment' car_slug=car.slug cat_slug=car.cat.slug com_id=one_coment.pk %}" class="btn btn-outline-danger btn-sm">
		Удалить комментарий
	&lt;/a>
&lt;/li>

{% endif %}&lt;!-- Если пользователь автор коммента или админ (id 1) --></pre>
						Кнопка - 'Удалить комментарий' - будет видна только авторам комментария или админу с id = 1
					</li>
					<li>
						Всё больше ничего делать не нужно, тема закрыта
					</li>
					<li>
						Может быть позже добавлю редактирование комментария но врятли
					</li>
				</ol>
			</li>


&lt;







			<li>
				<span class="title_text">Добавляю лайки, рейтинг и добавление в закладке к статьям</span>
				<hr>
				<ol>
					<li>
						Создам новое приложение - для рейтинга статей (отношение пользователей и статей) - relatepost
						<pre>python manage.py startapp relatepost</pre>
					</li>
					<li>
						Регистрирую приложение relatepost - в settings.py  - в INSTALLED_APPS
						<pre>
INSTALLED_APPS = [
	....
	'relatepost.apps.RelatepostConfig'  # наше приложение relatepost
]</pre>
					</li>
					<li>
						Добавлю отображение названия приложения в админке - relatepost/apps.py
						<pre>
class RelatepostConfig(AppConfig):
	....
	verbose_name = 'Оценка статей пользователем'  # отображение названия приложения</pre>
					</li>
					<li>
						Пишу первую модель в приложении relatepost - Модель для связи поста и пользователя с его оценками, лайком и закладкой
						<pre>
from django.contrib.auth.models import User
from django.db import models
from blog.models import Car

from django.contrib.auth.models import User
from django.db import models
from blog.models import Car


# отношение пользователя к посту
class UserCarRelation(models.Model):
    RATE_CHOICES = (
        (1, 'Совсем плохо'),
        (2, 'Плохо'),
        (3, 'Нормально'),
        (4, 'Хорошо'),
        (5, 'Отлично'),
    )

    # какой пользователь
    user_relation = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='Оценивающий пользователь')
    # какой пост
    car_relation = models.ForeignKey(Car, on_delete=models.CASCADE, verbose_name='оцениваемый пост',
                                     related_name='relation_from_user')
    # лайк на пост
    is_like_post = models.BooleanField(default=False, verbose_name='Лайк поста')
    # добавление в закладки
    is_bookmarks_post = models.BooleanField(default=False, verbose_name='Пост в закладке')
    # оценка поста
    rate = models.PositiveSmallIntegerField(choices=RATE_CHOICES, null=True, verbose_name='Личная оценка поста')

    class Meta:
        verbose_name = 'Отношение пользователя к посту'
        verbose_name_plural = 'Отношения пользователей к постам''

    def __str__(self):
        return f'Пользователь: {self.user_relation.username} - Статья: {self.car_relation}, Л_оценка: {self.rate}.'</pre>
					</li>
					<li>
						Регистрирую модель - UserCarRelation -  в админке - настраиваю отображение в админке
						<br>relatepost/admin.py
						<pre>
from django.contrib import admin
from relatepost.models import UserCarRelation


class UserCarRelationAdmin(admin.ModelAdmin):
    # список отображаемых столбцов в админ-панели
    list_display = ('id', 'user_relation', 'car_relation', 'is_like_post', 'is_bookmarks_post', 'rate')
    # список полей на которые можно кликнуть - для редактирования
    list_display_links = ('user_relation', 'car_relation')
    # список полей - ко которым можно вести поиск
    search_fields = ('user_relation', 'car_relation')
    # редактирование поля публикации - в списке - в админке
    list_editable = ('is_like_post', 'is_bookmarks_post', 'rate')  # запятая - если 1 поле!
    # фильтр по полям - публикация, время изменения.
    list_filter = ('user_relation', 'car_relation')


# Register your models here.
admin.site.register(UserCarRelation, UserCarRelationAdmin)</pre>
					</li>
					<li>
						Создаю и делаю миграции
						<pre>
python manage.py makemigrations
python manage.py migrate</pre>
					</li>
					<li>
						Добавлю общий рейтинг одной статьи - необходимо добавить поле rating - в модель поста
						<br>blog/models.py - class Car(models.Model):
						<pre>
class Car(models.Model):
	...
	# рейтинг поста (пример рейтинг = 3.68)
    rating = models.DecimalField(max_digits=3, decimal_places=2, default=None, null=True)</pre>
    				<br>
    				<span>
    					Необходимо автоматически записывать рейтинг в базц данных. Попробуй с помощью метода save  модели - rating_set
    				</span>
    				<br>
					</li>
					<li>
						Применю и сделаю миграцию
						<pre>
python manage.py makemigrations
python manage.py migrate</pre>
					</li>
					<li>
						Добавляю метод получения рейтинга, и передачи в шаблон car.html
						<br>blog/views.py - class ShowCar
						<pre>
class ShowCar(SuccessMessageMixin, DataMixin, DetailView, FormMixin):
	.....
	.....
	# метод получения рейтинга поста
    def get_rating(self, **kwargs):
        # получение всех записей, отношений к данному посту
        users_ralations = UserCarRelation.objects.filter(car_relation__slug=self.kwargs['car_slug'])
        sum_rate = 0  # промежуточная переменная - сумма всех рейтингов
        # если количество записей отношений больше нуля 0
        if users_ralations.count() > 0:
            # перебираем все записи отношений
            for one_relation in users_ralations:
                # в промежуточную переменную прибавляем рейтинг отдельной записи
                sum_rate += one_relation.rate
            # полную сумму оценок делим на количество оценок и получаем рейтинг
            rating = sum_rate / users_ralations.count()
        else:
            rating = 0
        return rating

    ....
	def get_context_data(self, object_list=None, **kwargs):
		....
        c_def = self.get_user_context(cat_selected=....,
                                      rating=self.get_rating(),  # получаю рейтинг
                                      ....)</pre>
					</li>
					<li>
						Для получения пейтинга внутри шаблона car.html - необходимо вызвать: {{ rating }}
					</li>
					<li>
						Добавляю метод получения реакции залогиненного пользователя к конкретному посту, и передачи в шаблон car.html
						<br>blog/views.py - class ShowCar
						<pre>
class ShowCar(SuccessMessageMixin, DataMixin, DetailView, FormMixin):
	......
	......
	# Личная оценка пользователя
    def get_my_rel(self, **kwargs):
        # пробуем получить объект (запись по реакции нашего пользователя)
        # по конкретной статье и конкретному пользователю
        try:
            # если объект найдём - реакция пользователя = этот объект
            my_rel = UserCarRelation.objects.get(user_relation__pk=self.request.user.pk,
                                                 car_relation__slug=self.kwargs['car_slug'])

        except UserCarRelation.DoesNotExist:  # если объекта не существует
            my_rel = 0  # реакции пользователя = 0
        # возвращаем реакции конкретного пользователя если
        return my_rel

    .....
    def get_context_data(self, object_list=None, **kwargs):
    	....
		c_def = self.get_user_context(cat_selected=....,
                                      ....,  # получаю рейтинг
                                      my_rel=self.get_my_rel())  # получаю реакции</pre>

					</li>
					<li>
						Чтобы проверить/вызвать реакции от пользователя залогиненного, к конкретому посту в шаблоне - необходимо вызвать
						<pre>
{% if my_rel != 0 %}  # это проверка, оставлял ли залогиненный пользователь какуюто реакцию на данный мост

Лайк = {{ my_rel.is_like_post }}  --> True или False
Закладки = {{ my_rel.is_bookmarks_post }}  --> True или False
Личный рейтинг = {{ my_rel.rate }}  -->  Личный рейтинг</pre>
						<br><span>
							-Необходимо добавить проверки (стоит ли лайк/ добавил ли в закладки) - И в соответствии с этим измненять отображение кнопки лайк и ли галочки закладки, с соответствующими url на добавление или удаление
							<br>-Необходимо выводить форму (Звёзды рейтинга) - Причём даже если и поставили звёзды - необходима возможность редактирования
							(проблема в том что форма уже есть на странице, и вроде как не получится добавить другую - необходимо пробовать с помошью пользовательского тега либо вообще какой то другой способ)
						</span>
					</li>
					<li>
						<span class="spec">
							Добавил форму добавления реакции (рейтинг статьи)
							<br>Форма рабочая, пока в отдельном шаблоне
							<br>Но она не проверяет реагировал ли уже пользователь или нет, в итоге при втором реагировании ошибка - нужно сделать так что если уже реакция была, то запись в бд необходимо изменить а не создавать ещё одну!
						</span>
						<br>На данные момент
						<br>
						views.py
						<pre>
# форма рабочая
def rate_post_form(request, cat_slug, car_slug):
    car = Car.objects.get(slug=car_slug)
    if request.method == 'POST':
        form = UserCarRelationRateForm(request.POST)
        if form.is_valid():
            usercarrelation = form.save(commit=False)
            usercarrelation.user_relation = request.user
            usercarrelation.car_relation = car
            usercarrelation.save()
            return redirect('car', cat_slug, car_slug)
    else:
        form = UserCarRelationRateForm()

    qs = UserCarRelation.objects.all()
    context = {'form': form, 'qs': qs, 'car': car,}
    return render(request, 'blog/add_rate_post.html', context=context)</pre>
    					<br><br>
    					urls.py
    					<pre>
    						path('category/&lt;slug:cat_slug>/&lt;slug:car_slug>/rate_car/', rate_post_form, name='rate_car'),
    					</pre>
    					<br><br>
    					отдельны шаблон - add_rate_post.html
    					<pre>
&lt;form action="{% url 'rate_car' car_slug=car.slug cat_slug=car.cat.slug %}" method="post">
    {% csrf_token %}
    &lt;div class="text-info">{{ form.non_field_errors }}&lt;/div>
    {{ form.as_ul }}
    &lt;div class="text-info">{{ form.errors }}&lt;/div>
    &lt;button type="submit" class="btn btn-primary btn-lg">
        Сохранить
    &lt;/button>
&lt;/form></pre>
					</li>
					<br><br>
					<li style="background: black;">

						<span class="title_text">Удаляю/изменяю из проекта всё что ранее делал относительно рейтинга к посту</span>
						<hr>
						<ol>							
							<li>
								<span class="spec">Удаляю</span>
								Из шаблона car.html - временно уберу всё что ствязно с рейтингом и лайками к постам -  в отдельный файл html - так как будут проблемы, буду менять функции буду менять модели. Оставлю это дело в отдельном файле - для экономии времени в будущем
								<br> - Эта информация будет в (hlam)rating_car.html
							</li>
							<li>
								<span class="spec">Удаляю</span>
								Туда же в - (hlam)rating_car.html  - перенесу информацию из 
								class ShowCar(SuccessMessageMixin, DataMixin, DetailView, FormMixin):
								<br>Получение рейтинга общего, получение записей о реакциях пользователя(буду использовать для лайков и закладок)
								<pre>
_______________________________________________________
blog/VIEWS.PY

class ShowCar(SuccessMessageMixin, DataMixin, DetailView, FormMixin):
	....
	........
	.....
	....

	# метод получения рейтинга поста
    def get_rating(self, **kwargs):
        # получение всех записей, отношений к данному посту
        users_ralations = UserCarRelation.objects.filter(car_relation__slug=self.kwargs['car_slug'])
        sum_rate = 0  # промежуточная переменная - сумма всех рейтингов
        # если количество записей отношений больше нуля 0
        if users_ralations.count() > 0:
            # перебираем все записи отношений
            for one_relation in users_ralations:
                # в промежуточную переменную прибавляем рейтинг отдельной записи
                sum_rate += one_relation.rate
            # полную сумму оценок делим на количество оценок и получаем рейтинг
            rating = sum_rate / users_ralations.count()
        else:
            rating = 0
        return rating


    # Личная оценка пользователя
    def get_my_rel(self, **kwargs):
        # пробуем получить объект (запись по реакции нашего пользователя)
        # по конкретной статье и конкретному пользователю
        try:
            # если объект найдём - реакция пользователя = этот объект
            my_rel = UserCarRelation.objects.get(user_relation__pk=self.request.user.pk,
                                                 car_relation__slug=self.kwargs['car_slug'])

        except UserCarRelation.DoesNotExist:  # если объекта не существует
            my_rel = 0  # реакции пользователя = 0
        # возвращаем реакции конкретного пользователя если
        return my_rel



    def get_context_data(self, object_list=None, **kwargs):
    	......
    	c_def = self.get_user_context(cat_selected=self.kwargs['cat_slug'],
                                      rating=self.get_rating(),  # получаю рейтинг - УДАЛИЛ
                                      my_rel=self.get_my_rel())  # получаю реакции - УДАЛИЛ

_______________________</pre>
							</li>
							<li>
								<span class="spec">Удаляю</span>
								ранее созданные формы (для получения рейтинга)
								<br>relatepost/forms.py
								<pre>
<span class="spec">DELETE</span>
from django import forms
from relatepost.models import UserCarRelation


# форма рейтинга поста
class UserCarRelationRateForm(forms.ModelForm):
    class Meta:
        model = UserCarRelation
        fields = ['rate',]</pre>
							</li>
							<li>
								<span class="spec">Удаляю</span> из blog/views.py
								<pre>
# форма рабочая (рейтинг статьи)
def rate_post_form(request, cat_slug, car_slug):
    car = Car.objects.get(slug=car_slug)
    if request.method == 'POST':
        form = UserCarRelationRateForm(request.POST)
        if form.is_valid():
            usercarrelation = form.save(commit=False)
            usercarrelation.user_relation = request.user
            usercarrelation.car_relation = car
            usercarrelation.save()
            return redirect('car', cat_slug, car_slug)
    else:
        form = UserCarRelationRateForm()

    qs = UserCarRelation.objects.all()
    context = {'form': form, 'qs': qs, 'car': car,}
    return render(request, 'blog/add_rate_post.html', context=context)</pre>
							</li>
							<li>
								Из blog/urls.py удаляю маршрут
								<pre>path('category/&lt;slug:cat_slug>/&lt;slug:car_slug>/rate_car/', rate_post_form, name='rate_car'),</pre>
							</li>
							<li>
								в relate/models.py Изменяю модель UserCarRelation.
								<br>Переименую
								<br>Удалю поле rate
								<br>Удалю RATE_CHOICES
								<br>Изменб __str__
								<br><strong>Отныне данная модель будет отвечать только за лайки и закладки поста!</strong>
								<pre>
class UserCarRelation(models.Model): ---> UPDATE
--->

# Лайки и закладки к посту
class LikeMarkPost(models.Model):
    # какой пользователь
    user_like_mark = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='Пользователь Л-З')
    # какой пост
    post_like_mark = models.ForeignKey(Car, on_delete=models.CASCADE, verbose_name='Пост Л-З')
    # лайк на пост
    is_like_post = models.BooleanField(default=False, verbose_name='Лайк поста')
    # добавление в закладки
    is_bookmarks_post = models.BooleanField(default=False, verbose_name='Пост в закладке')

    class Meta:
        verbose_name = 'Лайк/Закладка поста'
        verbose_name_plural = 'Лайки/закладки к посту'

    def __str__(self):
        return f'Пользователь: {self.user_like_mark.username} - Статья: {self.post_like_mark.slug}.'</pre>
							</li>
							<li>
								В relatepost/admin подкорректирую - отображение модели в админке, включая название моделей!
								<pre>
from django.contrib import admin
from relatepost.models import LikeMarkPost


# лайки закладки в админке
class LikeMarkPostAdmin(admin.ModelAdmin):
    # список отображаемых столбцов в админ-панели
    list_display = ('id', 'user_like_mark', 'post_like_mark', 'is_like_post', 'is_bookmarks_post')
    # список полей на которые можно кликнуть - для редактирования
    list_display_links = ('user_like_mark', 'post_like_mark')
    # список полей - ко которым можно вести поиск
    search_fields = ('user_like_mark', 'post_like_mark')
    # редактирование поля публикации - в списке - в админке
    list_editable = ('is_like_post', 'is_bookmarks_post')  # запятая - если 1 поле!
    # фильтр по полям - публикация, время изменения.
    list_filter = ('user_like_mark', 'post_like_mark')


# Register your models here.
admin.site.register(LikeMarkPost, LikeMarkPostAdmin)</pre>
							</li>
							<li>
								Создаю и применяю миграции
							</li>
						</ol>

					</li>



<br><br>
					<li>

						<span class="title_text">Делаю рейтинг с помошью ajax и hoogan.js </span>
						<hr>
						<ol>
							<li>
								В blog/static/js - создаю файл scripts.js
							</li>
							<li>
								В base.html, в конце перед закрытием body<br>
								- Добавляем ссылку на наш scritpts.js<br>
								- Добавляем библиотеку hogan hoogan.js (ссылку нужно брать из интернета)
								<br>- hogan - это шаблонизатор js , вместо него можно использовать например Vue
								<br><a href="https://twitter.github.io/hogan.js/">
									Установка и инструкция по hogan 
								</a>
								<br><br>Итого наш base.html
								<pre>
...									
&lt;!-- Наш static -  scripts.js -->
&lt;script src="{% static 'blog/js/scripts.js' %}">&lt;/script>

&lt;!-- JS шаблонизатор (почти Vue) hogan.js -->
&lt;script src="http://twitter.github.com/hogan.js/builds/3.0.1/hogan-3.0.1.js">&lt;/script>

&lt;/body>
....</pre>
							</li>							
					
					</li>

					<li>
						relatepost/models.py - делаю новую модель - (просто звёзды 1,2,3,4,5)
						<pre>
# Просто звёзды от 1 до 5 (одна звезда 1 запись)
class RatingStar(models.Model):
    value = models.SmallIntegerField(verbose_name='Значение', default=0)

    def __str__(self):
        return f'{self.value}'
    
    class Meta:
        verbose_name = 'Звезда рейтинга'
        verbose_name_plural = 'Звёзды рейтинга'
        ordering = ['-value']</pre>
					</li>
					<li>
						Зарегистрирую эту модель в админке
						<br>relatepost/admin.py
						<pre>
from relatepost.models import ..., RatingStar

# просто звёзды в админке
class RatingStarAdmin(admin.ModelAdmin):
    list_display = ('id', 'value')


# Register your models here.
admin.site.register(RatingStar, RatingStarAdmin)</pre>
					</li>
					<li>
						Создам и мприменю миграции
						<pre>
python manage.py makemigrations
python manage.py migrate</pre>
					</li>
					<li>
						Создам в админке 5 записей в этой модели
						<pre>1 2 3 4 5</pre>
					</li>
					<li>
						Добалю модель Rating в relatepost/models.py
						<pre>
# Рейтинг (конкретный пользователь, конкретная статья)
class Rating(models.Model):
    user_rate = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='Оценивающий пользователь')
    post_rate = models.ForeignKey(Car, on_delete=models.CASCADE, verbose_name='Оцениваемый пост')
    star = models.ForeignKey(RatingStar, on_delete=models.CASCADE, verbose_name='Звезда')

    def __str__(self):
        return f'Звезда: {self.star}, Пост: {self.post_rate}, Юзер: {self.user_rate}'

    class Meta:
        verbose_name = 'Рейтинг пользователя к посту'
        verbose_name_plural = 'Рейтинги пользователей к постам'</pre>
					</li>
					<li>
						Зарегистрирую модель Rating в админ панеле
						<br>relatepost/admin.py
						<pre>
from relatepost.models import .., Rating

# Рейтинг в админке (конкретный пользователь, конкретная статья)
class RatingAdmin(admin.ModelAdmin):
    list_display = ('id', 'user_rate', 'post_rate', 'star')
    list_display_links = ('user_rate', 'post_rate')
    search_fields = ('user_rate', 'post_rate')
    list_editable = ('star',)  # запятая - если 1 поле!
    list_filter = ('star',)

admin.site.register(Rating, RatingAdmin)</pre>
					</li>
					<li>
						Необходимо удалить поле rating - в модели Car - его мы не использовали, но он выдал ошибку так как поле рейтинг совпадало с именеи модели Rating, при том что из Rating  -> ForeingKey -> Car
					</li>
					<li>
						Создаю и применяю миграции
						<pre>
python manage.py makemigrations
python manage.py migrate</pre>
					</li>
					<li>
						Создаём форму, для изменения рейтинга
						<br>relatepost/forms.py
						<pre>
# форма изменения и добавления рейтинга к посту
class RatingForm(forms.ModelForm):
    # где empty_label - это чёрточки при выборе(например категорий)
    # RadioSelect - это тыканье на кнопку вместо выпадающего списка (есть чек бокс,
    # queryset - Это все записи, то есть все звёзды 1 2 3 4 5

    # здесь мы переопределяем поле star
    star = forms.ModelChoiceField(
        queryset=RatingStar.objects.all(), widget=forms.RadioSelect(), empty_label=None
    )

    class Meta:
        model = Rating  # связь с моделью юзер-пост-рейтинг
        fields = ('star',)</pre>
					</li>
					<li>
						В blog/views.py - добавляем форму в представление одного поста, в контект
						<br>class ShowCar

						<pre>
from relatepost.forms import RatingForm

# страница отдельной машины
class ShowCar(SuccessMessageMixin, DataMixin, DetailView, FormMixin):
	....
    def get_context_data(self, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)  # распаковываем изначальный контекст

        context['star_form'] = RatingForm()  # добавлеем нашу форму в контекст (ключ star_form: значение=наша форма)

        c_def = self.get_user_context(cat_selected=self.kwargs['cat_slug'])       
        return {**context, **c_def}  # в шаблон передаём полный контекст</pre>
					</li>
					<li>
						В car.html - добавляем форму
						<pre>
&lt;form action="{% url 'add_rating' %}" method="post" name="rating">
	&lt;b>Рейтинг&lt;/b>
	{% csrf_token %}


	&lt;input type="hidden" value="{{ car.id }}" name="car">


	&lt;span class="rating">
		{% for k, v in star_form.fields.star.choices %}
			&lt;input id="rating{{ v }}" type="radio" name="star" value="{{ k }}">
			&lt;label for='rating{{ v }}'>
			&lt;!-- {{ k }} Если поставить k - то будет дубликат непонятно почему!-->
			&lt;/label>
		{% endfor %}
	&lt;/span>
	&lt;span class="editContenr">4.0&lt;/span>
&lt;/form></pre>
					</li>
					<li>
						В blog/static/blog/imeges добавляю 2 изображения, жёлтая и прозрачная звезда
						<pre>
star-off-big.png
star-on-big.png</pre>
					</li>
					<li>
						В blog/static/blog/css/styles.cc - добавляем стили для формы, добавляем стили
						<pre>
/* Чекбоксы ретинга - Звёзды рейтинга */
.rating {
  overflow: hidden;
  vertical-align: bottom;
  display: inline-block;
  width: 155px;
  height: 30px;
}

.rating > input {
  opacity: 0;
  margin-right: -100%;
}

.rating > label {
  position: relative;
  display: block;
  float: right;
  background: url('../images/star-off-big.png');
  background-size: 30px 30px;
}

.rating > label:before {
  display: block;
  opacity: 0;
  content: '';
  width: 30px;
  height: 30px;
  background: url('../images/star-on-big.png');
  background-size: 30px 30px;
  transition: opacity 0.2s linear;
}

.rating > label:hover:before,  .rating > label:hover ~ label:before,  .rating:not(:hover) > :checked ~ label:before { opacity: 1; }
/* //Чекбоксы ретинга - Звёзды рейтинга */</pre>
					</li>
					<li>
						Добавляем JS в наш scripts.js
						<pre>
// Добавление рейтинга к статьям
// 1. в файле scripts.js - в документе, с помощью querySelector - ищем форму rating
const rating = document.querySelector('form[name=rating]');

// 2. когда у формы вызовится событие change
rating.addEventListener("change", function (e) {
    // Получаем данные из формы
    // 3. создавая FormData и передав нашу форму, мы получим значение наших полей
    let data = new FormData(this);
    // 4. с помощью fetch, на url из нашей action={% url %}, передаём пост запросы, в теле body нашу data
    fetch(`${this.action}`, {
        method: 'POST',
        body: data
    })
    // 5. При успешном ответе - Рейтинг установлен, при отрицательном - Ошибка
        .then(response => alert("Рейтинг установлен"))
        .catch(error => alert("Ошибка"))
});</pre>
					</li>
					<li>
						Создадим urls.py в relatepost (app) и внутри него создадим маршрут
						<pre>
from django.urls import path
from .views import *

urlpatterns = [
    path('add-rating/', AddStarRating.as_view(), name='add_rating'),
]</pre>
					</li>
					<li>
						В основной urls.py (avtoblog/urls.py) - включим ранее созданный relatepost/urls.py
						<pre>
urlpatterns = [
    ....('admin/', admin.site.urls),
	.....
    path('', include('relatepost.urls')),  # путь к путям приложения relatepost
]</pre>
					</li>
					<li>
						В relatepost/views.py - добавляем представления ajax
						<pre>
from django.http import HttpResponse
from django.views import View
from relatepost.forms import RatingForm
from relatepost.models import Rating

# Добавление рейтинга к Посту
class AddStarRating(View):
    def post(self, request):
        form = RatingForm(request.POST)
        if form.is_valid():
            Rating.objects.update_or_create(
                user_rate=request.user,
                post_rate_id=int(request.POST.get('car')),
                defaults={'star_id': int(request.POST.get('star'))}
            )
            return HttpResponse(status=201)
        else:
            return HttpResponse(status=400)</pre>
					</li>
					<li>
						Полный блок кода, с рейтингом выглядит так
						<br>car.html (необходимо добавить лайки и комментарии)
						<pre>
&lt;span class="text-secondary">Обновлено: {{ car.time_update }}&lt;/span>
&lt;ul class="list-group">
	&lt;li class="list-group-item list-group-item bg-dark bg-gradient text-white">
		&lt;h3>Автор статьи: {{ car.author }}&lt;/h3>
	&lt;/li>
	&lt;li class="list-group-item list-group-item-secondary">
		&lt;div class="d-flex justify-content-between">
			&lt;div class="pt-2 bd-highlight">
				&lt;b>Общий рейтинг: 4.73&lt;/b>
			&lt;/div>

			&lt;!-- кнопки лайк и закдадка -->
				&lt;div class="p-1 bd-highlight">
				&lt;a class="btn btn-outline-danger btn-xl" href="#">Закладка&lt;/a>
    			&lt;a class="btn btn-outline-danger btn-xl" href="#">Лайк&lt;/a>
			&lt;/div>
		&lt;/div>
	&lt;/li>

	&lt;li class="list-group-item list-group-item-success bg-gradient">

		&lt;!-- форма звёзд -->
	    {% if request.user.is_authenticated %}
			&lt;form action="{% url 'add_rating' %}" method="post" name="rating">
				&lt;b>Оцените статью:&lt;/b>
				{% csrf_token %}
				&lt;!-- скрытое поле -->
				&lt;input type="hidden" value="{{ car.id }}" name="car">
				&lt;span class="rating">
					&lt;!-- in форма.поля.поле стар -->
					{% for k, v in star_form.fields.star.choices %}
						&lt;input id="rating{{ v }}" type="radio" name="star" value="{{ k }}">
						&lt;label for='rating{{ v }}'>
							&lt;!-- {{ k }} Если поставить k - то будет дубликат непонятно почему!-->
						&lt;/label>
					{% endfor %}
				&lt;/span>			
			&lt;/form>
		{% endif %}
	&lt;/li>
&lt;/ul></pre>
				</ol>
			</li>
			<br><br>
			<li>
				Лайки к посту
			</li>
			<li>
				Лайки закладки к посту
			</li>
			<li>
				Вывол общего рейтинга
			</li>
			<li>
				Отображение звёзд что после обновления страницы
			</li>


&lt;



			<br><br><br><br><br><br><br><br><br>
			<li>
				<span class="title_text">Сделаю на сайте отдельное приложение магазина (глобально! - подкорректирую шаблоны для магазина, добавлю цены, корзину, модели корзины  итд)</span>
				<br>
				<span class="spec">В разделе будет много полезной информации: информация сессии, добавление количеста чегото (оставаяь на той же странице), расчёты в моделях и так далее</span>
				<hr>
				<ol type="I">
					<li>
						<span class="title_text">Создаю новое приложение shop, регистрирую настраиваю</span>
						<hr>
							<ol type="a">
								<li>
									создаю приложение
								</li>
								<li>
									регистрирую в INSTALLED_APPS
								</li>
							</ol>
					</li>
					<li>
						<span class="title_text">МАГАЗИН</span>
						<hr>
							<ol type="a">
								<li>
									магазин
								</li>
								<li>
									магазин
								</li>
							</ol>
					</li>


					<li>
						<span class="title_text">МАГАЗИН</span>
						<hr>
							<ol type="a">
								<li>
									магазин
								</li>
								<li>
									магазин
								</li>
							</ol>
					</li>




					<li>
						<span class="title_text">МАГАЗИН</span>
						<hr>
							<ol type="a">
								<li>
									магазин
								</li>
								<li>
									магазин
								</li>
							</ol>
					</li>
					


					<li>
						<span class="title_text">МАГАЗИН</span>
						<hr>
							<ol type="a">
								<li>
									магазин
								</li>
								<li>
									магазин
								</li>
							</ol>
					</li>



					<li>
						<span class="title_text">МАГАЗИН</span>
						<hr>
							<ol type="a">
								<li>
									магазин
								</li>
								<li>
									магазин
								</li>
							</ol>
					</li>
				</ol> <!-- магазин -->
			</li> <!-- магазин -->
			<br><br><br><br><br><br><br><br><br>

&lt;





			<li>
				<span class="title_text">Что делаем</span>
				<hr>
				<ol>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
				</ol>
			</li>


&lt;




			<li>
				<span class="title_text">Что делаем</span>
				<hr>
				<ol>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
				</ol>
			</li>


&lt;





		</ol><!-- общий список -->
	</div><!-- container-md all -->
&lt; &lt; &lt;

# Ctrl + Alt + L 

	<br>
	<br><br><br><br>


	<div class="container-md all_2"><!-- container-md all ОБЩИЙ -->
		<h1 class="title_text border">Полезности</h1><br>
		<hr>
		<ol><!-- общий список -->
			<li>
				<span class="title_text">
					Получение динамического маршрута [3 динамических параметра из трёх разных моделей] 
					<br>.../cat_slug/car_slug/com_id
					<br>http://127.0.0.1:8000/category/uk/aston-martin-db11-amr/57/
				</span>
				<hr>
				<ol>
					<li>
						В модели крайнего параметра - Comment - добавляем метод get_absolute_url
						<br>models.py - Comment
						<pre>
# функция формирования маршрута к ссылке
def get_absolute_url(self):  # self - ссылка на один экземпляр(строку) таблицы модели
    # reverse('имя пути', kwargs={ Category-slug, Car-slug, Comment-slug}
    return reverse('sss_path', kwargs={'cat_slug': self.car_post.cat.slug,
                                       'car_slug': self.car_post.slug,
                                       'com_id': self.pk})</pre>
                        <br>-sss_path - это имя маршрута
                        <br>-self.car_post.cat.slug = Category - поле slug
                        <br>-self.car_post.slug = Car - поле slug
                        <br>-self.self.pk = Comment - поле slug
                        <br>
                        <br>
                        где car_post = ForeignKey Car | cat = ForeignKey Category
                        <br>То есть самой удалённой модели дошли до первой, с помощью ForeingKey
					</li>
					<li>
						Пишем маршрут для всего этого в urls.py - urlpatterns
						<pre>path('category/&lt;slug:cat_slug>/&lt;slug:car_slug>/&lt;int:com_id>/', comment, name='sss_path'),</pre>
						<br>comment - функция представления
					</li>
					<li>
						Делаем функцию представления
						<pre>
def comment(request, cat_slug, car_slug, com_id):
    comment_post = Comment.objects.get(pk=com_id)
    context = {'comment_post': comment_post}
    return render(request, 'blog/sss.html', context=context)</pre>
    					<br>cat_slug, car_slug, com_id - это параметры из get_absolute_url - в модели
					</li>
					<li>
						Создаём шаблон sss.html - в нём пару параметров для понимания
						<pre>
Комментарий с ID/PK: {{ comment_post.pk }}
ТЕКСТ Комментария: {{ comment_post.text_comment }}
Автор Комментария: {{ comment_post.author_comment }}
Название статьи, на которую сделан комментарий: {{ comment_post.car_post.title }}
Название категории, где находится статья, на которой сделан комментарий: {{ comment_post.car_post.cat.name }}</pre>
						<span class="spec">
							Причём в контектс шаблона мы отправляли только комментарий - но внетри шаблона через комментарий добрались до статьи, а через статью добрались и до категории!
						</span><br><br>
					</li>
					<li>
						<span class="spec">Ссылка на страницу с тремя динамическими параметрами</span><br>
						Получаем url, ссылку на html странице, для того чтобы перейти со страницы статьи на страницу комментария
						<br>Шаблон car.html (статья)
						<pre>
&lt;a href="{% url 'sss_path' car_slug=car.slug cat_slug=car.cat.slug com_id=сom_element.pk %}">Ссылка на каждый комментарий&lt;/a></pre>
						<br>
						<span class="spec">
							-sss_path - имя маршрута<br>
							-далее без запятых, в любом порядке(вроде) необходимо указать все динамические параметры, до них всегда можно добраться с той страницы где размещаем ссылку<br>
							-сom_element - это одна статья (элемент цикла for) - я сам назвал её так в шаблоне, ничего трудного
						</span><br><br><br><br>
						<span class="spec">ИЛИ</span>
						<hr><br><br><br><br>
					</li>
					<li>
						<span class="spec">Создание ссылки в шаблоне a href=''  - с помощью get_absolute_url (предпочтительнее далать так!)</span>
						
						<pre>
&lt;a href="{{ сom_element.get_absolute_url }}">Cсылка через get_absolute_url&lt;/a>

# ссылка равносильна - {% url 'sss_path' car_slug=car.slug cat_slug=car.cat.slug com_id=сom_element.pk %}
# сom_element - это одна запись из модели Comment (просто взятая из цикла for)
</pre>
					</li>
				</ol>
			</li>

			<li>
				<span class="title_text">
					Получение информации о пользователе в сессии (в представлении, в шаблоне) request.user
				</span>
				<hr>
				<ul>
					<li>
						Получение данных о пользователи (какой пользователь аутентифицирован) в views.py - из реквеста
						<pre>
def sample_view(request):
    current_user = request.user
    print current_user.id</pre>
					</li>
					<li>
						Получение записи одного пользователя в request - из модели User
						<pre>
def show_profile(request):
    current_user = request.user

    user_info = User.objects.get(username=current_user)</pre>
				    	<br>Передача в шаблон
				    	<pre>
def show_profile(request):
    current_user = request.user

    user_info = User.objects.get(username=current_user)

    all_user = User.objects.all()
    context = {
        'all_user': all_user,
        'current_user': current_user,
        'user_info': user_info,
    }
    return render(request, 'account/profile.html', context=context)</pre>
				    	<br>Отображение в шаблоне
				    	<pre>
login: {{ user_info.username }}
мыло: {{ user_info.email }}
Имя: {{ user_info.first_name }}
Фамилия: {{ user_info.last_name }}
Пароль: {{ user_info.password }}</pre>
					</li>
					<li>
						Проверка аутетефицирован ли пользователь в функции представления
						<pre>
if request.user.is_authenticated:
    # Do something for authenticated users.
else:
    # Do something for anonymous users.</pre>
				    <li>
				    	Проверка аутентефицирован ли пользователь внутри шаблона
    	<pre>
{% if request.user.is_authenticated %}
блок кода покажета если пользователь щалогинен</pre>
				    </li>
				    <li>
				    	Получение id пользоватьеля из request
				    	<pre>request.user.id</pre>
				    </li>
				    <li>
				    	<span class="spec">ПЕРЕДАВАТЬ ЗНАЧЕНИЯ ПОЛЬЗОВАТЕЛЯ В ШАБЛОН НЕ ОБЯЗАТЕЛЬНО</span>
				    	его передаёт request.   (requuest.user) 
				    	<br>Можно просто сразу обращаться в шаблоне {{user}} {{user.id}} {{user.last_name}} и тд
				    </li>
				    <li>
				    	<span class="spec">Что хранится в request? - полный список</span>
				    </li>
				</ul>
			</li>

		</ol><!-- общий полезности -->
	</div><!-- общий полезности -->

&lt;


















<ol>
	<li>
		Получение данных о пользователи (какой пользователь аутентифицирован) в views.py - из реквеста
		<pre>
def sample_view(request):
    current_user = request.user
    print current_user.id</pre>
	</li>
	<li>
		Получение записи одного пользователя в request - из модели User
		<pre>
def show_profile(request):
    current_user = request.user

    user_info = User.objects.get(username=current_user)</pre>
    	<br>Передача в шаблон
    	<pre>
def show_profile(request):
    current_user = request.user

    user_info = User.objects.get(username=current_user)

    all_user = User.objects.all()
    context = {
        'all_user': all_user,
        'current_user': current_user,
        'user_info': user_info,
    }
    return render(request, 'account/profile.html', context=context)</pre>
    	<br>Отображение в шаблоне
    	<pre>
login: {{ user_info.username }}
мыло: {{ user_info.email }}
Имя: {{ user_info.first_name }}
Фамилия: {{ user_info.last_name }}
Пароль: {{ user_info.password }}</pre>
	</li>
	<li>
		Проверка аутетефицирован ли пользователь в функции представления
		<pre>
if request.user.is_authenticated:
    # Do something for authenticated users.
else:
    # Do something for anonymous users.</pre>
    <li>
    	Проверка аутентефицирован ли пользователь внутри шаблона
    	<pre>
{% if request.user.is_authenticated %}
блок кода покажета если пользователь щалогинен</pre>
    </li>
    <li>
    	Получение id пользоватьеля из request
    	<pre>request.user.id</pre>
    </li>
    <li>
    	<span class="spec">ПЕРЕДАВАТЬ ЗНАЧЕНИЯ ПОЛЬЗОВАТЕЛЯ В ШАБЛОН НЕ ОБЯЗАТЕЛЬНО</span>
    	его передаёт request.   (requuest.user) 
    	<br>Можно просто сразу обращаться в шаблоне {{user}} {{user.id}} {{user.last_name}} и тд
    </li>
    <li>
    	<span class="spec">Что хранится в request? - полный список</span>
    </li>


</ol>





<!-- JS Bootstrap 5 -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-gtEjrD/SeCtmISkJkNUaaKMoLD0//ElJ19smozuHV6z3Iehds+3Ulb9Bn9Plx0x4" crossorigin="anonymous"></script>


</body>
</html>


