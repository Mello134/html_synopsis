<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- css bootstrap 5 -->
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x" crossorigin="anonymous">

	<title>Автоблог - конспект работы</title>

	<style type="text/css">
		
		pre{
			color: black;
			background: #ffe2e2;
			margin-right: 30px;
			margin-left: 15px;
			margin-bottom: 2px;
			margin-top: 5px;
		}
		
		.all{
			background: #003802;
			color: white;

		}

		.all_2{
			background: black;
			color: white;

		}
		
		body{
			background: #c1ffcb;
		}
		
		.spec {
			font-size: 18px;
			letter-spacing: .2em;
			font-weight: 500;
/*			text-transform: uppercase;*/
			color: #ff7575;
			margin-top: 15px;
			margin-bottom: 2px;
		}

		.title_text {
			letter-spacing: .1em;
			font-weight: 500;
			color: #f2cb71;
			font-size: 25px;

		}

	</style>


&lt; &lt; &lt;
</head>


<body>
<span class="spec">
	Добавь redirect на ту страницу с которой был сделан комментарий/лайк или закладка.<br>
	Проверка HttpRequest.path?  if in request....name = 'имя': redirect 'имя'
	<br><br>
	ИЛИ даже лучше.  rerirect('HttpRequest.path.name')!!!
</span>
<a href="https://djangodoc.ru/3.2/ref/request-response/">request-response</a>
<br>


<span class="spec">Измени поле url / slug чтобы оно автомотически заполнилось на основании tittle - в форме создания поста с сайта</span>
<a href="https://qna.habr.com/q/303008">https://qna.habr.com/q/303008</a>
<br>

<span class="spec">Добавть поле chit_url в модели YT, при добавления видео, чтобы из "https://youtu.be/_atWFaLnRqs"  получалось  "https://www.youtube.com/embed/_atWFaLnRqs" </span>
<br>



<!-- 	<p><a href="https://www.youtube.com/@selfedu_rus">selfedu</a></p>
	<p><a href="https://www.youtube.com/watch?v=FyTL1bnUx5I&list=PLA0M1Bcd0w8xO_39zZll2u1lz_Q-Mwn1F">Django 3 для Python(плейлист)</a></p> -->
	<p><a href="https://proproprogs.ru/django">https://proproprogs.ru/django</a></p>
	<p><a href="https://django.fun/ru/articles/tutorials/">Статьи о Django</a></p>
	<p><a href="https://habr.com/ru/post/514348/">Шесть Python-пакетов, которые рекомендуется использовать в каждом веб-приложении на Django</a></p>
	<p><a href="https://django.fun/ru/docs/">Документация по фреймворку и библиотекам Django</a></p>
	<p><a href="https://translated.turbopages.org/proxy_u/en-ru.ru.5b0ed4c9-6378aa3f-3f4ce05c-74722d776562/https/hackr.io/blog/top-django-interview-questions-and-answers">50 лучших вопросов и ответов для интервью Django на 2022 год</a></p>
	<p><a href="https://pypi.org/">pypi.org</a></p>


	<div class="container-md all"><!-- container-md all ОБЩИЙ -->
		<h1 class="title_text border">Автоблог</h1><br>
		<hr>

		<!-- <img src="images\avtoblog\host.jpg" class="img-fluid"><br> -->



		<ol><!-- общий список -->


			<li>
				<span class="title_text">Старт проекта</span>
				<hr>
				<ol>

					<li>
						Сделал окружение
					</li>
					<li>
						Создаём Новый проект в PyCharm - C:\Хранилище\IT\IT Projects\avtoblog-project
						<br>Окружение venv_2022 - указывал путь к venv_2022\Scripts\python.exe
					</li>
					<li>
						Внутри окружения уже есть большинство пакетов которые будут необходимы:
						<br>-Pillow - для работы с изображениями
						<br>-django-crycpy-forms - использовал в eccomerce
						<br>-Django 4.1.3
						<br>-psycopg2 - для работы с PostgreSQL
						<br>-virtuslenv
						<br>-pip
						<br><br>Консоль работает, должно быть всё норм
					</li>
					<li>
						Стартую проект django
						<pre>django-admin startproject avtoblog</pre>
						<br>В ручную подкорректировал папки в проекте:
						<br>-IT Projects\avtoblog-project\avtoblog (manage.py в avtoblog, .idea - в avtoblog-project)
						<br>-В Pycharm - папке avtoblog-project - присвоил source root
					</li>
				</ol>
			</li>

			<li>
				<span class="title_text">Git, .gitignore, База данных, настройка времени языка</span>
				<hr>
				<ol>

					<li>
						Из <a href="www.toptal.com">www.toptal.com</a> генерируем .gitignore  - и помещаем в avtoblog-project
						<br>Раскомментируй .idea/ поставь сверху
					</li>
					<li>
						Создаём Базу данных DB - Для проекта в SQL Shell (PostgreSQL)
						<pre>
Server [localhost]:
Database [postgres]:
Port [5432]:
Username [postgres]:
Пароль пользователя postgres:blog1234

psql \! chcp 1251  # для отображении кириллицы
\l смортрим список всех DB
CREATE DATABASE avtoblogdb;  # создали базу данных - avtoblogdb
-->CREATE DATABASE
\l - смотрим DB создана
				</pre>
					</li>
					<li>
						Сразу привыязваем наш проект к базеданных postgreSQL - avtoblogdb - в settings.py
						<pre>
DATABASES = {
    'default': {
        # 'ENGINE': 'django.db.backends.sqlite3',  # стандартная БД
        # 'NAME': BASE_DIR / 'db.sqlite3',  # стандартная БД
        'ENGINE': 'django.db.backends.postgresql',  # БД PostrgeSQL
        'NAME': 'avtoblogdb',  # Имя нашей БД
        'USER': 'postgres',  # пользователь postgres - который создал БД
        'PASSWORD': 'blog1234',  # пароль в PostgreSQL, для пользователя postgres
        'HOST': '127.0.0.1',  # либо просто - 'localhost'
        'PORT': '5432',  # стандартный порт
    }
}</pre>
					</li>
					<li>
						В settings.py сразу настроим часовой пояс и русский язык в админке
						<pre>
LANGUAGE_CODE = 'ru-Ru'  # русский язык в admin

TIME_ZONE = 'Europe/Moscow'  # время по МСК</pre>
					</li>
					<li>
						На github - создадим репозиторий - avtoblog
					</li>
					<li>
						Инициализируем git репозиторий на PC, и запушим первый коммит
						<pre>
git –v  # посмотреть версию git
git init  # инициализируем git репозиторикй- папку на pc
git status  # смотрим какие файлы не отслеживаются на данный момент
git add .  # добавляем все файлы
git status  # смотрим что теперь всё отслеживается
git commit -m "имя коммита(что сделали/стадия)"  # создаём коммит
git remote add origin  - https://github.com/Mello134/репозиторий.git  # туда будем загружать
git branch -M main
git push -u origin main  # отправили на github - в репозитор</pre>
					</li>

				</ol>
			</li>


			<li>
				<span class="title_text"> Создание и регистрация приложения<br>Расшарение маршрутов urls.py [ inclide() ]</span>
				<hr>
				<ol>

				
					<li>
						Создаём приложение blog в avtoblog-project
						<pre>python manage.py startapp blog</pre>
					</li>
					<li>
						Регистрируем приложение blog в settings.py - INSTALLED_APPS. Информацию берём из blog/apps.py
						<pre>'blog.apps.BlogConfig',  # наше приложение blog</pre>
					</li>
					<li>
						Создадим urls.py в blog в него сразу импортируем path и views.py
						<pre>
from django.urls import path
from .views import *</pre>
						Создаём свой список urlpatterns, запишим первый путь
						<pre>
urlpatterns = [
    path('', home, name='home'),
]</pre>
					</li>
						Расширим основной avtoblog/urls.py  + avtoblog/urls.py (include)
						<br>Для этого добавляем маршрут к urls.py из blog  + имортируем include()
						<pre>
from django.urls import path, include

path('', include('blog.urls')),  # путь к путям приложения blog
				</pre>

				</ol>
			</li>

			

			<li>
				<span class="title_text">Первые функции представления (заглушки) - первые маршруты, динамические маршруты по id</span>
				<hr>
				<ol>

					<li>
						Создадим первую функцию представления во blog/views.py
						<pre>
from django.http import HttpResponse
						</pre>
					</li>
					<li>
						Добавим две функции представления категорий и отдельной машины. В blog/views.py
						<pre>
# страница категорий
def categories(request):
    return HttpResponse('Страница категорий')


# страница отдельной машины
def car(request):
    return HttpResponse('Страница отдельной машины')</pre>
					</li>
					<li>
						Сразу пропишем маршруты к ним в url.py
						<pre>
path('category/', categories, name="category"),
path('car/', car, name='car'),</pre>
					</li>
					<li>
						Увеличим функции представления и маршруты catregory/1-2-3.. и car/1-2-3
						<br>Во views.py
						<pre>
# страница категорий
def categories(request, category_id):  # в скобках то что получаем в запросе
    # в return то что отдаём для отображения
    return HttpResponse(f'&lt;h1>Страница категорий&lt;/h1>&lt;p>№ {category_id}&lt;/p>')


# страница отдельной машины
def car(request, car_id):
    return HttpResponse(f'&lt;h1>Страница отдельной машины&lt;/h1>&lt;p>№ { car_id }&lt;/p>')</pre>
						<br>В urls.py
						<pre>
path('category/&lt;int:category_id>/', categories, name="category"),
path('car/&lt;int:car_id>/', car, name='car'),</pre>
					</li>
					<li>
						<span class="spec">Искочения и 404 не далал на данном этапе. П33 КОНСПЕКТА SELFEDU</span>
					</li>

				</ol>
			</li>



			
			<li>
				<span class="title_text">Модели, миграции, суперпользователь, регистрация моделей в админке</span>
				<hr>
				<ol>

					<li>
						Пропишим 2 модели Сar, Category в models.py
						<pre>
class Car(models.Model):
    # Id прописывать не нужно - Model Это делает автоматически
    title = models.CharField(max_length=255, verbose_name='Заголовок')  # длина 255 символов
    # unique=True - поле уникально, db_index=True - индексируемое (для ускорения поиска, verbose_name - отображение в адм.)
    slug = models.SlugField(max_length=255, unique=True, db_index=True, verbose_name='URL')
    content = models.TextField(blank=True, verbose_name='Текст статьи')  # текстовое поле без ограничений, blank=True - поле может быть пустым
    tth = models.TextField(blank=True, verbose_name='Технические характеристики авто')
    photo = models.ImageField(upload_to='photos/%Y/%m', verbose_name='Фото')  # загружать будем в photos/год/месяц
    time_create = models.DateTimeField(auto_now_add=True, verbose_name='Время создания')
    time_update = models.DateTimeField(auto_now=True, verbose_name='Время изменения')
    is_published = models.BooleanField(default=True, verbose_name='Публикация')  # default=True
    # cat_id - id добавится автоматом, ForeignKey - связь Car - c Category
    cat = models.ForeignKey('Category', on_delete=models.PROTECT, verbose_name='Категории')


class Category(models.Model):
    # db_index - для того чтобы поле было индексированным, поиск по небу будет происходить быстрей
    name = models.CharField(max_length=100, db_index=True, verbose_name='Категория')
    slug = models.SlugField(max_length=255, unique=True, db_index=True, verbose_name='URL')</pre>
					</li>
					<li>
						Сделаем первую миграцию и применим её - без этого путь admin не работает!
						<pre>
python manage.py makemigrations
python manage.py migrate</pre>
					</li>
					<li>
						Создадим superuser
						<pre>
python manage.py createsuperuser  # создаём суперюзера

Имя пользователя: Mello
Адрес электронной почты: elproject220@yandex.ru
Password:blog1234
Password (again):blog1234
Superuser created successfully.  # пользователь создан</pre>
					</li>
					<li>
						Зарегистрируем наши модели в админке. в blog/admin.py
						<pre>
admin.site.register(Car)
admin.site.register(Category)</pre>
					</li>
				</ol>
			</li>



			<li>
				<span class="title_text">MEDIA_ROOT, MEDIA_URL, STATIC_URL, STATIC_ROOT, STATICFILES_DIRS, if settings.DEBUG:</span>
				<hr>
			
				<ol>

					<li>
						Настраиваем MEDIA_ROOT - MEDIA_URL в settings.py
						<pre>
MEDIA_ROOT = BASE_DIR / 'media'  # будет загружать медиа в папку media
MEDIA_URL = '/media/'  # добавили url - будет отображаться в браузере</pre>
			</li>
					<li>
						Для эмуляции работы сервер для получения ранее загруженных файлов, и передачи их нашему приложению.
						<br>В avtoblog/urls.py добавим маршруты к статическим файлам и к медиафайлам
						<pre>
from django.conf.urls.static import static  # пути к статическим файлам
from . import settings  # для MEDIA_URL MEDIA_ROOT

if settings.DEBUG:
    # к путям добавляем путь к статическим данным, графическим данным
    # на реальных серверах обычно это не используется
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)</pre>
					</li>
					<li>
						Настраиваем STATIC_URL STATIC_ROOT STATICFILES_DIRS
						<br>-STATIC_URL - префикс URL-адреса
						<br>-STATIC_ROOT - путь к общей статической папке, используемый реальым веб-сервером
						<br>-STATICFILES_DIRS - список дополнительных(нестандартных) путей к статическим файлам, используемых для сбора и для рещима отладки
						<br><br>в settings.py
						<pre>
STATIC_URL = 'static/'  # стандартно
# STATIC_ROOT добавили, в эту папку при collectstatic - django перемещает все статические файлы
# путь avtoblog-project/avtoblog - из этой папке, статический файлы будут пользоваться в режиме эксплуатации сайта на сервере
STATIC_ROOT = BASE_DIR / 'static'
# добавили пустой список, список нестандартных путей, пока у нас нет, оставим пустым
STATICFILES_DIRS = []</pre>
					</li>
				</ol>
			</li>



			
			<li>
				<span class="title_text">Папки статических фалов, первые шаблоны, base.html, функции представления, context, {% load static %}, {% extends 'blog/base.html' %}, Bootstrap5</span>
				<hr>

				<ol>


					<li>
						Создам вручную папку для статических фалов. В blog:
						<br>blog/static
						<br>blog/static/blog
						<br>blog/static/blog/css 
						<br>blog/static/blog/images - туда буду загружать иконки
						<br>blog/static/blog/js
					</li>
					<li>
						Создам файл стилей styles.css - в blog/static/blog/css 
					</li>
					<li>
						Создам вручную папку для шаблонов фалов. В blog:
						<br>blog/templates
						<br>blog/templates/blog
					</li>
					<li>
						Создам base.html - в blog/templates/blog
					</li>
					<li>
						Привяжу функцию представления def home - к base.html, в vievs.py
						<pre>
# домашняя страница
def home(request):
    context = {
        'title': 'Базовый шаблон',
        'ключ 2': 'Значение2',        
    }
    return render(request, 'blog/base.html', context=context)</pre>
					</li>
					<li>
						В base.html  - чтото напишу для проверки
						<pre>
&lt;!DOCTYPE html>
&lt;html>
&lt;head>
	&lt;meta charset="utf-8">
	&lt;meta name="viewport" content="width=device-width, initial-scale=1">
	&lt;title>{{ title }}&lt;/title>
&lt;/head>
&lt;body>
	&lt;h1>{{ title }}&lt;/h1>
&lt;/body>
&lt;/html></pre>
					</li>
					<li>
						Далее верстаю страницу base.html, Добавляю bootstrap, ссылку на css, подкгружаю статические файлы - В base.html - будет navbar, sidebar, footer
				<pre>
---в самом верху---
{% load static %}

---до title, в head---
ссыылка BOOTSTRAP CSS -->
ссыылка к нашему css файлу -->
ссылка для отображении иконки в браузере (где title) -->

---в title---
{% block title %} {% endblock %}

---до закрытия body---
ссыылка BOOTSTRAP JS --></pre>
					</li>
					<li>
						Сделал навбар, сайдбар и футер в base.html - указал промежуток {% block content %}
					</li>
					<li>
						Создал home.html в нём унаследовался от base.html - указал block kontent с минимальным содержимым
						<pre>
{% extends 'blog/base.html' %} 

{% block title %} 
	{{ title }}
{% endblock %}

{% block content %}
&lt;h1>{{ title }}&lt;/h1>
&lt;p>{{ key_2 }}&lt;p>
{% endblock %}</pre>
					</li>
					<li>
						Подгорректировал def home во views.py
						<pre>
# домашняя страница
def home(request):
    context = {
        'title': 'Главная страница',
        'key_2': 'Значение2',
    }
    return render(request, 'blog/home.html', context=context)</pre>
					</li>
				</ol>
			</li>



			<li>
				<span class="title_text">Методы __str__, class Meta:</span>
				<hr>

				<ol>


					<li>
						Пропишим метод __str__ в моделях Car, Category - чтобы при обращении к категории или посту нам отображался title Car, name - Category
						<pre>
--class Car--
# с помощью метода запись нашего класса будет выводиться по её заголовку
def __str__(self):
    return self.title

--class Category--
# будем обращаться к категории по полю name
def __str__(self):
    return self.name</pre>
					</li>
					<li>
						В модели дпбавим класс Meta - для нормального отображенияв админ панели и сортировки
						<pre>
--class Car--
class Meta:
    verbose_name = "Автомобиль"
    verbose_name_plural = "Автомобили"
    ordering = ['-time_create', 'title']  # сортировка, сначала по дате создания, потом по имени

--class Category--
class Meta:
    verbose_name = "Категория"
    verbose_name_plural = "Категории"
    ordering = ['id']  # сортировка, сначала по id</pre>
					</li>
				</ol>
			</li>



			<li>
				<span class="title_text">Отображение в админке/настройка</span>
				<hr>
				<ol>


					<li>
						Отобразим на нормальном языке наше приложение в админке
						<br>В blog/apps.py - class BlogConfig - добавим 1 поле
						<pre>verbose_name = 'Авто блог'  # отображение названия приложения</pre>
					</li>
					<li>
						Добавим пару записей в категорию и посты
					</li>
					<li>
						Для отображения столбцов в админ панеле в admin.py добавим классы, и опишем их
						<pre>
class CarAdmin(admin.ModelAdmin):
    # список отображаемых столбцов в админ-панели
    list_display = ('id', 'title', 'time_create', 'photo', 'is_published')
    prepopulated_fields = {'slug': ('title',)}  # автозаполнение слага по имени поста
    # список полей на которые можно кликнуть - для редактирования
    list_display_links = ('id', 'title')
    # список полей - ко которым можно вести поиск
    search_fields = ('title', 'content')
    # редактирование поля публикации - в списке - в админке
    list_editable = ('is_published',)  # запятая - если 1 поле!
    # фильтр по полям - публикация, время изменения.
    list_filter = ('is_published', 'time_create')</pre>
		    			<pre>
class CategoryAdmin(admin.ModelAdmin):
    prepopulated_fields = {'slug': ('name',)}  # автозаполнение слага по имени категории
    list_display = ('id', 'name')
    list_display_links = ('id', 'name')
    search_fields = ('name',)  # ЗАПЯТАЯ В КОНЦЕ- при одном поле</pre>
		    			<pre>
admin.site.register(Car, CarAdmin)
admin.site.register(Category, CategoryAdmin)</pre>
					</li>
					<li>
						<span class="spec">get_html_photo</span><br>
						Для отображения миниатюр фото вместо ссылки на фото добавим метод get_html_photo (назвали сами) - там же в class CarAdmin(admin.ModelAdmin):
						<pre>
from django.utils.safestring import mark_safe

list_display = ('id', 'title', 'time_create', 'get_html_photo', 'is_published')

# отображение миниатюр фото в админке
    def get_html_photo(self, object):
        if object.photo:  # если фото есть
            # mark_safe - не экранирует теги
            return mark_safe(f"}&lt;img src='{object.photo.url}' width=50>")</pre>
					</li>
				</ol>
			</li>



			<li>
				<span class="title_text">Страницы отдельного поста, get_absolute_url, динамический марщрут по слагу</span>
				<hr>
				<ol>

					<li>
						Создам шаблон для отображения 1 поста car.html, наследуюсь от base.html
						<pre>
{% extends 'blog/base.html' %} 

{% block title %} 
	{{ title }}
{% endblock %}

{% block content %}
&lt;h1>{{ title }}&lt;/h1><
{% endblock %}</pre>
					</li>
					<li>
						Изменю функцию представления def car
						<pre>
# страница отдельной машины
def car(request, car_slug):
    car = Car.objects.get(slug=car_slug)
    context = {
        'car': car,
    }
    return render(request, 'blog/car.html', context=context)</pre>
					</li>
					<li>
						Добавлю метод get_absolute_url - для Модели Car - для получения маршрута по слагу
						<pre>
from django.urls import reverse

# функция формирования маршрута к ссылке
def get_absolute_url(self):  # self - ссылка на один экземпляр(строку) таблицы модели
    # получаем путь('path name=car, 'car/&lt;slug:car_slug>/) = 127/car/supra)
    return reverse('car', kwargs={'car_slug': self.slug})  # self.slug - атрибут slug</pre>
			</li>
					<li>
						Изменяем маршрут в urls.py  name='car'
						<pre>
path('car/&lt;slug:car_slug>/', car, name='car'),</pre>
					</li>
					<li>
						Отображаю все поля на в шаблоне car.html
						<pre>
{% extends 'blog/base.html' %} 

{% block title %} 
	{{ car.title }}
{% endblock %}

{% block content %}

&lt;h1>{{ car.title }}&lt;/h1>
{% if post.photo %}
&lt;img src="{{ car.photo.url }}" class="img-fluid">&lt;br>
{% endif %}

&lt;p>Производство: {{ car.cat }}&lt;/p>
&lt;h3>Технические характеристики&lt;/h3>
&lt;p>{{ car.tth|linebreaks}}&lt;/p>&lt;br>
&lt;h3>Описание модели&lt;/h3>
&lt;p>{{ car.content|linebreaks }}&lt;/p>&lt;br>
&lt;p>Время обновления поста: {{ car.time_update }}&lt;/p>
&lt;
{% endblock %}</pre>
					</li>
					<li>
						Занимаемся оформлением шаблона car.html
					</li>
				</ol>
			</li>



			<li>
				<span class="title_text">
					Вывод всех записей и запизей по поределённому фильтру (категории) - в один шаблон, по разным функциям представления. (home / categories)
				</span>
				<hr>
				<ol>

					<li>
						Делаем отображение на главной странице (будут показывать все записи в модели)
					</li>
					<li>
						Во views.py - передаём в шаблон, все записи модели Car - в функции представления
						<pre>
# домашняя страница
def home(request):
    cars = Car.objects.all()
    context = {
        'title': 'Главная страница',
        'cars': cars,
    }
    return render(request, 'blog/home.html', context=context)</pre>
					</li>
					<li>
						Выводим все записи в шаблоне home.html
						<br>Оформляем шаблон home.html
					</li>
					<li>
						Пишем get_absolute_url - Category  - по слагу - в models.py
						<pre>
# функция формирования маршрута к ссылке
def get_absolute_url(self):
    return reverse('category', kwargs={'cat_slug': self.slug})</pre>
					</li>
					<li>
						Меняем маршрут по слагу urls.py
						<pre>path('category/&lt;slug:cat_slug>/', categories, name="category"),</pre>
					</li>
					<li>
						Меняем функцию представления views.py
						<pre>
# вывод записей Car - по выбранной категории
def categories(request, cat_slug):  # в скобках то что получаем в запросе
    # cat__slug - обращение из модели Car - к полю slug модели Category
    # cat_slug - значение поля slug - выбранной категории - см get_abs_url Category
    cars = Car.objects.filter(cat__slug=cat_slug)
    context = {
        'title': f'Производство: {category_1}',
        'cars': cars,
    }
    return render(request, 'blog/home.html', context=context)</pre>
					</li>
					<li>
						Выводим информацию в шаблон - в home.html
						<br>Ничего менять не нужно - будут отображаться только выбранные по категории авто
					</li>
				</ol>
			</li>	



			<li>
				<span class="title_text">Sidebar, cat_selected, Вывод категорий в панель навигации из бады данных</span>
				<hr>
				<ol>

					<li>
						Sidebar вывожу в отдельный шаблон sidebar.html
						<br>Просто удаляю всё из base.html - переношу в sidebar.html
						<br>В base.html - 1 строка в нужном месте
						<pre>{% include 'blog/sidebar.html' %}</pre>
					</li>
					<li>
						Выводим категории (ссылки в sidebar)
						views.py  - создаём переменную all_categories - выше всех функций представления
						<pre>
		all_categories = Category.objects.all()</pre>
						<br>В context - Каждой функции представления добавим all_categoryies - чтобы при "вызове" функции представления на html - страницах отображались категории
						<pre>
# домашняя страница
def show_home(request):
    cars = Car.objects.all()
    context = {
        'cat_selected': 'all',
        'all_categories': all_categories,
        'title': 'Все модели',
        'cars': cars,
    }
    return render(request, 'blog/home.html', context=context)


# вывод записей Car - по выбранной категории
def show_categories(request, cat_slug):  # в скобках то что получаем в запросе
    # cat__slug - обращение из модели Car - к полю slug модели Category
    # cat_slug - значение поля slug - выбранной категории - см get_abs_url Category
    cars = Car.objects.filter(cat__slug=cat_slug)
    category_1 = Category.objects.get(slug=cat_slug)
    context = {
        'all_categories': all_categories,
        'cat_selected': category_1.slug,
        'title': f'Производство: {category_1}',
        'cars': cars,
    }
    return render(request, 'blog/home.html', context=context)


# страница отдельной машины
def show_car(request, car_slug):
    car = Car.objects.get(slug=car_slug)
    context = {
        'all_categories': all_categories,
        'car': car,
    }
    return render(request, 'blog/car.html', context=context)</pre>
					</li>
					<li>
						В шаблоне sidebar.html  - сделаем вывод всех категорий, через цикл фор, так же добавим конструкцию if (сравниваем cat_selected) -  для отображания ссылки в виде активной ссылки либо в виде уже выбранной категории, причем будем сравнивать отдельно для кнопки  Все категории, и отдельно для остальных категорий
						<pre>
{% if cat_selected != 'all' %}
&lt;li class="nav-item">
&lt;a class="nav-link active" aria-current="page" href="{% url 'home' %}">Все категории&lt;/a>
&lt;/li>
{% else %}
&lt;li class="nav-item">
&lt;a class="nav-link disabled" href="{% url 'home' %}" tabindex="-1" aria-disabled="true">Все категории&lt;/a>
&lt;/li>
{% endif %}	


{% for category in all_categories %}


{% if cat_selected == category.slug %}
&lt;li class="nav-item">
&lt;a class="nav-link disabled" href="{{ category.get_absolute_url }}" tabindex="-1" aria-disabled="true">{{ category.name }}&lt;/a>
&lt;/li>
{% else %}
&lt;li class="nav-item">
&lt;a class="nav-link" href="{{ category.get_absolute_url }}">{{ category.name }}&lt;/a>
&lt;/li>
{% endif %}

{% endfor %}</pre>
					</li>
				</ol>
			</li>




			<li>
				<span class="title_text">Динамический маршрут с двумя слагами (cat_slug/car_clug)<br>Делаю путь для отдельной машины - http://127.0.0.1:8000/category/japan/nissan-silvia-s14</span>
				<hr>
				<ol>
					<li>
						Самое важное, models.py - class Car - get_absolute_url
						<pre>
def get_absolute_url(self):
    return reverse('car', kwargs={'cat_slug': self.cat.slug, 'car_slug': self.slug})</pre>
    					<strong>ПОРЯДОК cat_slug/car_slut - важен, точно такой эе как и в маршруте!</strong>
					</li>
					<li>
						Меняем маршрут urls.py
						<pre>path('category/&lt;slug:cat_slug>/&lt;slug:car_slug>', show_car, name='car'),</pre>
					</li>
					<li>
						Меняем функцию представления для отдельной машины
						<br><strong>на входе необходимо принимать как car_slug так и cat_slug</strong>
						<br>car/cat_slug - это ключи в get_absolute_url - models.py - class Car
						<pre>
# страница отдельной машины
def show_car(request, car_slug, cat_slug):
    car = Car.objects.get(slug=car_slug)
    context = {
        'all_categories': all_categories,
        'car': car,
    }
    return render(request, 'blog/car.html', context=context)</pre>
					</li>
					<li>
						Всё работает! Но последним штрихом def show_car - добавлю cat_selected в context
						<pre>
# страница отдельной машины
def show_car(request, car_slug, cat_slug):
    car = Car.objects.get(slug=car_slug)
    context = {
        'cat_selected': cat_slug,
        'all_categories': all_categories,
        'car': car,
    }
    return render(request, 'blog/car.html', context=context)</pre>
					</li>
				</ol>
			</li>

		

			<li>
				<span class="title_text">Делаем пагинацию главной страницы и отображения категорий</span>
				<hr>
				<ol>
					<li>
						View.py
						<pre>
from django.core.paginator import Paginator

# домашняя страница
def show_home(request):
    cars = Car.objects.all()

    paginator = Paginator(cars, 4)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    context = {
        'page_obj': page_obj,
        'cat_selected': 'all',
        'all_categories': all_categories,
        'title': 'Все модели',
        # 'cars': cars,
    }
    return render(request, 'blog/home.html', context=context)

# вывод записей Car - по выбранной категории
def show_categories(request, cat_slug):  # в скобках то что получаем в запросе
    # cat__slug - обращение из модели Car - к полю slug модели Category
    # cat_slug - значение поля slug - выбранной категории - см get_abs_url Category
    cars = Car.objects.filter(cat__slug=cat_slug)
    category_1 = Category.objects.get(slug=cat_slug)

    paginator = Paginator(cars, 2)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    context = {
        'page_obj': page_obj,
        'all_categories': all_categories,
        'cat_selected': cat_slug,
        'title': f'Производство: {category_1}',
        # 'cars': cars,
    }
    return render(request, 'blog/home.html', context=context)</pre>
					</li>
					<li>
						В шаблоне home.html - для отображения кнопок (делал bootstrap) - из коробки html тоже приемлимый вид
						<pre>
	&lt;div class="pagination justify-content-center">
    	&lt;span class="step-links">
    		&lt;ul class="pagination justify-content-center ">
    	
	    	{% if page_obj.has_previous %}
	    		&lt;&lt;li>
	            	&lt;&lt;a class="page-link bg-dark"  href="?page=1">&laquo; Первая&lt;&lt;/a>
	            &lt;&lt;/li>
	            &lt;&lt;li>
	            	&lt;&lt;a class="page-link bg-dark" href="?page={{ page_obj.previous_page_number }}">Предыдущая&lt;&lt;/a>
	            &lt;&lt;/li>
	        {% endif %}&lt;&lt;

	        &lt;li class="page-item disabled">
		        &lt;span class="page-link bg-dark">
		            Страница {{ page_obj.number }} из {{ page_obj.paginator.num_pages }}.
		        &lt;/span>
		    &lt;/l&lt;i>


	        {% if page_obj.has_next %}
	        	&lt;li>
	            	&lt;a class="page-link bg-dark" href="?page={{ page_obj.next_page_number }}">Следующая&lt;/a>
	            &lt;/li>&lt;
	            &lt;li>	
	            	&lt;a class="page-link bg-dark" href="?page={{ page_obj.paginator.num_pages }}">Последняя &raquo;&lt;/a>
	            &lt;/li>
	        {% endif %}
	        &lt;/ul>
    	&lt;/span>
    &lt;/div></pre>
				</ol>
			</li>




			<li>
				<span class="title_text">Регистрация пользователя</span>
				<hr>
				<ol>
					<li>
						В base.html - делаю ссылки для регистрация и войти
						<pre>
&lt;span class="navbar-text">
	&lt;a class="nav-link active" href="{% url 'register' %}">Регистрация&lt;/a> | 
	&lt;a class="nav-link active" href="{% url 'login' %}">Войти&lt;/a>
&lt;/span></pre>
					</li>
					<li>
						Прописываем марщруты в urls.py
						<pre>
path('', show_login, name='login'),
path('', RegisterUser.as_view(), name='register'),</pre>
					</li>
					<li>
						Создаю шаблоны login.html +  register.html - в них наследуюсь от base.html
						<pre>
{% extends 'blog/base.html' %} 

{% block title %} 
	Регистрация пользователя
{% endblock %}

{% block content %}

Форма для регистрации

{% endblock %}</pre>
						Аналогично для формы аутентификации
					</li>
					<li>
						Создам класс Mixin - для формирования первоначальных контектсов всех функций представления, в будущем перейду на них
					</li>
					<li>
						в avtoblog-project/blog создам utils.py - и добавим Mixin для формирования общего контекста
						<pre>
from blog.models import Category  # наша модель

all_categories = Category.objects.all()  # общий для всех список в sidebar


# общий класс
class DataMixin:
    # формируем общий контекст
    def get_user_context(self, **kwargs):
        # контекст будет словарём {'ключ':'значение'}
        context = kwargs
        # в словарь контекст добавили { 'all_categories' : Category.objects.all()}
        context['all_categories'] = all_categories
        # if 'cat_selected'
        return context</pre>
					</li>
					<li>
						Деляю класс представления для регистрации пользователя во views.py - перед этим импортировав всё что нужно
						<pre>
from django.views.generic import CreateView  # класс представления
from django.contrib.auth.forms import UserCreationForm  # форма django
from django.urls import reverse_lazy  # перенаправление на маршрут
from .utils import DataMixin  # наш Mixin


# класс представления RegisterUser
class RegisterUser(DataMixin, CreateView):
    form_class = UserCreationForm  # стандартная форма django
    template_name = 'blog/register.html'  # шаблон куда передаём
    success_url = reverse_lazy('login')  # При успешной регистрации направит path 'login'

    # формируем полный словарь context
    def get_context_data(self, object_list=None, **kwargs):
        # берём контекст из этого класса представления
        context = super().get_context_data(**kwargs)  # на данный момент form_class
        # берём контекст из DataMixin - и в него сразу добавляем title
        c_def = self.get_user_context(title='Регистрация')
        # передаём в шаблон общий контекст (RegisterUser + DataMixin)
        return {**context, **c_def}
        # или
        # return dict(list(context.items()) + list(c_def.items()))</pre>
					</li>
					<li>
						В шаблоне register.html - выведем стандартную форму django
						<pre>
{% block content %}

&lt;form method="post">
	{% csrf_token %}
	{{ form.as_p }}
	&lt;button type="submit">
		Зарегистрироваться
	&lt;/button>
&lt;/form>	
{% endblock %}</pre>
						Форма уже рабочая но фид у неё так себе
					</li>
					<li>
						Создадим свою форму (на основе стандартной просто изменим вид, отцентруем и так далее).
						<br>Формы будем создавать в отдельном файле - создаём blog/forms.py
					</li>
					<li>
						В forms.py - создаём свою форму на основе стандартной формы django - UserCreationForm
						<pre>
from django.contrib.auth.forms import UserCreationForm  # стандартная форма django
from django.contrib.auth.models import User  # из djando достаём записи модели User (все пользователи)
from django import forms  # модуль forms - для написания полей


# форма регистрации
class RegisterUserForm(UserCreationForm):
    # прописываем все необходимые поля, самостоятельно
    # тк django в meta их не видит почему-то без этого
    # название полей можно посмотреть в коде html - или в документации
    username = forms.CharField(label='Логин', widget=forms.TextInput(attrs={'class': 'form-input'}))
    email = forms.EmailField(label='Email', widget=forms.EmailInput(attrs={'class': 'form-input'}))
    password1 = forms.CharField(label='Пароль', widget=forms.PasswordInput(attrs={'class': 'form-input'}))
    password2 = forms.CharField(label='Повтор пароля', widget=forms.PasswordInput(attrs={'class': 'form-input'}))

    class Meta:
        model = User  # связываемся с моделью User
        # отображаем поля модели User
        fields = ('username', 'email', 'password1', 'password2')</pre>
					</li>
					<li>
						Во views.py изменим  в классе представление связь с формой - class RegisterUser - form_class = RegisterUserForm
						<pre>
from .forms import *  # наш forms.py

form_class = RegisterUserForm  # наша форма из forms.py</pre>
						Форма работает, но вид можно ещё улучшить
					</li>
					<li>
						В styles.css  - добавим стилей form-label/form-input/form-error/form-button
						<br>Отступы, размеры, цыет, выравнивание а такдалее
					</li>
					<li>
						Улучшаем вид в register.html - будем выводить все поля через цикл for
						<pre>
{% for f in form %}
&lt;p>
&lt;label class="form-label" for="{{ f.id_for_label }}">{{f.label}}: &lt;/label>{{ f }}
&lt;/p>
&lt;div class="form-error">{{ f.errors }}&lt;/div>
{% endfor %}</pre>
						Форма рабочая, с подобающим видом
					</li>

				</ol>
			</li>



			<li>
				<span class="title_text">Делаю авторизацию пользователя (login+logout)</span>
				<hr>
				<ol>
					<li>
						Сразу создам свою форму аутентификации в forms.py на основе стандартной формы AuthenticationForm, пропишем 2 поля логин и пароль
						<pre>
from django.contrib.auth.forms import AuthenticationForm  # стандартные формы

# Форма авторизации
class LoginUserForm(AuthenticationForm):  # AuthenticationForm - стандартная форма
    username = forms.CharField(label='Логин', widget=forms.TextInput(attrs={'class': 'form.input'}))
    password = forms.CharField(label='Пароль', widget=forms.PasswordInput(attrs={'class': 'form.input'}))</pre>
					</li>
					<li>
						Во views.py - сделю класс представления авторизацтт
						<pre>
from django.contrib.auth.views import LoginView  # стандартная логика авторизации

# Класс представления формы авторизации
# Логика работы базового класса LoginView + сама форма LoginUserForm
class LoginUser(DataMixin, LoginView):
    form_class = LoginUserForm  # наша форма из forms.py
    template_name = 'blog/login.html'  # шаблон
    
    # формируем полный контекст
    def get_context_data(self, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)  # распаковываем изначальный контекст
        c_def = self.get_user_context()  # переменная контекста DataMixin
        return {**context, **c_def}  # в шаблон передаём полный контекст</pre>
					</li>
					<li>
						Поправляем маршрут login - ссылкаемся на класс представления LoginUser
						<br>В urls.py
						<pre>path('login/', LoginUser.as_view(), name='login'),</pre>
					</li>
					<li>
						Выводим в шаблон login.html - нашу форму, По сути можно скопировать код из register.html - только изменить имя кнопки, так же добавил ошибки сверху и снизу
						<pre>
&lt;form method="post">
	{% csrf_token %}

	<!-- ошибки если неверный логин и пароль -->
	&lt;div class="form-error">
		{{ form.non_field_errors }}
	&lt;/div>
	&lt;
	{% for f in form %}
	&lt;p>
	&lt;label class="form-label" for="{{ f.id_for_label }}">{{f.label}}: &lt;/label>{{ f }}
	&lt;/p>
	&lt;div class="form-error">{{ f.errors }}&lt;/div>
&lt;
	<!-- ошибки если возникнут -->
	&lt;div class="form-error">
		{{ f.errors }}
	&lt;/div>


	{% endfor %}

	&lt;button type="submit" class="btn btn-primary btn-lg">
		Войти
	&lt;/button>
&lt;/form></pre>
					</li>
					<li>
						<span class="spec">Страница аккаунта - сделаю позже!</span>
					</li>
					<li>
						Стандартно после залогинивания - пренаправляет по url - http://127.0.0.1:8000/accounts/profile/ - Но такого маршрута нету, по этому будем перенаправлять на домашнюю страницу
						<br>
						Для этого в views.py - в классе представления LoginUser - в самом инзу добавим метод для перенаправление при успешной авторизации
						<pre>
def get_success_url(self):
    return reverse_lazy('home')  # при успешном входе перенаправит домой</pre>
    			<br><strong>Второй вариант сделать перенаправление через settings.py</strong>
    			<pre>
LOGIN_REDIRECT_URL = '/'  # При успешной аутентификации - перенаправление на home-page
LOGOUT_REDIRECT_URL = 'home'  # При выходе из акккунта перенаправление домой
    			</pre>
					</li>
					<li>
						Для залогиненого пользователя, вместо регистрации и войти в навбар будем отображать - имя пользователя и выйти
						<br>Редактируем base.html - добавляя конструкцию if

						<pre>
  	&lt;span class="nav-text text-light">

  		<!-- если пользователь залогиненый -->
  		{% if request.user.is_authenticated %}
  		&lt;span class="text-info" style="letter-spacing: .2em; font-size: 30px;">{{ user.username }} &lt;/span> &lt;a class="nav-link active text-warning" href="{% url 'logout' %}">Выйти&lt;/a>

  		<!-- иначе пользователь незалогинен -->
  		{% else %}
      	&lt;a class="nav-link active" href="{% url 'register' %}">Регистрация&lt;/a>
      	&lt;a class="nav-link active" href="{% url 'login' %}">Войти&lt;/a>
      	{% endif %}

  	&lt;/span></pre>
					</li>
					<li>
						Делаем маршрут и функцию представляния для logout
						<br>Во views.py
						<pre>
from django.contrib.auth import logout  # выход пользователя django
from django.shortcuts import ..., redirect

# выход из аккаунта
def logout_user(request):
    logout(request)  # стандартный выход пользователя
    return redirect('login')  # перенаправляет залогиниться</pre>
						<br>
						В urls.py
						<pre>path('logout/', logout_user, name='logout'),</pre>
						<br>
						<span class="spec">redirect делает перенаправление по сформированному маршруту, а reverse только формирует маршрут (без перенаправления)</span>
					</li>
					<li>
						Добавлю вункцию чтобы при успешной регистрации  - пользователь сразу был залогинен
						<br>Для этого во views.py - в классе представления RegisterUser - добавим метод form_valig
						<pre>
from django.contrib.auth import logout, login  # выход/вход пользователя django

# автозалогинивание при успешной регистрации
def form_valid(self, form):
    user = form.save()  # сохраняем данные пользователя в БД (User)
    login(self.request, user)  # авторизовывает пользователя
    return redirect('home')  # перенаправляет домой</pre>
					</li>
					<li>
						Немного подкорректирую шаблон login.html
					</li>
				</ol>
			</li>



			<li>
				<span class="title_text">Вынесу аутентификацию пользователей в отдельное приложение</span>
				<hr>
			<ol>
					<li>
						В двух словах, нежны свои urls.py, forms.py, templates, vievs.py
					</li>
					<li>
						Создам новой приложение account.
						<pre>python manage.py startapp account</pre>
					</li>
					<li>
						В settings.py - регистрирую приложение
						<pre>
INSTALLED_APPS = [ 
....,
'account.apps.AccountConfig',  # наше приложение аккаунт
]</pre>
					</li>
					<li>
						В account/urls.py добавляем пути - перемещаем  всё необходимое из blog/urls.py
						<pre>
from django.urls import path
from .views import *

urlpatterns = [
    path('login/', LoginUser.as_view(), name='login'),
    path('logout/', logout_user, name='logout'),
    path('register/', RegisterUser.as_view(), name='register'),
]</pre>
					</li>
					<li>
						В Главном urls.py - расширимся путями из account/urls.py
						<pre>path('', include('account.urls')),  # путь к путям приложения account</pre>
					</li>
					<li>
						blog/forms.py - полностью переносим в account/urls.py (сейчас там только формы регистрации и автоиризации)
					</li>
					<li>
						В account  - создаём подкаталоги templates/account. В него переносим наши шаблоны login.html, register.html
					</li>
					<li>
						Из blog/views.py переносим все классы и функции представления в account/views.py, связанные с пользователем  - Везде где указан путь к шаблону меняем путь
						<pre>
'account/register.html'
template_name = 'account/login.html'</pre>
						<br>Все функции и класса представления в account views.py
						<pre>
# Create your views here.
# класс представления RegisterUser
class RegisterUser(DataMixin, CreateView):
    form_class = RegisterUserForm  # наша форма из forms.py
    template_name = 'account/register.html'  # шаблон куда передаём
    success_url = reverse_lazy('login')  # При успешной регистрации направит path 'login'

    # формируем полный словарь context
    def get_context_data(self, object_list=None, **kwargs):
        # берём контекст из этого класса представления
        context = super().get_context_data(**kwargs)  # на данный момент form_class
        # берём контекст из DataMixin - и в него сразу добавляем title
        c_def = self.get_user_context(title='Регистрация')
        # передаём в шаблон общий контекст (RegisterUser + DataMixin)
        return {**context, **c_def}
        # или
        # return dict(list(context.items()) + list(c_def.items()))

    # автозалогинивание при успешной регистрации
    def form_valid(self, form):
        user = form.save()  # сохраняем данные пользователя в БД (User)
        login(self.request, user)  # авторизовывает пользователя
        return redirect('home')  # перенаправляет домой


# Класс представления формы авторизации
# Логика работы базового класса LoginView + сама форма LoginUserForm
class LoginUser(DataMixin, LoginView):
    form_class = LoginUserForm  # наша форма из forms.py
    template_name = 'account/login.html'  # шаблон

    # формируем полный контекст
    def get_context_data(self, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)  # распаковываем изначальный контекст
        c_def = self.get_user_context(title='Авторизация')  # переменная контекста DataMixin
        return {**context, **c_def}  # в шаблон передаём полный контекст

    def get_success_url(self):
        return reverse_lazy('home')  # при успешном входе перенаправит домой


# выход из аккаунта
def logout_user(request):
    logout(request)  # стандартный выход пользователя
    return redirect('login')  # перенаправляет залогиниться</pre>
					</li>
					<li>
						Выделенные красным мктоды, классы, формы  - импортируем в account/views.py - Это очень просто сделать в PyCharm.  - он почти всегда знает что откуда импортировать
						<pre>
from django.contrib.auth import logout, login
from django.contrib.auth.views import LoginView
from django.shortcuts import render, redirect
from django.urls import reverse_lazy
from django.views.generic import CreateView

from account.forms import RegisterUserForm, LoginUserForm
from blog.utils import DataMixin</pre>
					</li>
					<li>
						Пробуем запускать сервер и в терминале читаем ошибки, что и где не состыковывается
						<br>В blog.views.py - удаляем ИМПОРТ forms.py
						<pre>from .forms import *  # наш forms.py  -  УДАЛЯЕМ</pre>
						<strong>Всё работает! Точно так же как и до создания прилодения account и переноса туда всеи информации!</strong>
					</li>
					<li>
						Финальнцы штрих - удалим все неиспользуемые импорты в blog/Views.py
						<pre>
---DELETE---DELETE---DELETE---DELETE---DELETE---DELETE---
from django.contrib.auth import logout, login  # выход/вход пользователя django
from django.contrib.auth.forms import UserCreationForm  # форма django
from django.contrib.auth.views import LoginView  # стандартная логика авторизации
from django.http import HttpResponse

from django.urls import reverse_lazy  # перенаправление на маршрут
from django.views.generic import CreateView  # класс представления

from .utils import DataMixin  # наш Mixin

from django.shortcuts import redirect
---DELETE---DELETE---DELETE---DELETE---DELETE---DELETE---</pre>
						<br>Даже если что то и понадобится в будующем - импортируем заново
					</li>
				</ol>
			</li>
			





			<li>
				<span class="title_text">Добавляем страницу добавления поста - пользователем сайта</span>
				<hr>
			
				<ol>

					<li>
						В blog/forms.py - создаём форму - по сути ссылаемся на нашу модель Car, и указываем какие поля будем отображать
						<pre>
from django import forms
from blog.models import Car


class CarForm(forms.ModelForm):
    class Meta:
        model = Car  # наша модель
        # поля отображаемые в форме
        fields = ['slug', 'title', 'content', 'tth', 'photo', 'cat']</pre>
					</li>
					<li>
						Создаём шаблон add_post.html - по стандарту, расщиряемся от base.html , block content, block title
					</li>
					<li>
						Создаём функция представления show_add_post
						<pre>
from .forms import CarForm			

def show_add_post(request):
    form = CarForm()
    context = {
        'all_categories': all_categories,
        'form': form,
    }
    return render(request, 'blog/add_post.html', context=context)</pre>
					</li>
					<li>
						Добавляем маршрут name='add_post'
						<pre>path('add_post/', show_add_post, name='add_post'),</pre>

					</li>
					<li>
						Добавим ссылку в навбар для добавления поста (base.html)
						<pre>href="{% url 'add_post' %}</pre>
					</li>
					<li>
						<span class="spec">Внутри шаблона обязательно сразу указать form method='POST' и csrf_token - Без этого ничего сервер не запустится!</span>
						<pre>
&lt;h1>New post&lt;/h1>
&lt;form method="POST" class="post-form">
	{% csrf_token %}
    {{ form.as_p }}
    &lt;button type="submit" class="save btn btn-default">Save&lt;/button>
&lt;/form></pre>
					</li>
					<li>
						На данном этапе, форма уже отображается, только при её заполнении ничего не происходит так как у нас по сути нет кода чтобы сохранить её, так же нужно сделать валидацию данных
					</li>
					<li>
						Во первых в шаблоне add_post - необходимо обязательно добавить в тегах форм
						<pre>
&lt;form action="{%  url 'add_post' %}" method="post" enctype="multipart/form-data"></pre>
					</li>
					<li>
						Добавим параметры отображения полей (по сути автозаполнение тегов при пережаче в шаблон)
						<br>
						В forms.py - class CarAddForm(forms.ModelForm): -  class Meta: - widgets
						<pre>
widgets = {
        'slug': forms.TextInput(attrs={'class': 'form-control, col-5'}),
        'title': forms.TextInput(attrs={'class': 'form-control, col-10'}),
        'content': forms.Textarea(attrs={'rows': 6, 'class': 'form-control, col-10'}),
        'tth': forms.Textarea(attrs={'rows': 4, 'class': 'form-control, col-10'}),
    }</pre>
					</li>
					<li>
						В add_post - отобразим  ошибка форм - сразу после csrf -{{ form.non_field_errors }} / до закрытия цикла фор - {{ f.errors }}
						<br>
						Готовй шаблон add_post.html
						<pre>
&lt;h1>{{ title }}&lt;/h1>
&lt;form action="{%  url 'add_post' %}" method="post" enctype="multipart/form-data">
	{% csrf_token %}
	
&lt;div class="form-error">{{ form.non_field_errors }}&lt;/div>
	
	{% for f in form %}

	&lt;p>
		&lt;label class="form-label" for="{{ f.id_for_label }}">{{ f.label }}:&lt;/label>{{ f }}
	&lt;/p>

&lt;div class="form-error">{{ f.errors }}&lt;/div>

{% endfor %}

&lt;button type="submit" class="btn btn-primary btn-lg">
	Сохранить запись
&lt;/button>

{% endblock %}</pre>
					</li>
					<li>
						Готовая функция представления (добавление поста)
						<pre>
def show_add_post(request):
    if request.method == 'POST':  # если уже введены какие-то данные
        # request.FILES - Обязательно если есть файлы, изображения и ТД
        form = CarAddForm(request.POST, request.FILES)  # форма = заполненная форма
        if form.is_valid():  # проверка правильности формы, если форма заполнена правильно
            form.save()  # сохраняет запись в БД
            return redirect('home')  # перенаправление домой при успешном заполнении
    else:  # если никаких данный пользователь ещё не вводил
        form = CarAddForm()  # отображаем пустую форму для заполнения

    context = {
          'title': 'Добавление статьи',
          'all_categories': all_categories,
          'form': form,
      }
    return render(request, 'blog/add_post.html', context=context)</pre>
					</li>
				</ol>
			</li>




			<li>
				<span class="title_text">Редактирование поста через класс представления UpdateView</span>
				<hr>
				
				<ol>

					<li>
						Создаю форму в forms.py - на данном этапе почти такаяже как и добавление поста - но не указываю slug в полях
						<pre>
# форма редактирования поста
class CarUpdateForm(forms.ModelForm):
    <span class="spec"># Чтобы не отображалось - На данный момент: http:///...</span>
    photo = forms.ImageField(widget=forms.FileInput)
    # photo = forms.ImageField(required=False, widget=forms.FileInput)
    class Meta:
        model = Car  # связываемся с моделью Car
        # поля отображаемые в форме - URL - не указываю!
        # c photo не всё так просто, коряво + обязательно необходимо изменить изображение
        fields = ['title', 'content', 'tth', 'cat', 'photo']
        widgets = {
            'title': forms.TextInput(attrs={'class': 'form-control, col-12'}),
            'content': forms.Textarea(attrs={'rows': 15, 'class': 'form-control, col-12'}),
            'tth': forms.Textarea(attrs={'rows': 10, 'class': 'form-control, col-12'}),
        }</pre> 
					</li>
					<li>
						Делаем класс представления c помощью. UpdateView, во views.py
						<pre>
# редактирование Поста
class UpdatePostView(DataMixin, UpdateView):
    model = Car  # связываемся с моделью Car
    form_class = CarUpdateForm  # связываемся с формой
    # указываем только car_slug - из get_absolute_ur
    # несмотря на то что в пути есть и car_slug ? почему так хз
    slug_url_kwarg = 'car_slug'
    template_name = 'blog/update_post.html'  # путь к шаблону

    # формируем полный контекст
    def get_context_data(self, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)  # распаковываем изначальный контекст
        c_def = self.get_user_context(title='Изменение поста')  # переменная контекста DataMixin + title
        return {**context, **c_def}  # в шаблон передаём полный контекст</pre>
					</li>
					<li>
						Маршрут urls.py 
						<pre>
		path('category/&lt;slug:cat_slug>/&lt;slug:car_slug>/update/', UpdatePostView.as_view(), name='update_post'),</pre>
					</li>
					<li>
						Cоздаём шаблон  - лучше сделать отдельный update_post.html - по сути внитри всё тоже самое что и в add_post.html - но очень важная особенность, в тегах form в action=' ' получение пути по слагу!'
						<br><span class="spec">{%  url 'update_post' car_slug=car.slug cat_slug=car.cat.slug %}</span>
						<br><span class="spec"> = http://127.0.0.1:8000/category/japan/nissan_gt-r/</span>
						<pre>
&lt;form action="{%  url 'update_post' car_slug=car.slug cat_slug=car.cat.slug %}" method="post" enctype="multipart/form-data">

# {%  url 'update_post' car_slug=car.slug cat_slug=car.cat.slug %} - для получения пути ../&lt;slug: cat_slug>/&lt;slug:car_slug>/.../
# method="post" - для отправки информации на сервер (исопльзовать в форме отправки)
№ enctype="multipart/form-data" - при отправке не только текста но и файлов (например изображенией)</pre>
					</li>
					<li>
						Тот же шаблон update. html - отображаем изображение внизу вместо ссылки<br>
						<span class="spec">КРИТИЧЕСКИИЯ ФАЖНАЯ ИНФОРМАЦИЯ - ОТОБРАЖЕНИЕ ФОТО С СЕРВЕРА, ПОЛУЧЕНИЕ ССЫЛКИ НА НЕЁ, ФОТО ОТНОСЕЩИЕСЯ К ОПРЕДЕЛЕННОЙ ЗАПИСИ</span>
						<br>Для начала будем выводить все поля кроме фото, фото стоит последним полем в форме UpdatePostView
						<br>-Ниже выводим отдельно поле фото - вместе с текущи изображение
						<pre>
&lt;form action="{%  url 'update_post' car_slug=car.slug cat_slug=car.cat.slug %}" method="post" enctype="multipart/form-data">
	{% csrf_token %}
	
	&lt;!-- # &lt;div class="form-error"> form.non_field_errors }}&lt;/div> -->
    &lt;!-- # одибки сверху см add_post.html - нажна ли? -->

	{% for f in form %}

	{% if not forloop.last %}

	&lt;p>
		&lt;label class="form-label" for="{{ f.id_for_label }}">{{ f.label }}:&lt;/label>{{ f }}
	&lt;/p>

    {% else %}
    &lt;br>

<span class="spec">
# ССЫЛКА НА ИЗОБРАЖЕНИЕ ОБЪЕКТА (записи модели из БД) <br>(вставлять в &lt;img src='ссылка') : <br>{{object.photo.url }}</span>

    	&lt;label class="form-label" for="{{ f.id_for_label }}">
    		&lt;img src="{{object.photo.url }}" class="img-fluid" style="max-width: 50%;">&lt;br>

    		&lt;p class="text-info">- Если хотите оставить указанное фото, &lt;br>в этом поле не нужно ничего изменять.&lt;/p>{{ f }}
    	&lt;/label>
  

	{% endif %}

	&lt;!-- # &lt;div class="form-error"> f.errors }}&lt;/div> -->
    &lt;!-- # ошибки снизу см add_post.html нужна ли? -->

	{% endfor %}
	
	&lt;br>&lt;br>
	&lt;button type="submit" class="btn btn-primary btn-lg">
		Сохранить изменения
	&lt;/button>
&lt;/form></pre>
					</li>
					<li>
						Кнопка 'Редактировать' - в шаблоне car.html - важно так же указать car_slug cat_clug
						<br><span class="spec">href="{% url 'update_post' car_slug=car.slug cat_slug=car.cat.slug %}"</span>
						<br><span class="spec"> = http://127.0.0.1:8000/category/japan/nissan_gt-r/</span>
						<pre>
&lt;a class="btn btn-warning" href="{% url 'update_post' car_slug=car.slug cat_slug=car.cat.slug %}">Редактировать статью&lt;/a></pre>
					</li>
				</ol>
			</li>



			<li>
				<span class="title_text">Удаление статьи пользователем сайта</span>
				<hr>
				<ol>
					<li>
						Пишем маршрут в blog/urls.py
						<pre>path('category/&lt;slug:cat_slug>/&lt;slug:car_slug>/delete/', DeletePostView.as_view(), name='delete_post'),</pre>
					</li>
					<li>
						Во views.py пишим класс представления - для удаления статьи
						<pre>
from django.views.generic import ..., DeleteView  # представление для удаления
from django.urls import reverse_lazy  # перенаправление

# Представление для удаления статьи
class DeletePostView(DataMixin, DeleteView):
    model = Car  # модель из models.py
    template_name = 'blog/delete_post.html'  # шаблон
    success_url = reverse_lazy('home')  # после удаления отправит домой

    # !указываем только car_slug - из get_absolute_ur
    # !несмотря на то что в пути есть и car_slug ? почему так хз
    slug_url_kwarg = 'car_slug'
    
    # form_class = не нужно никакой формы

    # формируем полный контекст
    def get_context_data(self, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)  # распаковываем изначальный контекст
        c_def = self.get_user_context(title='Удаление поста')  # переменная контекста DataMixin + title
        return {**context, **c_def}  # в шаблон передаём полный контекст</pre>
						<br><span class="spec">Обрати внимаание на комменатрии к slug_url_kwarg = 'car_slug'</span>
					</li>
					<li>
						Создаём шаблон delete_post.html - в нем расширяемся от base.html + block title + block content
						<br>В блок контент добавим - кнопку удалить, проверку аутентификации пользователя, альтернативный вариант (войти/зарегестрироваться)
						<br>Форма простая просто method = 'post'
						<pre>
{% block content %}

&lt;h1>{{ title }}&lt;/h1>&lt;br>

&lt;!-- если пользователь залогиненый -->
{% if request.user.is_authenticated %}

&lt;&lt;div class="form-error">Удалить статью: "{{ object }}"!?&lt;/div>
&lt;br>
<span class="spec"># {{ object }} - это запись в таблице, отображает Сar - title
обрещение к записи через {{ object }} - вроде как в классах представления или формах</span>


&lt;form method="post">

	{% csrf_token %}
	
	&lt;button type="submit" class="btn btn-danger btn-lg">
		Удалить статью
	&lt;/button>
&lt;/form>

{% else %}
&lt;div class="form-error">
	&lt;p>Только авторизованные пользователи могут удалть статьи.</p>
	&lt;br>&lt;br>
	&lt;p>
		Пройдите авторизацию: &lt;a href="{% url 'login' %}" class="btn btn-primary btn-sm">Войти</a>
	&lt;/p>
	&lt;p>
		Либо зарегистрируйтесь:&lt;a href="{% url 'register' %}" class="btn btn-warning btn-sm">Регистрация&lt;/a>
	&lt;/p>
&lt;/div>

{% endif %}
{% endblock %}
						</pre>
					</li>
					<li>
						Добавим кнопку/ссылку удалить на страницу отдельной статьи - car.html
						<pre>
&lt;a class="btn btn-danger" href="{% url 'delete_post' car_slug=car.slug cat_slug=car.cat.slug %}">Удалить статью&lt;/a></pre>
						<br><span class="spec">Обрати внимание, для написания динамической ссылки в шаблоне, где есть id/pk или slug - все их необходимо указывать в href!</span>
					</li>
				</ol>
			</li>



			<li>
				<span class="title_text">
					Добавление поля autor - в модель Car (связь User - Car)
				</span>
				<hr>

				<ol>
					<li>
						В models.py - добавляем поле author
						<pre>
from django.contrib.auth.models import User

class Car(models.Model):
	...
	author = models.ForeignKey(User, on_delete=models.SET_NULL, verbose_name='Автор', blank=True, null=True)
						</pre>
					</li>
					<li>
						Сделаю и применю миграции для добавления поля в Базу данных
						<pre>
python manage.py makemigrations
python manage.py migrate</pre>
					</li>
					<li>
						Смотрим в pgAdmin 4 - добавилось поле, значение для каждой статьи null
					</li>
					<li>
						В админке - можно определить автора - в редактировании статьи, расставлю для всех стаей - автора
					</li>
					<li>
						Для удобства добавлю поле author - в сприске статьей в админке - для этого в  admin.py - class CarAdmin(admin.ModelAdmin 
						<pre>
list_display = ('id', 'title', 'time_create', 'get_html_photo', 'is_published', 'author')
list_editable = ('is_published', 'author')  # запятая - если 1 поле!</pre>
					</li>
					<li>
						Выведу в шаблон car.html - поле автор
						<pre>
&lt;p class="text_desc">Автор: {{ car.author }}&lt;/p></pre>
					</li>
					<li>
						Сделаю так что автоматически автором статьию будет админ - если удалим пользователя, то автором статьи автоматически будет администратор (чтобы не удалисть статьи при удалении автора)
						<br>Для этого - в models.py - class Car(models.Model): - меняю поле - author
						<pre>
# автор - (связь с моделью User, при удалении автора - статья переходит админу, стандартно автором будет админ,
# поле автор не может быть пустым)
author = models.ForeignKey(User, on_delete=models.SET_DEFAULT, verbose_name='Автор', default=1, blank=False)</pre>
					</li>
					<li>
						В функцию представления -show_add_post добавлю строчки кода
						<pre>
if form.is_valid():  # проверка правильности формы, если форма заполнена правильно
    car = form.save(commit=False)  # commit=False - когда нужно внести изменение в поле модели не из формы!
    car.author = request.user  # поле автора заполняется автоматически (залогиненый пользователь)
    car.save()  # сохраняем модель</pre>
    					<br>Полная функция представления дополненияя нового коста
    					<pre>
# добавление нового поста
def show_add_post(request):
    if request.method == 'POST':  # если уже введены какие-то данные
        # request.FILES - Обязательно если есть файлы, изображения и ТД
        form = CarAddForm(request.POST, request.FILES)  # форма = заполненная форма
        if form.is_valid():  # проверка правильности формы, если форма заполнена правильно
            car = form.save(commit=False)  <span class="spec"># commit=False - когда нужно внести изменение в поле модели не из формы!</span>
            car.author = request.user  # поле автора заполняется автоматически (залогиненый пользователь)
            car.save()  # сохраняем модель
            return redirect('home')  # перенаправление домой при успешном заполнении
    else:  # если никаких данный пользователь ещё не вводил
        form = CarAddForm()  # отображаем пустую форму для заполнения

    context = {
        'title': 'Добавление статьи',
        'all_categories': all_categories,
        'form': form,
      }
    return render(request, 'blog/add_post.html', context=context)</pre>

					</li>
					<li>
						Сделаю так что отображать ссылку для редактирования и удаления статью будут только автору статьи или администратору.
						<br>
						Для этого в car.html - добавляем конструкцию if
						<pre>
&lt;h3>Автор: {{ car.author }}&lt;/h3>
&lt;p class="text-muted">Время обновления поста: {{ car.time_update }}&lt;/p>

{% if car.author == request.user or request.user.id == 1 %}

&lt;a class="btn btn-warning" href="{% url 'update_post' car_slug=car.slug cat_slug=car.cat.slug %}">Редактировать статью&lt;/a>
&lt;a class="btn btn-danger" href="{% url 'delete_post' car_slug=car.slug cat_slug=car.cat.slug %}">Удалить статью&lt;/a>

{% else %}

&lt;p class="text-info">Вы не можете редактировать эту статью&lt;/p>

{% endif %}</pre>
					</li>
					<li>
						Для дополнительной безопасности (чтобы через url - не автор статьи не смог удалить статью через url) добавим проверку,  если пользователь автор статьи или администатор
						<br>В delete_post и create_post - аналогично в двух формах
						<pre>
<!-- если это автор статьи или администратор -->
{% if car.author == request.user or request.user.id == 1 %}

блок кода - форма удаления или редактирования статьи

<!-- если пользователь не автор статьи и не администратор -->
{% else %}

блок кода - ошибка, вы не автор статьи

{% endif %}</pre>
					</li>
				</ol>
			</li>

			<li>
				<span class="title_text">Переделаю функцию представления show_car - на класс представления ShowCar</span>
				<hr>

				<ol>
					<li>
						Во views.py - комментируем функцию представления show_car, и пишем новый класс представления для определённой машины
						<pre>
from django.views.generic import .., .., DetailView

# страница отдельной машины
class ShowCar(DataMixin, DetailView):
    model = Car
    template_name = 'blog/car.html'
    # !указываем только car_slug - из get_absolute_ur
    # !несмотря на то что в пути есть и car_slug ? почему так хз
    slug_url_kwarg = 'car_slug'  # !для пути 'category/&lt;slug:cat_slug>/&lt;slug:car_slug>/'
    context_object_name = 'car'  # обращаемся в шаблоне {{ car.поле }} - вместо object

    # формируем полный контекст
    # kwargs = {'cat_slug': self.cat.slug, 'car_slug': self.slug}
    # kwargs (пример из одного поста) = {'cat_slug': 'italy', 'car_slug': 'ferrari-488-gtb'}
    def get_context_data(self, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)  # распаковываем изначальный контекст
        c_def = self.get_user_context(cat_selected=self.kwargs['cat_slug'])
        return {**context, **c_def}  # в шаблон передаём полный контекст
						</pre>
						<br><span class="spec">
							Что здесь важно:<br>
							1. slug_url_kwarg = 'car_slug' - этого достаточно в классе представления чтобы получить путь - 'category/&lt;slug:cat_slug>/&lt;slug:car_slug>/ - то есть cat_slug указываеть не нужно (как в функции представления)
							<br>2. context_object_name = 'car' - чтобы в шаблоне к обхекту обращатся не как object (по стандарту) - а как car. car  = Car.object.get(slug=car_slug)
							<br>3. kwargs = {'cat_slug': self.cat.slug, 'car_slug': self.slug}<br>kwargs (пример из одного поста) = {'cat_slug': 'italy', 'car_slug': 'ferrari-488-gtb'}
							<br>4. Для получения cat_selected  - он должен быть равен cat_slug - добавляем в c_def: c_def = self.get_user_context(cat_selected=self.kwargs['cat_slug'])
						</span>
						<br><br>
					</li>
					<li>
						Корректируем маршрут, т.е обращаемся не к def show_car, а к классу представления class ShowCar
						<pre>path('category/&lt;slug:cat_slug>/&lt;slug:car_slug>/', ShowCar.as_view(), name='car')</pre>
					</li>
					<li>
						Всё страница отдельной статьи - работает как и раньше, букваньно за 2 действия.
				</ol>	
			</li>


			<li>
				<span class="title_text">Добавление комментариев к постам (модель Comment)</span>
				<hr>

				<ol>
					<li>
						Проришем модель Comment - в models.py
						<pre>
# класс комментарии
class Comment(models.Model):
    # отношение к определенному посту (записи в Car)
    car_post = models.ForeignKey(Car, on_delete=models.CASCADE, verbose_name='Статья', blank=True, null=True, related_name='comment_car')
    # автор - связь с моделью User
    author_comment = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='Автор комментария', blank=True, null=True)
    # дата создания комментария
    time_create_comment = models.DateTimeField(auto_now_add=True, verbose_name='Время создания комментария')
    # текст комментария
    text_comment = models.TextField(verbose_name='Текст комментария')
    # статус комментария (видно/не видно)
    status_comment = models.BooleanField(verbose_name='Видимость комментария', default=True)</pre>
					</li>
					<li>
						Создаём и принимаем миграции
						<pre>
python manage.py makemigrations  # создаём
python manage.py migrate  # принимаем
						</pre>						
					</li>
					<li>
						Создадим форму для создания статьи. В forms.py
						<pre>
# форма для комментария
class CommentForm(forms.ModelForm):
    class Meta:
        model = Comment  # наша модель
        # поля отображаемые в форме
        fields = ['text_comment']
        widgets = {
            'text_comment': forms.Textarea(attrs={'rows': 1, 'class': 'form-control'}),
        }</pre>
					</li>
					<li>
						Делаем представление, буду делать с помощью класса представлени DetailView
						<br>Во views.py - добавлю - расширяем класс представления ShowCar - стандартным миксином, FormMixin, так как DetailView - изначально не может иметь форм
						<br><strong>FormMixin -Предоставляет возможность показать и обработать форму в запросе.</strong>
						<pre>
from django.views.generic.edit import FormMixin

class ShowCar(DataMixin, DetailView, FormMixin):
	...
	...</pre>
						<br><span class="spec">
							Важную информацию можно брать с репозитория github django
						</span>	
						<br><a href="https://github.com/django/django">https://github.com/django/django</a>
					</li>
					<li>
						Выводим форму в классе представления class ShowCar, так как мы расширились от миксина django - FormMixin  - у нас есть возможность в свой класс представления добавлять атрибут - form_class = (имя формы)
						<br>В views.py- class ShowCar
						<pre>
from .forms import ...., ..., CommentForm	# наши формы forms.py

form_class = CommentForm  # наша форма для комментариев</pre>
						Теперь можем выводить форму - в шаблоне!
					</li>
					<li>
						Выводим форму в шаблон car.html.
						<pre>
<!-- Комментарии -->
&lt;br>&lt;br>&lt;br>&lt;br>
&lt;h3 class="text_desc">Комментарии к посту&lt;/h3>
&lt;hr>

&lt;p>Добавить комментарий&lt;/p>
&lt;form action="" method="post" id="add_comment" enctype="multipart/form-data">
{% csrf_token %}
&lt;div class="col-12">{{ form.as_p }}&lt;/div>
&lt;/form>

&lt;button form="add_comment" type="submit" class="btn btn-primary btn-md">
	Добавить комментарий
&lt;/button></pre>
					<br>
					<span class="spec">
						Что здесь важно:
						<br>1. &lt;form action="" - означает что ссылаемся на ту страницу где находимся!
						<br>2. Необходимо связать форму, с кнопкой. В тегах формы создаём id, в тегах кнопке ссылаемся на это id:
						<br> - &lt;form ... id="add_comment" ..>
						<br> - &lt;button form="add_comment" ...>
					</span>
					</li>
					<li>
						Для того чтобы кнопка добавить заработала, необходимо в классе представления переопределить метод post.
						<pre>
    # переопределяем метод пост (для того чтобы сохранялись комментарии)
    # self - это все объекты класса
    # request- запрос от пользователя
    def post(self, request, **kwargs):
        form = self.get_form()  # получить форму
        if form.is_valid():
            return HttpResponse('работает')
        else:
            return HttpResponse('не валидна')</pre>
            			промежуточный вариант - для понимания что делаем всё правильно и post - работает,  при отправке комментария - в браузере должно выводится 'работает'
					</li>
					<li>
						Полный класс представления
						<pre>
# страница отдельной машины
class ShowCar(DataMixin, DetailView, FormMixin):
    model = Car
    template_name = 'blog/car.html'
    # !указываем только car_slug - из get_absolute_ur
    # !несмотря на то что в пути есть и car_slug ? почему так хз
    slug_url_kwarg = 'car_slug'  # !для пути 'category/&lt;slug:cat_slug>/&lt;slug:car_slug>/'
    # context_object_name = 'car'  # обращаемся в шаблоне {{ car.поле }} - вместо object
    form_class = CommentForm  # наша форма для комментариев
    # success_msg = 'Комментарий создан!'  # сообщение при успешном создании комментария - РАЗБЕРИСЬ

    # определим перенаправление на нашу страницу, после отправки комментария, так как в пути у нас есть cat_slug, car_slug
    def get_success_url(self, **kwargs):
        # get_object() - это по сути Car.objects.get(1 штука)
        # kwargs - мы добавляем /&lt;slug:cat_slug>/&lt;slug:car_slug>/
        # полный наш путь равен пути path = 'car' - для этого и добавляли cat_slug car_slug
        # То есть при успешном заполнении формы (отправка комментария, нас оставит на этой же странице)
        return reverse_lazy('car', kwargs={'cat_slug': self.get_object().cat.slug, 'car_slug': self.get_object().slug})
  
    # переопределяем метод пост (для того чтобы сохранялись комментарии)
    # self - это все объекты класса
    # request- запрос от пользователя
    def post(self, request, **kwargs):
        form = self.get_form()  # в переменной форм занесли ту форму которую отправили
        # 2
        if form.is_valid():  # проверка правильности формы
            return self.form_valid(form)  # выполняется после form_valid - передаёт уже сохранённую форму
        else:
            return self.form_invalid(form)  # иначе вернёт что у нас неправильно

    # 1
    def form_valid(self, form):  # берём форму
        self.object = form.save(commit=False)
        self.object.car_post = self.get_object()  # получение и запись экземпляра статьи (одной машины)
        self.object.author_comment = self.request.user  # получение и запись имени автора
        self.object.save()  # форма пересохраняется с новыми данными
        return super().form_valid(form)  # форма передаётся в базу данных и программа продолжит свои действия

    # формируем полный контекст
    # kwargs = {'cat_slug': self.cat.slug, 'car_slug': self.slug}
    # kwargs (пример из одного поста) = {'cat_slug': 'italy', 'car_slug': 'ferrari-488-gtb'}
    def get_context_data(self, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)  # распаковываем изначальный контекст
        c_def = self.get_user_context(cat_selected=self.kwargs['cat_slug'])
        return {**context, **c_def}  # в шаблон передаём полный контекст</pre>
        				<br>
        				<span class="spec">
        					Что здесь важно:<br>
        					1. Для переопределения параметров, которые запонили не в форме (например автоматическое имя аавтора) блок кода - def form_valid(self, form):
        					<br>2. Для получения формы и сохранения в бд, переопределяем Post - который в габлоне в тегах form
        					<br>3. Для того чтобы остаться на той же странице, после успешного заполнения формы - def get_success_url(self, **kwargs):
        					<br>4. Передача параметров в путь, где есть слаги - return reverse_lazy('car', kwargs={'cat_slug': self.get_object().cat.slug, 'car_slug': self.get_object().slug})
        					<br>5. В остальном всё по старому - необходимо будет добавить высплывающее окно, что комментарий создан
        				</span><br><br>
					</li>
					<li>
						Отображаем комментарии, автора комментария, дату публикации в шаблоне
						<br>Шаблон car.html
						<pre>
&lt;p>Комментарии: {{ car.comment_car.all.count }}&lt;/p> # количество комментариев
...
...	
&lt;!-- Обращение к комментарию из объекта с помощью related_name='comment_car'
из class Comment(models.Model): - car_post &lt;p>{{ car.comment_car.all }}&lt;/p> -->
{% for сom_element in car.comment_car.all reversed  %}

&lt;ul class="list-group">
	&lt;li class="list-group-item list-group-item-info">Автор комментария: {{ сom_element.author_comment }}&lt;/li>
	&lt;li class="list-group-item list-group-item-light">{{ сom_element.text_comment|linebreaks }}&lt;/li>
	&lt;li class="list-group-item list-group-item-secondary">Дата создания: {{ сom_element.time_create_comment }}&lt;/li>
&lt;/ul>

&lt;br>&lt;br>


{% endfor %}</pre>
					    <span class="spec">
							Что здесь важно:<br>
							1. car.comment_car.all - обращение к комментарию из Car в Comment, c помощью Comment - car_post - related_name='comment_car'
							<br>2. Цикл for в шаблоне с конца (для отображения свежих коментариев в начале) - {% for i in list reversed  %}
							<br>3. {{ сom_element.text_comment|linebreaks }} - Авто абзац
							<br>4. &lt;/hr> - линия подчеркивание
						</span><br><br>
					</li>
					<li>
						Далее делал проверки аутентификации, и отображал что нужно кому нужно, с помощью проверки - {% if request.user.is_authenticated %} - авторизован ли пользователь:
						<br>-Комментарии могут видить все
						<br>-Комментировать могут только авторизоавнные пользователи
						<br>-Не авторизованному пользователю вывел ссылки войти или загегистрироваться
					</li>
				</ol>

			</li>



			<li>
				<span class="title_text">Переделаю представления home.html - вместо функциий представления с помощтю класса ListView</span>
				<hr>
				<ol>
					<li>
						def show_home(request): - комментирую - и делаю класс представления - class CarsAllShow(DataMixin, ListView):
						<pre>
# домашняя страница
class CarsAllShow(DataMixin, ListView):
    paginate_by = 6  # пагинация
    model = Car  # модель cars = Car.objects.all()
    template_name = 'blog/home.html'  # шаблон
    context_object_name = 'cars'  # objects = cars (просто имя)

    # формируем полный контекст
    def get_context_data(self, *, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)  # контекст Car.object.all()
        c_def = self.get_user_context(cat_selected='all',
                                      title='Все модели')  # наш контекст + DataMixin
        return {**context, **c_def}  # в шаблон передаём полный контекст</pre>
					</li>
					<li>
						Правлю маршрут name='home'
						<pre>path('', CarAllShow.as_view(), name='home'),</pre>
					</li>
					<li>
						Немного подкорректировал шаблон (3 столбца вместо двух)
						<br>Пагинацию в шаблоне вообще не трогал всё работает как работало
						<br><br><strong>Всё буквально два действия и вместо функции представления -класс, который более предпочтительней и удобный</strong>
					</li>
				</ol>
			</li>


&lt;

			<li>
				<span class="title_text">Переделаю представления category.html - вместо функциий представления с помощтю класса ListView</span>
				<hr>
				<ol>
					<li>
						Для начала сделал отдельный шаблон category.html - так как хочу что отображение по категориям было бы в другом стиле (дело не в пагинации, выводе некоторых авто или чтом то другом - просто стиль шаблона)
					</li>
					<li>
						Комментирую/ удаляю функцию представления - def show_categories(request, cat_slug):
					</li>
					<li>
						Делаю класс представление - CarsCategoryShow
						<pre>
# вывод машин по категориям
class CarsCategoryShow(DataMixin, ListView):
    paginate_by = 2
    model = Car
    template_name = 'blog/category.html'
    context_object_name = 'cars'
    allow_empty = False  # для отображения 404

    # параметры вывода (выводим записи только определенной категории)
    def get_queryset(self):
        return Car.objects.filter(cat__slug=self.kwargs['cat_slug'])

    # полный контекст
    def get_context_data(self, *, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)
        # получение выбранной категории - для получения параметров категории
        select_category = Category.objects.get(slug=self.kwargs['cat_slug'])
        c_def = self.get_user_context(cat_selected=select_category.slug,
                                      title=f'Производство: {select_category.name}')
        return {**context, **c_def}</pre>
					</li>
					<li>
						Корректирую маршрут name='category'
						<pre>path('category/&lt;slug:cat_slug>/', CarsCategoryShow.as_view(), name="category"),</pre>
					</li>
				</ol>
			</li>


&lt;



			<li>
				<span class="title_text">Добавлю всплываюшее сообщение, при успешном создании комментария</span>
				<hr>
				<ol>
					<li>
						Добавляем в форму сообщение - (всплывающее сообщение при успешном создании комментария)
						<br>views.py - class ShowCar
						<pre>
# SuccessMessageMixin- миксин для сообщения, при работе с любыми формами!		
class ShowCar(SuccessMessageMixin, ..., ..., FormMix...):
	......
	# всплывающий комментарий {% if messages %} - {% for m in messages %}
	success_message = "Комментарий успешно создан!"</pre>
						<span class="spec">
							Важно! SuccessMessageMixin - должен быть первым в списке базовых классов! - чтобы всплывающее сообщение срабатывало!
						</span>
					</li>
					<li>
						В шаблоне отображаем само сообщение
						<br>car.html - в любом месте, я отображаю прям под кнопкой 'добавить комментарий'
						<pre>
&lt;!-- Всплывающий комментарий -->
&lt;div class="bg-success">
	{% if messages %}
		{% for m in messages %}
			&lt;h3>{{ m }}&lt;/h3>
		{% endfor %}
{% endif %}
&lt;/div></pre>
					</li>
					<li>
						Теперь при создании комментария - будет выведено сообщение - "Комментарий успешно создан!" - после другого действия на странице, или обновления страницы, сообщение исчезнет. Т.е всё как и планировал!
					</li>
				</ol>
			</li>


&lt;





			<li>
				<span class="title_text">Регистрирую модель в админ панеле (Comment)</span>
				<hr>
				<ol>
					<li>
						Приведу в подобающий вид отображение комментов (в админке), добавив Meta и __str__.
						<br>models.py - class Comment
						<pre>
class Comment(models.Model):
	....
    class Meta:
    verbose_name = "Комментарий"
    verbose_name_plural = "Комментарии"
    ordering = ['-time_create_comment']  # сортировка

    # отображение записи по данным
    def __str__(self):
        return f'Авто: {self.car_post}, Коммент: {self.text_comment}'</pre>
					</li>
					<li>
						Рагистрирую модель в админ панеле
						<br>admin.py
        				<pre>admin.site.register(Comment)</pre>
					</li>
				</ol>
			</li>


&lt;


			<li>
				<span class="title_text">Добавляем лайки к комментарием</span>
				<hr>
				<ol>
					<li>
						Добавляю модель в models.py для лайков коммтария
						<pre>
# Лайки на Комменты
# Буду считать количество LikeComment.objects.filter(comment=comment.pk)
class LikeComment(models.Model):
    # Связь с пользователем
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='Лайкнувший пользователь')
    # Связь c определённым комментарием
    comment = models.ForeignKey(Comment, on_delete=models.CASCADE, verbose_name='Комментарий для лайка', related_name='comment_like')

    class Meta:
        verbose_name = "Лайк комментария"
        verbose_name_plural = "Лайки комментария"
        # db_table = 'LikeComment'  # для названия таблицы в DB

    def __str__(self):
        return f'ЛАЙК_К - {self.comment},' \
               f'Пользователь: {self.user}.'</pre>
					</li>
					<li>
						Создам и сделаю миграции
					</li>
					<li>
						Зарегистрирую модель LikeComment - в admin.py
						<pre>admin.site.register(LikeComment)</pre>
					</li>
					<li>
						Создал пару фальшивых лайков через админку - (2 записи модели - LikeComment)
					</li>
					<li>
						<span class="spec">
							Выводим количество лайков в шаблоне
						</span>
						<br>В представлении ничего менть не нужно!
						<br>Шаблон car.html
						<pre>
{% for сom_element in car.comment_car.all reversed  %}
&lt;ul class="list-group">
	&lt;li class="list-group-item list-group-item-info">
_______всё что выше без изменения_______

		# если количество лайков больше 0
		{% if сom_element.comment_like.all|length > 0 %}
		Количество лайков {{ сom_element.comment_like.all|length }}
		{% endif %}
		
		Автор комментария: {{ сom_element.author_comment }}

	&lt;/li>
	&lt;li>
		..Текст коммента
	&lt;/li>
	&lt;li>
		..дата комета
	&lt;/li></pre>
						<span class="spec">
							Что здесь важно - связи related_mane - Сar-->Comment-->LikeComment - т.е через 1 класс можно обратится к третьему!:
							<br><br>
							- car.comment_car.all = Записи Сomment-ForeingKey-Car (related_name=comment_car)<br>
							- &lt;QuerySet><br>
							-то есть все записи Comment связанные к определённой записи Car
							<br><br>
							- сom_element - это одна запись (1 комментарий)
							<br><br>
							- сom_element.comment_like.all = Запись LikeComment-ForeignKey-Comment (related_name=comment_car)<br>
							- &lt;QuerySet><br>
							- то есть все записи относящиеся к определённому комментарию
							В нашем случае одна запись это 1 лайк
							<br>
							<br>
							- ...|length }} - длина QuerySeta - то есть количество записей!
							<br><br>
						</span>
					</li>
					<li>
						Добавлю одну функцию кнопки лайк (добавить/убрать) - (По сути записей  модели LikeComment)
						<br>Необходим будет маршрут url - для функции, но переходить на эту страницу нет необходимости
						<br>-Но сами функции будут возвращать на страницу поста - редирект, то есть мы будем всегда на одной странице - маршруты фикция
					</li>
					<li>
						В моделе - Comment - добавлю метод get_absolute_url - для получения urlа для кнопики "ЛАйК" - к каждому комментарию. (По сути необходимо создать маршрут для каждого комментария)
					</li>
					<pre>
class Comment(models.Model):
	....
	....
	# функция формирования маршрута к ссылке
    def get_absolute_url(self):  # self - ссылка на один экземпляр(строку) таблицы модели
        # reverse('имя пути', kwargs={ Category-slug, Car-slug, Comment-slug}
        return reverse('like_button_comment', kwargs={'cat_slug': self.car_post.cat.slug,
                                                      'car_slug': self.car_post.slug,
                                                      'com_id': self.pk})</pre>
                        <span class="spec">
                        	<br>-like_button_comment - path name='__'
							<br>-self.car_post.cat.slug = Category - поле slug
							<br>-self.car_post.slug = Car - поле slug
							<br>-self.self.pk = Comment - поле slug

							<br>-где car_post = ForeignKey Car | cat = ForeignKey Category
							<br>-То есть самой удалённой модели дошли до первой, с помощью ForeingKey	
                        </span><br><br>
					<li>
						Пишу представление для кнопки лайк комментария (поиведие - при нашатии на неё)
						<br>views.py
						<pre>
# поведение кнопки лайк
@login_required
def like_button_comment(request, cat_slug, car_slug, com_id):
    # или 404 или Comment.objects.get(pk=com_id)
    # comment - жто поле модели LikeComment-> ForeingKey -> Сomment
    comment = get_object_or_404(Comment, pk=com_id)
    author_comment = comment.author_comment  # только для вывода во всплывающем сообщении

    # получаем или создаём запись в модели LikeComment (то есть лайк)
    like_comment, created = LikeComment.objects.get_or_create(
        comment=comment,
        user=request.user
    )

    # если запись не создалась (т.е она уже была)
    if not created:
        like_comment.delete()
        messages.info(request, f"Вам больше не нравится комментарий от пользователя - {author_comment}")
    else:  # если запись добавилась - (лайкнули)
        like_comment.save()  # сохраняем лайк (запись LikeComment) в БД
        messages.info(request, f'Вам понравился комментарий от пользователя - {author_comment}')
    # остаёмся на странице поста, через запятую все динамические параметры (получали с реквестом)
    return redirect('car', cat_slug, car_slug)</pre>
    				<br>
    					<span class="spec">
    						Очень интересная функция, множество функционала, при лаконичном исполнении!
    						<br>- Приём трёх динамических параметров (slug/slug/pk)
    						<br>- Только залогиненый может пользоваться
    						<br>- 404 или объект
    						<br>- Достаём поле из записи модели, для передачи в шаблоне
    						<br>- Проверка, ставили ли лайк или нет
    						<br>- Запись в БД и удаление, при одном и том же действии
    						<br>- Всплывающее сообщение
    						<br>- f строка, передача значения из бд в сообщение
    						<br>- Остаёмся на той же странице
    						<br>- Передача динамических параметров slug/slug - в redidect
    					</span>
    					<br><br>
					</li>
					<li>
						Для функции представления нужен маршрут, даже если на него мы не будем попадать (маршрут фикция)
						<br>urls.py
						<pre>path('category/&lt;slug:cat_slug>/&lt;slug:car_slug>/&lt;int:com_id>/', like_button_comment, name='like_button_comment'),</pre>
					</li>
					<li>
						В шаблоне car.html - добавляем кнопку лайк - причем так чтобы она выглядела по разному, если пользователь ставил лайк или неставил
						<br><br>-Для этого необходимо найти сами символы  - беру из <a href="https://fonts.google.com/icons?icon.style=Rounded&icon.query=like&icon.platform=web">https://fonts.google.com/</a>
						<br><br>-Беру ссыллку на символы и добавляю в head base.html
						<br><br>-Беру "настройки" css с сайта и загружаю в blog/static/blog/css/styles.css
						<br><br>Отображаю в самом шаблоне car.html - иконка будет ссылкой, кнопки лайк, и вышлядить будет по разному в зависимости от того - нажат лайк или нет
						<br>Весь блок кода, для отображения всего комментария (с кнопками и счётчиком лайка) - car.html
						<pre>
&lt;!-- ПЕРЕБИРАЮ ВСЕ КОММЕНТАРИИ К ПОСТУ	 -->
{% for сom_element in car.comment_car.all reversed  %}

{% if request.user.is_authenticated %} &lt;!-- если залогинен -->

&lt;ul class="list-group">&lt;!--  начало списка (1 комментарий) -->
	&lt;li class="list-group-item list-group-item bg-secondary bg-gradient text-white">

		&lt;div class="d-flex bd-highlight mb-0">
			&lt;div class="p-0 bd-highlight" style="font-size: 1.5em">{{ сom_element.author_comment }}&lt;/div>


			&lt;div class="p-0 bd-highlight ms-auto">

				&lt;!-- перебираю все LikeComment записи (все лайки к коменту) -->
				{% for user_likes in сom_element.comment_like.all %}
													
				&lt;!-- ЕСЛИ ПОСТАВИЛ ЛАЙК -->
				{% if request.user == user_likes.user %}						
				&#9989;
				{% endif %}&lt;!-- ЕСЛИ ПОСТАВИЛ ЛАЙК -->

				
				{% endfor %}&lt;!-- перебираю все лайки к коменту-->
				
				
				&lt;!-- ЛАЙК КНОПКА -->
				&lt;a class="btn" href="{{ сom_element.get_absolute_url }}">
					&lt;span class="material-symbols-rounded">thumb_up&lt;/span>
				&lt;/a>
				
				&lt;!-- кнопка на будущее , вместо галочки рядом со сделанным лайком -->
				&lt;!-- &lt;a class="btn" href="{{ сom_element.get_absolute_url }}">
					&lt;span class="material-symbols-outlined">thumb_up&lt;/span>
				&lt;/a>-->						

				&lt;!-- если количество лайков больше 0 - ПОКАЖУ КОЛИЧЕСТВО -->
				{% if сom_element.comment_like.all|length > 0 %}
				&lt;span style="font-size: 1.2em" class="text-white">  {{ сom_element.comment_like.all|length }} &lt;/span>
				{% endif %} &lt;!-- если количество лайков больше 0 -->

			&lt;/div>
		&lt;/div>
	&lt;/li>
	&lt;!-- ТЕКСТ КОММЕНТАРИЯ -->
	&lt;li class="list-group-item list-group-item-light">{{ сom_element.text_comment|linebreaks }}&lt;/li>
	&lt;!-- ДАТА КОММЕРИЯ -->
	&lt;li class="list-group-item list-group-item-secondary">{{ сom_element.time_create_comment }}&lt;/li>

&lt;/ul> 

&lt;br>&lt;br>

{% endif %} &lt;!-- если  залогинен -->


{% endfor %}&lt;!-- ПЕРЕБИРАЮ ВСЕ КОММЕНТАРИИ К ПОСТУ	 --></pre>
						<br><strong> На данный момент получилось только чтобы при нажатии лайка - появлялась галочка рядом со значком лайка - необходимо сделать чтобы менялся сам занчёк (так как приходится делать через цикл) - исправь</strong>
					</li>
				</ol>
			</li>


&lt;





			<li>
				<span class="title_text">Убираю комментарии (+лайки к ним) в отдельное приложение</span>
				<hr>
				<ol>
					<li>
						Создаю приложение
						<pre>python manage.py startapp comments </pre>
					</li>
					<li>
						Регистрирую приложение в settings.py
						<pre>
INSTALLED_APPS = [
	....
	'comments.apps.CommentsConfig',  # наше приложение comments
]</pre>
					</li>
					<li>
						В основном urls.py (avtoblog) расширяю urlpatterns - из приложения comments
					</li>
					<li>
						Переношу все необходимые модели (Comment, LikeComment) - из blog/models.py - в comments/models.py
						<br>Сразу импортирую всё седостающие модели (Car, Category, User)
						<pre>
from django.contrib.auth.models import User
from django.db import models
from django.urls import reverse
from blog.models import Car


# Create your models here.
# класс комментарии
class Comment(models.Model):
    # отношение к определенному посту (записи в Car)
    car_post = models.ForeignKey(Car, on_delete=models.CASCADE, verbose_name='Статья', blank=True, null=True,
                                 related_name='comment_car')
    # автор - связь с моделью User
    author_comment = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='Автор комментария', blank=True,
                                       null=True)
    # дата создания комментария
    time_create_comment = models.DateTimeField(auto_now_add=True, verbose_name='Время создания комментария')
    # текст комментария
    text_comment = models.TextField(verbose_name='Текст комментария')
    # статус комментария (видно/не видно)
    status_comment = models.BooleanField(verbose_name='Видимость комментария', default=True)

    class Meta:
        verbose_name = "Комментарий"
        verbose_name_plural = "Комментарии"
        ordering = ['time_create_comment']  # сортировка

    # отображение записи по данным
    def __str__(self):
        return f'Авто: {self.car_post}, ' \
               f'Коммент: {self.text_comment}'

    # функция формирования маршрута к ссылке
    def get_absolute_url(self):  # self - ссылка на один экземпляр(строку) таблицы модели
        # reverse('имя пути', kwargs={ Category-slug, Car-slug, Comment-slug}
        return reverse('like_button_comment', kwargs={'cat_slug': self.car_post.cat.slug,
                                                      'car_slug': self.car_post.slug,
                                                      'com_id': self.pk})


# Лайки на Комменты
# Буду считать количество LikeComment.objects.filter(comment=comment.pk)
class LikeComment(models.Model):
    # Связь с пользователем
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='Лайкнувший пользователь')
    # Связь с определённым комментарием
    comment = models.ForeignKey(Comment, on_delete=models.CASCADE, verbose_name='Комментарий для лайка',
                                related_name='comment_like')

    class Meta:
        verbose_name = "Лайк комментария"
        verbose_name_plural = "Лайки комментария"
        # db_table = 'LikeComment'  # для названия таблицы в DB

    def __str__(self):
        return f'ЛАЙК_К - {self.comment},' \
               f'Пользователь: {self.user}.'</pre>
					</li>
					<li>
						В comments - cоздаю каталог templates, для шаблонов и внтурири подкаталог - с названием приложения - comments
						<pre>comments/templates/comments</pre>
					</li>
					<li>
						В этот подкаталог переношу все шаблоны которые необходимы  - оказалось на данный момент их нет
						<strong>оказалось на данный момент их нет</strong>  - но скорее всего появится (сделаю пользовательский тег шаблонов для комментария)
					</li>
					<li>
						Из blog/views.py - в comments/views.py - перенесу все представления которые необходимы (like_button_comment)  - но добавление комментария осталось в классе представления - ShowCar
						<br><br>Сразу импортирую все функции и класса в comments/views.py
						<pre>
from django.contrib.auth.decorators import login_required
from django.shortcuts import get_object_or_404, redirect
from comments.models import Comment, LikeComment


# поведение кнопки лайк
@login_required
def like_button_comment(request, cat_slug, car_slug, com_id):
    # или 404 или Comment.objects.get(pk=com_id)
    # comment - жто поле модели LikeComment-> ForeignKey -> Comment
    comment = get_object_or_404(Comment, pk=com_id)
    # author_comment = comment.author_comment  # только для вывода во всплывающем сообщении

    # получаем или создаём запись в модели LikeComment (то есть лайк)
    like_comment, created = LikeComment.objects.get_or_create(
        comment=comment,
        user=request.user
    )

    # если запись не создалась (т.е она уже была)
    if not created:
        like_comment.delete()
        # messages.info(request, f"Вам больше не нравится комментарий от пользователя - {author_comment}")
    else:  # если запись добавилась - (лайкнули)
        like_comment.save()  # сохраняем лайк (запись LikeComment) в БД
        # messages.info(request, f'Вам понравился комментарий от пользователя - {author_comment}')
    # остаёмся на странице поста, через запятую все динамические параметры (получали с request)
    return redirect('car', cat_slug, car_slug)</pre>
					</li>
					<li>
						Создаю свой urls.py - в приложении comments<br>
						Перемещаем все маршруты из blog/urls.py в comments/urls.py
						<pre>
from django.urls import path
from comments.views import like_button_comment

urlpatterns = [
    path('category/&lt;slug:cat_slug>/&lt;slug:car_slug>/&lt;int:com_id>/', like_button_comment, name='like_button_comment'),</pre>
					</li>
					<li>
						Из blog/admin.py в comments/admin.py - переношу вме админ модели комментариев и лайков 
						<pre>
from django.contrib import admin

from comments.models import Comment, LikeComment


class CommentAdmin(admin.ModelAdmin):
    list_display = ('id', 'car_post', 'author_comment', 'text_comment')

    
admin.site.register(Comment, CommentAdmin)
admin.site.register(LikeComment)</pre>
					</li>
					<li>
						Добавлю verbose_name - для приложения comments - в comments/apps.py - class CommentsConfig
						<pre>
class CommentsConfig...:
	....
	verbose_name = 'Приложение Комментарии'  # для отображения в админке
						</pre>
					</li>
					<li>
						Пробую запустить сервер  - чтобы увидеть ошибки (то есть что забыли подправить)
						<br>Переносим форму для комментариев - из blog/forms.py - в comments/forms.py  - предварительно создав сам forms.py в приложении comments
						<pre>
from django import forms
from comments.models import Comment


# форма для комментария
class CommentForm(forms.ModelForm):
    class Meta:
        model = Comment  # наша модель
        # поля отображаемые в форме
        fields = ['text_comment']
        widgets = {
            'text_comment': forms.Textarea(attrs={'rows': 1, 'class': 'form-control'}),
        }</pre>
					</li>
					<li>
						Корректируем расположение формы для создания комментария в представлении ShowCar - CommentForm.
						<br>blog/views.py
						<pre>from comments.forms import CommentForm  # наши формы forms.py (comments app)</pre>
					</li>
					<li>
						Создаю и применяю миграции
						<pre>
python manage.py makemigrations
python manage.py migrate</pre>
					</li>
					<li>
						Запускаем сервер - проверяем функционал, (комментарии, лайки) - пробуем различные действия с разных акаунтов.
					</li>
					<li>
						По итогу всё работает как и было, так же важно понимать что старые модели (Комментарии и Лайки) - из приложения blog будут удалены, то есть и все записи и все таблицы
					</li>
					<li>
						Даже не пришлось что то корректировать внутри шаблонов, то есть те отображения orm внутри шаблонов остались ровно такиме же!
					</li>
				</ol>
			</li>


&lt;



			<li>
				<span class="title_text">Удаление комментария</span>
				<hr>
				<ol>
					<li>
						Будет возможность удалять комментарий только пользователю который создал комментарий или админу
					</li>
					<li>
						Делаю представление кнопки удаления комментария
						<br>comments/views.py
						<pre>
# кнопка удаления комментария
def delete_button_comment(request, cat_slug, car_slug, com_id):
    # получаю 1 комментарий (по id коммента)
    comment = get_object_or_404(Comment, pk=com_id)
    # если пользователь автор коммента или админ (id 1)
    if request.user.id == comment.author_comment.id or request.user.id == 1:
        # Удаляем комментарий
        comment.delete()
    else:  # если не автор и не админ
        # Вывожу сообщение
        messages.warning(request, 'Вы не можете удалить не свой комментарий')
    # перенаправляюсь на страницу поста
    # обязательно указать динамические параметры
    return redirect('car', cat_slug, car_slug)</pre>
					</li>
					<li>
						Делаю маршрут для кнопки удаления комментария - comments/urls.py
						<pre>
path('category/&lt;slug:cat_slug>/&lt;slug:car_slug>/&lt;int:com_id>/delete_comment',
     delete_button_comment,
     name='delete_comment'),</pre>
					</li>
					<li>
						Отображаю кнокру удалить комментарий в цикле перебора всех комментариев.
						<br>car.html
						<pre>
<!-- Если пользователь автор коммента или админ (id 1) -->
{% if request.user.id == one_coment.author_comment.id or request.user.id == 1 %}

&lt;!-- КНОПКА УДАЛЕНИЕ КОММЕНТАРИЯ -->
&lt;li class="list-group-item list-group-item-secondary">
	&lt;a href="{% url 'delete_comment' car_slug=car.slug cat_slug=car.cat.slug com_id=one_coment.pk %}" class="btn btn-outline-danger btn-sm">
		Удалить комментарий
	&lt;/a>
&lt;/li>

{% endif %}&lt;!-- Если пользователь автор коммента или админ (id 1) --></pre>
						Кнопка - 'Удалить комментарий' - будет видна только авторам комментария или админу с id = 1
					</li>
					<li>
						Всё больше ничего делать не нужно, тема закрыта
					</li>
					<li>
						Может быть позже добавлю редактирование комментария но врятли
					</li>
				</ol>
			</li>


&lt;







			<li>
				<span class="title_text">Добавляю лайки, рейтинг и добавление в закладке к статьям</span>
				<hr>
				<ol>
					<li>
						Создам новое приложение - для рейтинга статей (отношение пользователей и статей) - relatepost
						<pre>python manage.py startapp relatepost</pre>
					</li>
					<li>
						Регистрирую приложение relatepost - в settings.py  - в INSTALLED_APPS
						<pre>
INSTALLED_APPS = [
	....
	'relatepost.apps.RelatepostConfig'  # наше приложение relatepost
]</pre>
					</li>
					<li>
						Добавлю отображение названия приложения в админке - relatepost/apps.py
						<pre>
class RelatepostConfig(AppConfig):
	....
	verbose_name = 'Оценка статей пользователем'  # отображение названия приложения</pre>
					</li>
					<li>
						Пишу первую модель в приложении relatepost - Модель для связи поста и пользователя с его оценками, лайком и закладкой
						<pre>
from django.contrib.auth.models import User
from django.db import models
from blog.models import Car

from django.contrib.auth.models import User
from django.db import models
from blog.models import Car


# отношение пользователя к посту
class UserCarRelation(models.Model):
    RATE_CHOICES = (
        (1, 'Совсем плохо'),
        (2, 'Плохо'),
        (3, 'Нормально'),
        (4, 'Хорошо'),
        (5, 'Отлично'),
    )

    # какой пользователь
    user_relation = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='Оценивающий пользователь')
    # какой пост
    car_relation = models.ForeignKey(Car, on_delete=models.CASCADE, verbose_name='оцениваемый пост',
                                     related_name='relation_from_user')
    # лайк на пост
    is_like_post = models.BooleanField(default=False, verbose_name='Лайк поста')
    # добавление в закладки
    is_bookmarks_post = models.BooleanField(default=False, verbose_name='Пост в закладке')
    # оценка поста
    rate = models.PositiveSmallIntegerField(choices=RATE_CHOICES, null=True, verbose_name='Личная оценка поста')

    class Meta:
        verbose_name = 'Отношение пользователя к посту'
        verbose_name_plural = 'Отношения пользователей к постам''

    def __str__(self):
        return f'Пользователь: {self.user_relation.username} - Статья: {self.car_relation}, Л_оценка: {self.rate}.'</pre>
					</li>
					<li>
						Регистрирую модель - UserCarRelation -  в админке - настраиваю отображение в админке
						<br>relatepost/admin.py
						<pre>
from django.contrib import admin
from relatepost.models import UserCarRelation


class UserCarRelationAdmin(admin.ModelAdmin):
    # список отображаемых столбцов в админ-панели
    list_display = ('id', 'user_relation', 'car_relation', 'is_like_post', 'is_bookmarks_post', 'rate')
    # список полей на которые можно кликнуть - для редактирования
    list_display_links = ('user_relation', 'car_relation')
    # список полей - ко которым можно вести поиск
    search_fields = ('user_relation', 'car_relation')
    # редактирование поля публикации - в списке - в админке
    list_editable = ('is_like_post', 'is_bookmarks_post', 'rate')  # запятая - если 1 поле!
    # фильтр по полям - публикация, время изменения.
    list_filter = ('user_relation', 'car_relation')


# Register your models here.
admin.site.register(UserCarRelation, UserCarRelationAdmin)</pre>
					</li>
					<li>
						Создаю и делаю миграции
						<pre>
python manage.py makemigrations
python manage.py migrate</pre>
					</li>
					<li>
						Добавлю общий рейтинг одной статьи - необходимо добавить поле rating - в модель поста
						<br>blog/models.py - class Car(models.Model):
						<pre>
class Car(models.Model):
	...
	# рейтинг поста (пример рейтинг = 3.68)
    rating = models.DecimalField(max_digits=3, decimal_places=2, default=None, null=True)</pre>
    				<br>
    				<span>
    					Необходимо автоматически записывать рейтинг в базц данных. Попробуй с помощью метода save  модели - rating_set
    				</span>
    				<br>
					</li>
					<li>
						Применю и сделаю миграцию
						<pre>
python manage.py makemigrations
python manage.py migrate</pre>
					</li>
					<li>
						Добавляю метод получения рейтинга, и передачи в шаблон car.html
						<br>blog/views.py - class ShowCar
						<pre>
class ShowCar(SuccessMessageMixin, DataMixin, DetailView, FormMixin):
	.....
	.....
	# метод получения рейтинга поста
    def get_rating(self, **kwargs):
        # получение всех записей, отношений к данному посту
        users_ralations = UserCarRelation.objects.filter(car_relation__slug=self.kwargs['car_slug'])
        sum_rate = 0  # промежуточная переменная - сумма всех рейтингов
        # если количество записей отношений больше нуля 0
        if users_ralations.count() > 0:
            # перебираем все записи отношений
            for one_relation in users_ralations:
                # в промежуточную переменную прибавляем рейтинг отдельной записи
                sum_rate += one_relation.rate
            # полную сумму оценок делим на количество оценок и получаем рейтинг
            rating = sum_rate / users_ralations.count()
        else:
            rating = 0
        return rating

    ....
	def get_context_data(self, object_list=None, **kwargs):
		....
        c_def = self.get_user_context(cat_selected=....,
                                      rating=self.get_rating(),  # получаю рейтинг
                                      ....)</pre>
					</li>
					<li>
						Для получения пейтинга внутри шаблона car.html - необходимо вызвать: {{ rating }}
					</li>
					<li>
						Добавляю метод получения реакции залогиненного пользователя к конкретному посту, и передачи в шаблон car.html
						<br>blog/views.py - class ShowCar
						<pre>
class ShowCar(SuccessMessageMixin, DataMixin, DetailView, FormMixin):
	......
	......
	# Личная оценка пользователя
    def get_my_rel(self, **kwargs):
        # пробуем получить объект (запись по реакции нашего пользователя)
        # по конкретной статье и конкретному пользователю
        try:
            # если объект найдём - реакция пользователя = этот объект
            my_rel = UserCarRelation.objects.get(user_relation__pk=self.request.user.pk,
                                                 car_relation__slug=self.kwargs['car_slug'])

        except UserCarRelation.DoesNotExist:  # если объекта не существует
            my_rel = 0  # реакции пользователя = 0
        # возвращаем реакции конкретного пользователя если
        return my_rel

    .....
    def get_context_data(self, object_list=None, **kwargs):
    	....
		c_def = self.get_user_context(cat_selected=....,
                                      ....,  # получаю рейтинг
                                      my_rel=self.get_my_rel())  # получаю реакции</pre>

					</li>
					<li>
						Чтобы проверить/вызвать реакции от пользователя залогиненного, к конкретому посту в шаблоне - необходимо вызвать
						<pre>
{% if my_rel != 0 %}  # это проверка, оставлял ли залогиненный пользователь какуюто реакцию на данный мост

Лайк = {{ my_rel.is_like_post }}  --> True или False
Закладки = {{ my_rel.is_bookmarks_post }}  --> True или False
Личный рейтинг = {{ my_rel.rate }}  -->  Личный рейтинг</pre>
						<br><span>
							-Необходимо добавить проверки (стоит ли лайк/ добавил ли в закладки) - И в соответствии с этим измненять отображение кнопки лайк и ли галочки закладки, с соответствующими url на добавление или удаление
							<br>-Необходимо выводить форму (Звёзды рейтинга) - Причём даже если и поставили звёзды - необходима возможность редактирования
							(проблема в том что форма уже есть на странице, и вроде как не получится добавить другую - необходимо пробовать с помошью пользовательского тега либо вообще какой то другой способ)
						</span>
					</li>
					<li>
						<span class="spec">
							Добавил форму добавления реакции (рейтинг статьи)
							<br>Форма рабочая, пока в отдельном шаблоне
							<br>Но она не проверяет реагировал ли уже пользователь или нет, в итоге при втором реагировании ошибка - нужно сделать так что если уже реакция была, то запись в бд необходимо изменить а не создавать ещё одну!
						</span>
						<br>На данные момент
						<br>
						views.py
						<pre>
# форма рабочая
def rate_post_form(request, cat_slug, car_slug):
    car = Car.objects.get(slug=car_slug)
    if request.method == 'POST':
        form = UserCarRelationRateForm(request.POST)
        if form.is_valid():
            usercarrelation = form.save(commit=False)
            usercarrelation.user_relation = request.user
            usercarrelation.car_relation = car
            usercarrelation.save()
            return redirect('car', cat_slug, car_slug)
    else:
        form = UserCarRelationRateForm()

    qs = UserCarRelation.objects.all()
    context = {'form': form, 'qs': qs, 'car': car,}
    return render(request, 'blog/add_rate_post.html', context=context)</pre>
    					<br><br>
    					urls.py
    					<pre>
    						path('category/&lt;slug:cat_slug>/&lt;slug:car_slug>/rate_car/', rate_post_form, name='rate_car'),
    					</pre>
    					<br><br>
    					отдельны шаблон - add_rate_post.html
    					<pre>
&lt;form action="{% url 'rate_car' car_slug=car.slug cat_slug=car.cat.slug %}" method="post">
    {% csrf_token %}
    &lt;div class="text-info">{{ form.non_field_errors }}&lt;/div>
    {{ form.as_ul }}
    &lt;div class="text-info">{{ form.errors }}&lt;/div>
    &lt;button type="submit" class="btn btn-primary btn-lg">
        Сохранить
    &lt;/button>
&lt;/form></pre>
					</li>
					<br><br>
					<li style="background: black;">

						<span class="title_text">Удаляю/изменяю из проекта всё что ранее делал относительно рейтинга к посту</span>
						<hr>
						<ol>							
							<li>
								<span class="spec">Удаляю</span>
								Из шаблона car.html - временно уберу всё что ствязно с рейтингом и лайками к постам -  в отдельный файл html - так как будут проблемы, буду менять функции буду менять модели. Оставлю это дело в отдельном файле - для экономии времени в будущем
								<br> - Эта информация будет в (hlam)rating_car.html
							</li>
							<li>
								<span class="spec">Удаляю</span>
								Туда же в - (hlam)rating_car.html  - перенесу информацию из 
								class ShowCar(SuccessMessageMixin, DataMixin, DetailView, FormMixin):
								<br>Получение рейтинга общего, получение записей о реакциях пользователя(буду использовать для лайков и закладок)
								<pre>
_______________________________________________________
blog/VIEWS.PY

class ShowCar(SuccessMessageMixin, DataMixin, DetailView, FormMixin):
	....
	........
	.....
	....

	# метод получения рейтинга поста
    def get_rating(self, **kwargs):
        # получение всех записей, отношений к данному посту
        users_ralations = UserCarRelation.objects.filter(car_relation__slug=self.kwargs['car_slug'])
        sum_rate = 0  # промежуточная переменная - сумма всех рейтингов
        # если количество записей отношений больше нуля 0
        if users_ralations.count() > 0:
            # перебираем все записи отношений
            for one_relation in users_ralations:
                # в промежуточную переменную прибавляем рейтинг отдельной записи
                sum_rate += one_relation.rate
            # полную сумму оценок делим на количество оценок и получаем рейтинг
            rating = sum_rate / users_ralations.count()
        else:
            rating = 0
        return rating


    # Личная оценка пользователя
    def get_my_rel(self, **kwargs):
        # пробуем получить объект (запись по реакции нашего пользователя)
        # по конкретной статье и конкретному пользователю
        try:
            # если объект найдём - реакция пользователя = этот объект
            my_rel = UserCarRelation.objects.get(user_relation__pk=self.request.user.pk,
                                                 car_relation__slug=self.kwargs['car_slug'])

        except UserCarRelation.DoesNotExist:  # если объекта не существует
            my_rel = 0  # реакции пользователя = 0
        # возвращаем реакции конкретного пользователя если
        return my_rel



    def get_context_data(self, object_list=None, **kwargs):
    	......
    	c_def = self.get_user_context(cat_selected=self.kwargs['cat_slug'],
                                      rating=self.get_rating(),  # получаю рейтинг - УДАЛИЛ
                                      my_rel=self.get_my_rel())  # получаю реакции - УДАЛИЛ

_______________________</pre>
							</li>
							<li>
								<span class="spec">Удаляю</span>
								ранее созданные формы (для получения рейтинга)
								<br>relatepost/forms.py
								<pre>
<span class="spec">DELETE</span>
from django import forms
from relatepost.models import UserCarRelation


# форма рейтинга поста
class UserCarRelationRateForm(forms.ModelForm):
    class Meta:
        model = UserCarRelation
        fields = ['rate',]</pre>
							</li>
							<li>
								<span class="spec">Удаляю</span> из blog/views.py
								<pre>
# форма рабочая (рейтинг статьи)
def rate_post_form(request, cat_slug, car_slug):
    car = Car.objects.get(slug=car_slug)
    if request.method == 'POST':
        form = UserCarRelationRateForm(request.POST)
        if form.is_valid():
            usercarrelation = form.save(commit=False)
            usercarrelation.user_relation = request.user
            usercarrelation.car_relation = car
            usercarrelation.save()
            return redirect('car', cat_slug, car_slug)
    else:
        form = UserCarRelationRateForm()

    qs = UserCarRelation.objects.all()
    context = {'form': form, 'qs': qs, 'car': car,}
    return render(request, 'blog/add_rate_post.html', context=context)</pre>
							</li>
							<li>
								Из blog/urls.py удаляю маршрут
								<pre>path('category/&lt;slug:cat_slug>/&lt;slug:car_slug>/rate_car/', rate_post_form, name='rate_car'),</pre>
							</li>
							<li>
								в relate/models.py Изменяю модель UserCarRelation.
								<br>Переименую
								<br>Удалю поле rate
								<br>Удалю RATE_CHOICES
								<br>Изменб __str__
								<br><strong>Отныне данная модель будет отвечать только за лайки и закладки поста!</strong>
								<pre>
class UserCarRelation(models.Model): ---> UPDATE
--->

# Лайки и закладки к посту
class LikeMarkPost(models.Model):
    # какой пользователь
    user_like_mark = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='Пользователь Л-З')
    # какой пост
    post_like_mark = models.ForeignKey(Car, on_delete=models.CASCADE, verbose_name='Пост Л-З')
    # лайк на пост
    is_like_post = models.BooleanField(default=False, verbose_name='Лайк поста')
    # добавление в закладки
    is_bookmarks_post = models.BooleanField(default=False, verbose_name='Пост в закладке')

    class Meta:
        verbose_name = 'Лайк/Закладка поста'
        verbose_name_plural = 'Лайки/закладки к посту'

    def __str__(self):
        return f'Пользователь: {self.user_like_mark.username} - Статья: {self.post_like_mark.slug}.'</pre>
							</li>
							<li>
								В relatepost/admin подкорректирую - отображение модели в админке, включая название моделей!
								<pre>
from django.contrib import admin
from relatepost.models import LikeMarkPost


# лайки закладки в админке
class LikeMarkPostAdmin(admin.ModelAdmin):
    # список отображаемых столбцов в админ-панели
    list_display = ('id', 'user_like_mark', 'post_like_mark', 'is_like_post', 'is_bookmarks_post')
    # список полей на которые можно кликнуть - для редактирования
    list_display_links = ('user_like_mark', 'post_like_mark')
    # список полей - ко которым можно вести поиск
    search_fields = ('user_like_mark', 'post_like_mark')
    # редактирование поля публикации - в списке - в админке
    list_editable = ('is_like_post', 'is_bookmarks_post')  # запятая - если 1 поле!
    # фильтр по полям - публикация, время изменения.
    list_filter = ('user_like_mark', 'post_like_mark')


# Register your models here.
admin.site.register(LikeMarkPost, LikeMarkPostAdmin)</pre>
							</li>
							<li>
								Создаю и применяю миграции
							</li>
						</ol>

					</li>



<br><br>
					<li>

						<span class="title_text">Делаю рейтинг с помошью ajax и hoogan.js </span>
						<hr>
						<ol>
							<li>
								В blog/static/js - создаю файл scripts.js
							</li>
							<li>
								В base.html, в конце перед закрытием body<br>
								- Добавляем ссылку на наш scritpts.js<br>
								- Добавляем библиотеку hogan hoogan.js (ссылку нужно брать из интернета)
								<br>- hogan - это шаблонизатор js , вместо него можно использовать например Vue
								<br><a href="https://twitter.github.io/hogan.js/">
									Установка и инструкция по hogan 
								</a>
								<br><br>Итого наш base.html
								<pre>
...									
&lt;!-- Наш static -  scripts.js -->
&lt;script src="{% static 'blog/js/scripts.js' %}">&lt;/script>

&lt;!-- JS шаблонизатор (почти Vue) hogan.js -->
&lt;script src="http://twitter.github.com/hogan.js/builds/3.0.1/hogan-3.0.1.js">&lt;/script>

&lt;/body>
....</pre>
							</li>							
					
					</li>

					<li>
						relatepost/models.py - делаю новую модель - (просто звёзды 1,2,3,4,5)
						<pre>
# Просто звёзды от 1 до 5 (одна звезда 1 запись)
class RatingStar(models.Model):
    value = models.SmallIntegerField(verbose_name='Значение', default=0)

    def __str__(self):
        return f'{self.value}'
    
    class Meta:
        verbose_name = 'Звезда рейтинга'
        verbose_name_plural = 'Звёзды рейтинга'
        ordering = ['-value']</pre>
					</li>
					<li>
						Зарегистрирую эту модель в админке
						<br>relatepost/admin.py
						<pre>
from relatepost.models import ..., RatingStar

# просто звёзды в админке
class RatingStarAdmin(admin.ModelAdmin):
    list_display = ('id', 'value')


# Register your models here.
admin.site.register(RatingStar, RatingStarAdmin)</pre>
					</li>
					<li>
						Создам и мприменю миграции
						<pre>
python manage.py makemigrations
python manage.py migrate</pre>
					</li>
					<li>
						Создам в админке 5 записей в этой модели
						<pre>1 2 3 4 5</pre>
					</li>
					<li>
						Добалю модель Rating в relatepost/models.py
						<pre>
# Рейтинг (конкретный пользователь, конкретная статья)
class Rating(models.Model):
    user_rate = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='Оценивающий пользователь')
    post_rate = models.ForeignKey(Car, on_delete=models.CASCADE, verbose_name='Оцениваемый пост')
    star = models.ForeignKey(RatingStar, on_delete=models.CASCADE, verbose_name='Звезда')

    def __str__(self):
        return f'Звезда: {self.star}, Пост: {self.post_rate}, Юзер: {self.user_rate}'

    class Meta:
        verbose_name = 'Рейтинг пользователя к посту'
        verbose_name_plural = 'Рейтинги пользователей к постам'</pre>
					</li>
					<li>
						Зарегистрирую модель Rating в админ панеле
						<br>relatepost/admin.py
						<pre>
from relatepost.models import .., Rating

# Рейтинг в админке (конкретный пользователь, конкретная статья)
class RatingAdmin(admin.ModelAdmin):
    list_display = ('id', 'user_rate', 'post_rate', 'star')
    list_display_links = ('user_rate', 'post_rate')
    search_fields = ('user_rate', 'post_rate')
    list_editable = ('star',)  # запятая - если 1 поле!
    list_filter = ('star',)

admin.site.register(Rating, RatingAdmin)</pre>
					</li>
					<li>
						Необходимо удалить поле rating - в модели Car - его мы не использовали, но он выдал ошибку так как поле рейтинг совпадало с именеи модели Rating, при том что из Rating  -> ForeingKey -> Car
					</li>
					<li>
						Создаю и применяю миграции
						<pre>
python manage.py makemigrations
python manage.py migrate</pre>
					</li>
					<li>
						Создаём форму, для изменения рейтинга
						<br>relatepost/forms.py
						<pre>
# форма изменения и добавления рейтинга к посту
class RatingForm(forms.ModelForm):
    # где empty_label - это чёрточки при выборе(например категорий)
    # RadioSelect - это тыканье на кнопку вместо выпадающего списка (есть чек бокс,
    # queryset - Это все записи, то есть все звёзды 1 2 3 4 5

    # здесь мы переопределяем поле star
    star = forms.ModelChoiceField(
        queryset=RatingStar.objects.all(), widget=forms.RadioSelect(), empty_label=None
    )

    class Meta:
        model = Rating  # связь с моделью юзер-пост-рейтинг
        fields = ('star',)</pre>
					</li>
					<li>
						В blog/views.py - добавляем форму в представление одного поста, в контект
						<br>class ShowCar

						<pre>
from relatepost.forms import RatingForm

# страница отдельной машины
class ShowCar(SuccessMessageMixin, DataMixin, DetailView, FormMixin):
	....
    def get_context_data(self, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)  # распаковываем изначальный контекст

        context['star_form'] = RatingForm()  # добавлеем нашу форму в контекст (ключ star_form: значение=наша форма)

        c_def = self.get_user_context(cat_selected=self.kwargs['cat_slug'])       
        return {**context, **c_def}  # в шаблон передаём полный контекст</pre>
					</li>
					<li>
						В car.html - добавляем форму
						<pre>
&lt;form action="{% url 'add_rating' %}" method="post" name="rating">
	&lt;b>Рейтинг&lt;/b>
	{% csrf_token %}


	&lt;input type="hidden" value="{{ car.id }}" name="car">


	&lt;span class="rating">
		{% for k, v in star_form.fields.star.choices %}
			&lt;input id="rating{{ v }}" type="radio" name="star" value="{{ k }}">
			&lt;label for='rating{{ v }}'>
			&lt;!-- {{ k }} Если поставить k - то будет дубликат непонятно почему!-->
			&lt;/label>
		{% endfor %}
	&lt;/span>
	&lt;span class="editContenr">4.0&lt;/span>
&lt;/form></pre>
					</li>
					<li>
						В blog/static/blog/imeges добавляю 2 изображения, жёлтая и прозрачная звезда
						<pre>
star-off-big.png
star-on-big.png</pre>
					</li>
					<li>
						В blog/static/blog/css/styles.cc - добавляем стили для формы, добавляем стили
						<pre>
/* Чекбоксы ретинга - Звёзды рейтинга */
.rating {
  overflow: hidden;
  vertical-align: bottom;
  display: inline-block;
  width: 155px;
  height: 30px;
}

.rating > input {
  opacity: 0;
  margin-right: -100%;
}

.rating > label {
  position: relative;
  display: block;
  float: right;
  background: url('../images/star-off-big.png');
  background-size: 30px 30px;
}

.rating > label:before {
  display: block;
  opacity: 0;
  content: '';
  width: 30px;
  height: 30px;
  background: url('../images/star-on-big.png');
  background-size: 30px 30px;
  transition: opacity 0.2s linear;
}

.rating > label:hover:before,  .rating > label:hover ~ label:before,  .rating:not(:hover) > :checked ~ label:before { opacity: 1; }
/* //Чекбоксы ретинга - Звёзды рейтинга */</pre>
					</li>
					<li>
						Добавляем JS в наш scripts.js
						<pre>
// Добавление рейтинга к статьям
// 1. в файле scripts.js - в документе, с помощью querySelector - ищем форму rating
const rating = document.querySelector('form[name=rating]');

// 2. когда у формы вызовится событие change
rating.addEventListener("change", function (e) {
    // Получаем данные из формы
    // 3. создавая FormData и передав нашу форму, мы получим значение наших полей
    let data = new FormData(this);
    // 4. с помощью fetch, на url из нашей action={% url %}, передаём пост запросы, в теле body нашу data
    fetch(`${this.action}`, {
        method: 'POST',
        body: data
    })
    // 5. При успешном ответе - Рейтинг установлен, при отрицательном - Ошибка
        .then(response => alert("Рейтинг установлен"))
        .catch(error => alert("Ошибка"))
});</pre>
					</li>
					<li>
						Создадим urls.py в relatepost (app) и внутри него создадим маршрут
						<pre>
from django.urls import path
from .views import *

urlpatterns = [
    path('add-rating/', AddStarRating.as_view(), name='add_rating'),
]</pre>
					</li>
					<li>
						В основной urls.py (avtoblog/urls.py) - включим ранее созданный relatepost/urls.py
						<pre>
urlpatterns = [
    ....('admin/', admin.site.urls),
	.....
    path('', include('relatepost.urls')),  # путь к путям приложения relatepost
]</pre>
					</li>
					<li>
						В relatepost/views.py - добавляем представления ajax
						<pre>
from django.http import HttpResponse
from django.views import View
from relatepost.forms import RatingForm
from relatepost.models import Rating

# Добавление рейтинга к Посту
class AddStarRating(View):
    def post(self, request):
        form = RatingForm(request.POST)
        if form.is_valid():
            Rating.objects.update_or_create(
                user_rate=request.user,
                post_rate_id=int(request.POST.get('car')),
                defaults={'star_id': int(request.POST.get('star'))}
            )
            return HttpResponse(status=201)
        else:
            return HttpResponse(status=400)</pre>
					</li>
					<li>
						Полный блок кода, с рейтингом выглядит так
						<br>car.html (необходимо добавить лайки и комментарии)
						<pre>
&lt;span class="text-secondary">Обновлено: {{ car.time_update }}&lt;/span>
&lt;ul class="list-group">
	&lt;li class="list-group-item list-group-item bg-dark bg-gradient text-white">
		&lt;h3>Автор статьи: {{ car.author }}&lt;/h3>
	&lt;/li>
	&lt;li class="list-group-item list-group-item-secondary">
		&lt;div class="d-flex justify-content-between">
			&lt;div class="pt-2 bd-highlight">
				&lt;b>Общий рейтинг: 4.73&lt;/b>
			&lt;/div>

			&lt;!-- кнопки лайк и закдадка -->
				&lt;div class="p-1 bd-highlight">
				&lt;a class="btn btn-outline-danger btn-xl" href="#">Закладка&lt;/a>
    			&lt;a class="btn btn-outline-danger btn-xl" href="#">Лайк&lt;/a>
			&lt;/div>
		&lt;/div>
	&lt;/li>

	&lt;li class="list-group-item list-group-item-success bg-gradient">

		&lt;!-- форма звёзд -->
	    {% if request.user.is_authenticated %}
			&lt;form action="{% url 'add_rating' %}" method="post" name="rating">
				&lt;b>Оцените статью:&lt;/b>
				{% csrf_token %}
				&lt;!-- скрытое поле -->
				&lt;input type="hidden" value="{{ car.id }}" name="car">
				&lt;span class="rating">
					&lt;!-- in форма.поля.поле стар -->
					{% for k, v in star_form.fields.star.choices %}
						&lt;input id="rating{{ v }}" type="radio" name="star" value="{{ k }}">
						&lt;label for='rating{{ v }}'>
							&lt;!-- {{ k }} Если поставить k - то будет дубликат непонятно почему!-->
						&lt;/label>
					{% endfor %}
				&lt;/span>			
			&lt;/form>
		{% endif %}
	&lt;/li>
&lt;/ul></pre>
				</ol>
			</li>
			<br><br>
			<li>
				<span class="title_text">Делаю лайк к посту</span>
				<ol type="A">
					<li>
						Делаю представление, кнопки лайка
						<br>relatepost/views.py
						<pre>
from relatepost.models import .., LikeMarkPost
from blog.models import Car
from django.shortcuts import redirect
from django.contrib.auth.decorators import login_required


# кнопка лайка
@login_required
def like_post(request, cat_slug, car_slug):
    try:
        like_mark_post_object = LikeMarkPost.objects.get(user_like_mark__pk=request.user.pk,
                                                         post_like_mark__slug=car_slug)
        # то же самое что [if like_mark_post_object.is_like_post == False:]
        if not like_mark_post_object.is_like_post:  # если в реакции ЛАЙК = False
            # !update не работает с get! - работает только c filter!
            # меняем лайн на True
            LikeMarkPost.objects.filter(user_like_mark__pk=request.user.pk,
                                        post_like_mark__slug=car_slug).update(is_like_post=True)

        else:  # если в реакции ЛАЙК = True
            # меняем лайн на False
            LikeMarkPost.objects.filter(user_like_mark__pk=request.user.pk,
                                        post_like_mark__slug=car_slug).update(is_like_post=False)
    except LikeMarkPost.DoesNotExist:  # Реакцию не нашли (объект не существует)
        # создаём новую реакцию
        like_mark_post_object = LikeMarkPost.objects.create(
            user_like_mark=request.user,
            post_like_mark=Car.objects.get(slug=car_slug),
            is_like_post=True,
            is_bookmarks_post=False
        )
        like_mark_post_object.save()
    return redirect('car', cat_slug, car_slug)</pre><br>
    					<strong>
    						Всё достаточно просто и логично!:
    					</strong>
    					<br>1) ищем была ли хоть какаято реакция (лайк или закладка), ищем по конкретному пользователю и конкретному посту
    					<br>- В случае еули реакция была, и лайк не стоит, ставим лайк
    					<br>- В случае еули реакция была, и лайк уже есть, убираем лайк
    					<br>- Если реакций до этого не было - добавляем реакция (делаем новую запись реакции = пользователь, статья, поставил лайк, закладку не ставим)
    					<br>
					</li>
					<li>
						<span class="spec">
							Способ проверки существует ли запись по конкретным катерогиям, если не нужно 404 в случае неудачи:
						</span>
						<br>
						<br>- 1 способ tru: и except.Model.DoesNotExist: (пример выше) 
						<pre>
tru: 
	пробуем получить запись по параметрам
	блок кода если запись есть
except Модель.DoesNotExist: - записи в модели не сушествует
	блок кода если записи нет</pre>
						<br>- 2 способ - метод exists()
						<pre>
a = Model.objects.get(id=15) (a это QuerySet)
if a.exists():  # если запись есть True
	блок кода если запись существует
else:
	блок кода если записи не существует</pre>
					</li>
					<li>
						Делаю маршрут для кнопки лайка
						<br>relatepost/urls.py
						<pre>
path('category/&lt;slug:cat_slug>/&lt;slug:car_slug>/like', like_post, name='like_post'),</pre>
					</li>
					<li>
						Необходима переменная, которая будет<span class="spec"> в шаблоне показывать реакции от конкретного пользователя</span>, (для привильного отображения лайка, для отобрадения закладки статьи)<br>
						Для получения переменной в классе представления добавим свой метод, и добавим переменную в контекст представления.
						<br>переменная будет кверисетом записи, или строкой 'no' - если никаких реакций данный пользователь не делал к данному посту.
						<br>blog/views.py - class ShowCar
						<pre>
# страница отдельной машины
class ShowCar(....):
	....
	....

# получение реакций пользователя к посту
def get_user_relation_to_post(self, **kwargs):
    # пробуем получить реакции (лайк И ИЛИ закладки)
    # по pk пользователя и slag статьи
    relation = LikeMarkPost.objects.filter(user_like_mark__pk=self.request.user.pk,
                                           post_like_mark__slug=self.kwargs['car_slug'])
    # если количество реакций > 0
    if relation.count() > 0:
        return relation  # возвращаем весь QuerySet (запись self.user + self.car)
    else:
        relation = 'no'
        return relation  # возвращаем строку 'no' (для проверки в шаблоне)</pre>
					</li>
					<li>
						Вывод данных в шаблоне. <span class="spec">Указаны сухие данные</span> для понимания как действовать, какие кнопки (активные неактивные указывать), для лайка, для закладки.
						<br><span class="spec">
							Итоговый вариант будет ниже
						</span>
						<br>Сухое представление и проверки реакций пользователя в шаблоне. car.html
						<pre>
&lt;!-- если реакции есть -->
{% if relation != 'no' %}
	{% for r in relation %} &lt;!-- перебираем поля реакций -->
		&lt;h3>Пользователь - {{ r.user_like_mark }}&lt;/h3>
		&lt;h3>Статья - {{ r.post_like_mark }}&lt;/h3>
		&lt;h3>Лайк - {{ r.is_like_post }}&lt;/h3>
		&lt;h3>Закладка - {{ r.is_bookmarks_post }}&lt;/h3>
		&lt;br>
		{% if r.is_like_post == True %} &lt;!-- если лайк стоит -->
			&lt;h3 class="text-info">Лайк есть&lt;/h3>
		{% else %} &lt;!-- если лайк не стоит -->
			&lt;h3 class="text-info">Нет лайка&lt;/h3>
		{% endif %}&lt;!-- если лайк стоит -->
	{% endfor %} &lt;!-- перебираем поля реакций -->

{% else %} &lt;!-- если нет реакций -->	
	&lt;h3 class="text-danger">Нет реакции от пользователя&lt;/h3>
{% endif %} &lt;!-- если реакции есть --></pre>
					</li>
				</ol>
			</li>
			<li>
				<span class="title_text">Поведение кнопки (представление + маршрут), добавить/убрать пост из закладок пользователя</span>
				<ol type="A">
				<br>Предаставление и маршрут будут почти такиеме же как и у лайка, за исключением корректироуемого поля в модели
				<br>Теоретически можно было бы сделать и в одном представлении, но нужнны разные маршруты , а через форму делать не лучшая идея
					<li>
						Пишу представление кнопки добавить и и убрать пост из закладки
						<br>relatepost/views.py
						<pre>
# кнопка закладки
@login_required
def bookmark_post(request, cat_slug, car_slug):
    try:
        like_mark_post_object = LikeMarkPost.objects.get(user_like_mark__pk=request.user.pk,
                                                         post_like_mark__slug=car_slug)
        # то же самое что [if like_mark_post_object.is_bookmarks_post == False:]
        if not like_mark_post_object.is_bookmarks_post:  # если не добавил в закладки
            # добавляем в закладки
            LikeMarkPost.objects.filter(user_like_mark__pk=request.user.pk,
                                        post_like_mark__slug=car_slug).update(is_bookmarks_post=True)

        else:  # если уже в закладках
            # убираем из закладок
            LikeMarkPost.objects.filter(user_like_mark__pk=request.user.pk,
                                        post_like_mark__slug=car_slug).update(is_bookmarks_post=False)
    except LikeMarkPost.DoesNotExist:  # Реакцию не нашли (объект не существует)
        # создаём новую реакцию
        like_mark_post_object = LikeMarkPost.objects.create(
            user_like_mark=request.user,
            post_like_mark=Car.objects.get(slug=car_slug),
            is_like_post=False,
            is_bookmarks_post=True
        )
        like_mark_post_object.save()
    return redirect('car', cat_slug, car_slug)</pre>
					</li>
					<li>
						Пишу маршрут для кнопки закладки
						<br>relatepost/urls.py
						<pre>path('category/&lt;slug:cat_slug>/&lt;slug:car_slug>/bookmark', bookmark_post, name='bookmark_post'),</pre>
					</li>
				</ol>
			</li>
			<li>
				<span class="title_text">
					Отображаю кнопки лайк и закладки, активные/неактивные + ссылки на изменение (кнопка лайк, кнопка закладка)
				</span>
				<ol type="A">
					<li>
						Напоминаю что, ранее в шаблон выводил реакцию для конкретного пользоватея и поста (нет/есть/если да то какие)
						<br>Смотри blog/views.py - class ShowCar - def get_user_relation_to_post и get_context_data
					</li>
					<li>
						Полный блок кода, для кнопок лайк и закладок, с учётом всех возможных вариантов (залогинен/незалогинен - есть реакции от юзера/нет реакций - стоит лайк/не стоит - в закладках/не в закладках)
						<br>car.html
						<pre>
{% if request.user.is_authenticated %} &lt;!-- если залогинен  для лайк, рейтинг, закладки -->	
				
&lt;!-- кнопки лайк и закдадка -->
	&lt;div class="mb-0 bd-highlight">

&lt;!-- если реакции есть -->
{% if relation != 'no' %}
	{% for r in relation %} &lt;!-- перебираем поля реакций -->

	&lt;!-- закладки -->
	{% if r.is_bookmarks_post == True %} &lt;!-- если в закладках -->
	&lt;a class="btn" href="{% url 'bookmark_post' car_slug=car.slug cat_slug=car.cat.slug %}">
		&lt;img src="{% static 'blog/images/bookmark-on.png' %}" height="32" width="32" class="img-fluid">
	&lt;/a>
	{% else %} &lt;!-- если НЕ закладках -->
	&lt;a class="btn" href="{% url 'bookmark_post' car_slug=car.slug cat_slug=car.cat.slug %}">
		&lt;img src="{% static 'blog/images/bookmark-off.png' %}" height="32" width="32" class="img-fluid">
	&lt;/a>
	{% endif %} &lt;!-- если в закладках -->


		&lt;!-- лайк -->
		{% if r.is_like_post == True %} &lt;!-- если лайк стоит -->
		&lt;a class="btn" href="{% url 'like_post' car_slug=car.slug cat_slug=car.cat.slug %}">
		&lt;img src="{% static 'blog/images/heart-on.png' %}" height="32" width="32" class="img-fluid">
	&lt;/a>14!!!
	{% else %} &lt;!-- если лайк не стоит -->
	&lt;a class="btn" href="{% url 'like_post' car_slug=car.slug cat_slug=car.cat.slug %}">
		&lt;img src="{% static 'blog/images/heart-off.png' %}" height="32" width="32" class="img-fluid">
	&lt;/a>15!!!
	{% endif %} &lt;!-- если лайк стоит -->

	{% endfor %} &lt;!-- перебираем поля реакций -->



{% else %} &lt;!-- если реакций от пользователя нет -->
	&lt;!-- неактивная закладка -->
	&lt;a class="btn" href="{% url 'bookmark_post' car_slug=car.slug cat_slug=car.cat.slug %}">
		&lt;img src="{% static 'blog/images/bookmark-off.png' %}" height="32" width="32" class="img-fluid">
	&lt;/a>
	&lt;!-- неактивный лайк -->
	&lt;a class="btn" href="{% url 'like_post' car_slug=car.slug cat_slug=car.cat.slug %}">
		&lt;img src="{% static 'blog/images/heart-off.png' %}" height="32" width="32" class="img-fluid">
	&lt;/a>15!!!

{% endif %} &lt;!-- если реакции есть -->
&lt;/div>	

......
блок кода для рейтинга звёзд
{% endif %} &lt;!-- если залогинен  для лайк, рейтинг, закладки --></pre>
					</li>
				</ol>
			</li>

			<li>
				<span class="title_text">
					Делаю и вывожу в шаблон, счётчик рейтинга и счётчик лайков поста.
				</span>
				<ol type="A">
					<li>
						Добавляю функцию получения рейтинга поста
						<br>blog/views.py - class ShowCar (представление)
						<pre>
class ShowCar(...):
	....
    # получение рейтинга поста
    def get_rating_post(self, **kwargs):
        # получаем все записи рейтинга к конкретному посту
        rating_records = Rating.objects.filter(post_rate__slug=self.kwargs['car_slug'])
        sum_rating = 0  # промежуточная переменная, сумма всех рейтингов
        # если количество записей рейтинга больше 0
        if rating_records.count() > 0:
            # перебираем все записи модели Rating
            for rec in rating_records:
                # к переменной прибавляем рейтинг из каждой записи Rating (конкретного поста)
                # value - потому что поле star не совсем число, и его нужно привести к числу!
                sum_rating += rec.star.value
            # сумма всех рейтингов / количество записей по рейтингу
            rating = sum_rating / rating_records.count()
            # округляем до 2-х чисел после запятой
            rating = round(rating, 2)
        else:  # если к посту рейтинг никто не ставил
            rating = 0
        return rating  # возвращаем итоговый рейтинг!


	....
    def get_context_data(....):
        context = super().get_context_data(**kwargs)  # распаковываем изначальный контекст
        ....
        c_def = self.get_user_context(....,  # выбор категории
                                      ....,  # реакции
                                      rating=self.get_rating_post())  # рейтинг
        ...</pre>
					</li>
					<li>
						Выводим в шаблоне рейтинг, если рейтинг = 0 , будем выводит 'нет оценок'
						<br>car.html
						<pre>
&lt;p style="font-size: 1.2em;">
	Рейтинг: 
	{% if rating > 0 %} &lt;!-- если рейтинг > 0 -->
	{{ rating }}
	{% else %} &lt;!-- если рейтинг 0 -->
	нет оценок
	{% endif %} &lt;!-- если рейтинг > 0 -->
&lt;/p></pre>
					</li>
					<li>
						Добавляю счётчик лайков, в представлении ShowCar  - добавляю свой метод
						<br>blog/views.py - class ShowCar (представление)
						<pre>
class ShowCar(...):
	....
    # получение количества лайков к посту
    def get_total_likes_post(self, **kwargs):
        # получаю все записи реакций (лайк и/или закладки) относящиеся к конкретному посту
        likes_or_marks_records = LikeMarkPost.objects.filter(post_like_mark__slug=self.kwargs['car_slug'])
        total_likes = 0
        # если реакций (количество записей) лайк и/или закладки больше 0
        if likes_or_marks_records.count() > 0:
            # перебираем все записи
            for rec in likes_or_marks_records:
                # упрощено от if rec.is_like_post == True:
                # если в записи в поле лайков стоит True
                if rec.is_like_post:
                    # прибавляем к результату единицу
                    total_likes += 1
        return total_likes  # возвращаем подсчёт лайков


	....
    def get_context_data(....):
        context = super().get_context_data(**kwargs)  # распаковываем изначальный контекст
        ....
        c_def = self.get_user_context(....,  # выбор категории
                                      ....,  # реакции
                                      ....,  # рейтинг
                                      total_likes=self.get_total_likes_post()  # количество лайков
                                      )
            ....</pre>
					</li>
					<li>
						Блок кода в шаблоне, который показывает количество лайков если они есть (если лайко ещё нет ничего показывать не будет)
						<br>car.html - (этот блок необходимо вставить везде где нужно количество лайков, при разных условиях -логин/активный лайк/неактивный лайк)
						<pre>
{% if total_likes > 0 %} &lt;!-- если лайков больше 0 -->
	{{ total_likes }}
{% endif %} &lt;!-- если лайков больше 0 --></pre>
					</li>
				</ol>
			</li>

			<li>
				<span class="spec">
					На данный момент с добавлением, отображением лайков/закладок/рейтинга всё
					<br>В перспективе нужно:
					<br>- Чтобы звёзды рейтинга не пропадали в шаблоне после обновления страницы
					<br>- Чтобы рейтинг обновлялся через ajax (сейчас только после обновления страницы)
					<br>- Лайки/закладки через ajax
					<br><br>Для этого начинай учить JavaScript, jQuery/Vue/React/Angular? + REST
				</span>
			</li>
				</ol><!-- конец по рейтингам лайкам и комментар8им поста -->
			</li> <!-- конец по рейтингам лайкам и комментар8им поста -->
		<hr>
		<br><br>




&lt;





			<li>
				<span class="title_text">Представление вывода избранных статей закладки пользователя</span>
				<hr>
				<ol type="A">
					<li>
						Делаю новое представление, для вывода избранных записей (добавленных в закладки), каждого пользователя
						<br>blog/views.py
						<pre>
# вывод машин избранных статей пользователя
class CarsBookmarksShow(LoginRequiredMixin, DataMixin, ListView):
    login_url = 'login'  # перенаправление если пользователь не авторизован (LoginRequiredMixin)
    model = Car
    template_name = 'blog/home.html'  # тот же шаблон, что и домашняя страницы
    context_object_name = 'cars'  # objects = cars (просто имя)
    # allow_empty = True - покажет пустой список если ничего не будет
    # allow_empty = False - покажет 404, при отсутствии совпадений в get_queryset
    allow_empty = True  # для отображения 404

    # параметры вывода (выводим записи только из, закладок пользователя)
    def get_queryset(self):
        # получаем список всех записей LikeMarkPost ао фильтру (текущий пользователь, есть закладка)
        bookmarks_post_list = LikeMarkPost.objects.filter(user_like_mark__pk=self.request.user.pk,
                                                          is_bookmarks_post=True)
        pk_list_bookmarks_for_user = []  # создал пустой список pk
        # перебираем все записи по вышеуказанной выборке
        for one_rec in bookmarks_post_list:
            # добавляю в наш список, id/pk записей, которые есть в закладки
            pk_list_bookmarks_for_user.append(one_rec.post_like_mark.pk)
        # Вывожу только записи из закладок
        # pk - это Сar.pk,  __in - необходим когда атрибутов одного поля несколько
        # после __in - атрибуты поиска нужно выводить списком
        # пример = Model.objects.filter(цвет__in=['белый','чёрный','синий'])
        return Car.objects.filter(pk__in=pk_list_bookmarks_for_user)

    # полный контекст
    def get_context_data(self, *, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)
        c_def = self.get_user_context(cat_selected='закладки',
                                      title=f'Избранные статьи')
        return {**context, **c_def}</pre>
        				<br>
        				<span class="spec">Что здесь интересного:</span>
        				<ul>
        					<li>
        						LoginRequiredMixin - миксин, который разрешает это предсталение только авторизованным пользователем, <span class="spec">LoginRequiredMixin - должен быть первым в списке наследования классов!</span>
        					</li>
        					<li>
        						login_url = 'login' - Это имя маршрута, name='login', куда будет отправлять представление, если им попытается воспользоваться не авторизованный пользователь
        					</li>
        					<li>
        						template_name = 'blog/home.html'  -  Используем тот же шаблон что и при выводе всех записей
        						<br><span class="spec">Шаблон в итоге поменял на другой, захотел чтобы отображалось по другому</span>
        					</li>
        					<li>
        						allow_empty = True - разрешаем выводить пустой список, если поставить False - выведет 404 при пустом списке
        					</li>
        					<li>
        						<span class="spec">def get_queryset(self): - самое важное здесь</span><br>
        						get_queryset - определят какие именно записи модели Car будут показаны
        						<br>Станадартно при model = Car, выведет Car.objects.all()
        						<ul>
        							<li>
        								bookmarks_post_list - здесь получим записи модели LikeMarkPost, они нам нужны только для получении pk записей где есть закладки у конкретного пользователя, уверен что можно сделать более элегантно, без получения этих записей, но пока не стал мудрить
        							</li>
        							<li>
        								Далее перебираем все выбранные записи LikeMarkPost, и записываем все необходимые pk
        								<br>Напомню LikeMarkPost.post_like_mark --> ForeignKey --> Car
        							</li>
        							<li>
        								<span class="spec">
        									Далее фильтр по нескольким значениям одного поля!  - Модель.objects.filter(цвет__in=['red','blue','black'])
        								</span>
        								<br>return Car.objects.filter(pk__in=pk_list_bookmarks_for_user)
        							</li>
        						</ul>
        					</li>
        					<li>
        						В get_context_data - добавлю cat_selected='закладки'  - для отображения кнопки избранное (активно/неактивно) - в шаблоне в sidebar
        					</li>
        				</ul>
					</li>
					<br><br>
					<li>
						Пишу маршрут для представления избранных пользователем статей (на основе классов)
						<br>blog/urls.py
						<pre>path('bookmarks/', CarsBookmarksShow.as_view(), name="bookmarks"),</pre>
					</li>
					<li>
						Добавлю ссылку 'Мои закладки' в sidebar
						<br>sidebar.html - (блок кода кнопки мои закладки)
						<pre>
{% if request.user.is_authenticated %} &lt;!-- если залогинен -->		
		{% if cat_selected != 'закладки' %} &lt;!-- если не 'закладки' -->
		&lt;li class="nav-item">
		    &lt;a class="nav-link active pb-4" aria-current="page" href="{% url 'bookmarks' %}">Мои закладки&lt;/a>
		&lt;/li>
		{% else %} &lt;!-- если 'закладки' -->
		&lt;li class="nav-item">
		    &lt;a class="nav-link disabled pb-4" href="{% url 'bookmarks' %}" tabindex="-1" aria-disabled="true">Мои закладки&lt;/a>
		&lt;/li>
		{% endif %}	&lt;!-- если не 'закладки' -->
{% endif %} &lt;!-- если залогинен --></pre>
					</li>
					<li>
						Скопирую шаблон home.html, переиминую booksmarks.html, подкорректирую формат отображения списка, буду выводить по 4 в ряд. (изменю параметр для стобцы в контейнере class --> col-xl-3)
					</li>
					<li>
						Соответственно поменяю шаблон в классе представления CarsBookmarksShow
						<br>blog/views.py
						<pre>
# вывод машин избранных статей пользователя
class CarsBookmarksShow(...):
	...							
	template_name = 'blog/bookmarks.html'  # шаблон</pre>
					</li>
					<li>
						Добавлю вывод информации на случай если закладок ещё нет, 'Здесь будут храниться ваши избранные статьи'
						<br>bookmarks.html
						<pre>
&lt;!-- если пользователь не нелал закладки -->
&lt;!-- cars = Queryset Cars.objects.all/get/filter (у нас filter) -->
{% if cars.count == 0 %}
	&lt;p class="no_queryset">
		Здесь будут храниться ваши избранные статьи
	&lt;/p>
	&lt;h4 class="text-center text-info">
		Для добааления в избранное, необходимо перейти на страницу статьи - и добавить её в закладки.
	&lt;/h4>
{% endif %}&lt;!-- если пользователь не нелал закладки -->&lt;/pre>
					</li>
				</ol>
			</li>



&lt;



			<li>
				<span class="spec">
					Добавлюю видео с ютуб (в отдельный шаблон)
				</span>
				<hr>
				<ol type="A">
					<li>
						Создаю шаблон video.html
						<br>blog/templates/blog - video.html
					</li>
					<li>
						Пишу представление, для шаблона с видео
						<br>blog/views.py
						<pre>
# представление шаблона с видео
class VideoTemplateShow(DataMixin, TemplateView):
    template_name = 'blog/video.html'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        c_def = self.get_user_context(title='Видео материалы')
        return {**context, **c_def}</pre>
					</li>
					<li>
						Пишу маршрут для представления шаблона video.html
						<br>blog/urls.py
						<pre>path('video/', VideoTemplateShow.as_view(), name="video"),</pre>
					</li>
					<li>
						<span class="spec">
							Добавление видео с Youtube - html ссылка
						</span>
						<br>-Заходим на Youtube - какое-то видео
						<br>-Поделиться - Встроить
						<br>-Настраиваем в youtube (например можно настроить показ с конкретной секунды)
						<br>-Вставляем в шаблон html ссылку
						<br><br>video.html
						<pre>
{% block content %}

&lt;h1 class="text_shadow">{{ title }}&lt;/h1>
&lt;hr>

&lt;iframe width="560" height="315" src="https://www.youtube.com/embed/03Sb_K6u8l8" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>&lt;/iframe>


{% endblock %}</pre>
					</li>
					<li>
						Подключаем адаптацию bootstrap5 (изменение размера при изменении родительского элемента)
						<br><span class="spec">bootstrap5 .ratio</span>
						<br>Для видео c Ютуб (и большинства видео) - подходит соотношение 16х9
						<br>Всё что необходимо обернуть элемент iframe - в div c классом ratio ratio-16x9
						<pre>
&lt;div class="ratio ratio-16x9">
	&lt;iframe информаци с стороннего сайтиа Youtube>&lt;/iframe>
&lt;/div></pre>
					</li>
					<li>
						Для добавление выдео через модель, можно сделать просто:
						<br>-Создадим модель Video, создадим поля в модели ['title_video', 'link_video']
						<br>-Всё пол стандарту, link_video - можно сделать просто полем CharField/TextFielg
						<br>-В админке в link_video - добавляем полностью ссылку html - со всеми тегами html - от &lt;iframe> до &lt;/iframe> - включительно
						<br>-Далее в шаблоне при выводе видео, необходимо будет экранировать html теги. 
						<span class="spec">Экранирование html в шаблоне: {{ link_video|safe }}</span>
						<br>-<strong>Но этот способ очень кустарный, он подойдёт в том случае, если видео на сайте не планируется много, если видео можно будет добавлять только админу из админ панели</strong>
						<br>-Более павильный метод реализации, через отдельный пакет -например: <span class="spec">django-embed-video</span>
					</li>		
				</ol>
			</li>


&lt;
			
			<li>
				<span class="title_text">
					Делаю полноценное Видео приложение на сайте, с помощью - django-embed-video
				</span>
				<hr>
				<ol type="A">
					<li>
						<span class="spec">Установка - django-embed-video</span>
						<ul>
							<li>
								<a href="https://pypi.org/project/django-embed-video/">https://pypi.org/</a>
								<br>
								<a href="https://django-embed-video.readthedocs.io/en/latest/">Официальная документация</a>
							</li>
							<li>
								Устанавливаю в окружение пакет: django-embed-video
								<pre>pip install django-embed-video</pre>
							</li>
							<li>
								Регистрирую приложение в settings.py - INSTALLED_APPS
								<pre>
INSTALLED_APPS = [
	....,
	...., # изначаньные приложения django								
    'embed_video',  # django-embed-video
    ....,  # наши приложения
]</pre>
							</li>
							<li>
								В settings.py - в TEMPLATES - в OPTIONS - должен быть включен 'django.template.context_processors.request',  - Изначально это условие в django есть
								<br><br>
								<span class="spec">В инструкции написано что необходимо добавить - этого я не делал, должно работать без указанного ниже кода</span>
								<br>скорее всего информация для старой версии django
								<pre>
TEMPLATE_CONTEXT_PROCESSORS = (
    ...
    'django.core.context_processors.request',
)</pre>
							</li>
							<li>
								Так же есть настройка <span class="spec">WSGi + Nginx</span> - То есть при использовании в Продакшене
								<br>В settings.py добавляю
								<pre>SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')</pre>
								<br>В настройках Nginx необходимо добавить
								<pre>proxy_set_header X-Forwarded-Proto $scheme;</pre>
							</li>
							<li>
								Теперь можно использовать видео со стороннего сайта в нашем проекте
								<br>Пример модели:
								<pre>
from django.db import models
from embed_video.fields import EmbedVideoField

class Item(models.Model):
	# поле ссылки на видео
    video = EmbedVideoField()  # такое же как models.URLField()
								</pre>
							</li>
							<li>
								В шаблоне необходимо подгрузить
								<pre>{% load embed_video_tags %}</pre>
							</li>
							<li>
								Пример самого простого вывода видео в шаблоне
								<pre>{% video item.video 'small' %}</pre>
								<br>-где small = 480x360
								<br>-где tiny  = 420x315
								<br>-где medium  = 640x480
							</li>
							<li>
								Можно размер в лоб
								<pre>{% video my_video '800x600' %}</pre>
							</li>
							<li>
								Вывод отдельных элеметнов в шаблоне
								<pre>
{# or use variables (with embedding, too) #}
{% video item.video as my_video %}
    URL: {{ my_video.url }}
    Thumbnail: {{ my_video.thumbnail }}
    Backend: {{ my_video.backend }}
    {% video my_video 'small' %}
{% endvideo %}</pre>
							</li>
							<li>
								Подробней читай в официальной документации - django-embed-video
							</li>
						</ul>
					</li>
					<li>
						Удаляю всё что делал для пробы в видео ранее
					</li>
					<li>
						Создаю новое приложение в проекте 'video'
						<pre>python manage.py startapp video</pre>
					</li>
					<li>
						Регистрирую приложение 'video' в settings.py - INSTALLED_APPS
						<pre>
INSTALLED_APPS = [
	...
    'video.apps.VideoConfig',  # наше приложение video
]</pre>
					</li>
					<li>
						Создам папку для шаблонов в приложении video
						<br>
						<pre>avtoblog-project/video/templates/video</pre>
					</li>
					<li>
						Создам собственный urls.py в video (app), напишу первый маршрут и необходимые импорты
						<br>video/urls.py
						<pre>
from django.urls import path
from .views import *

urlpatterns = [
    # path('list/', VideoTemplateShow.as_view(), name="video"),
]</pre>
					</li>
					<li>
						Включу в video/urls.py в основной avtoblog/urls.py
						<pre>path('video/', include('video.urls')),  # путь к путям приложения video</pre>
					</li>
					<li>
						Сделаю первое представление, для проверки работоспособности приложения:
						<br>-Пермещу video.html - в video/templates/video
						<br>-Напишу первое простейшее представленрие в video/views.py
						<pre>
from django.shortcuts import render
from django.views.generic import TemplateView
from blog.utils import DataMixin


# представление шаблона со списком видео
class VideoListShow(DataMixin, TemplateView):
    template_name = 'video/video.html'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        c_def = self.get_user_context(title='Видео материалы')
        return {**context, **c_def}</pre>
        				<br>-Пишу маршрут для представления
        				<pre>path('list/', VideoListShow.as_view(), name="video_list"),</pre>
        				<br>-Проверяю в браузере, url=http://127.0.0.1:8000/video/list/
        				<br>Всё работает на данном этапе!
					</li>
					<li>
						Добавлю название приложение на руссом "Приложение Видео"
						<br>video/apps.py - class VideoConfig
						<pre>
class VideoConfig(AppConfig):
	...
	verbose_name = 'Приложение Видео'  # отображение названия приложения</pre>
					</li>
					<li>
						Пишу модель для хранения видео (ссылки видео)
						<br>video/models.py
						<pre>
# Сторонние видеофайлы
class VideoYT(models.Model):
    name = models.CharField(max_length=255, verbose_name='Название видео')
    video_url = EmbedVideoField()  # ссылка стороннего видео</pre>
					</li>
					<li>
from django.contrib.auth.models import User
from django.db import models
from embed_video.fields import EmbedVideoField  # django-embed-video


# Сторонние видеофайлы
class VideoYT(models.Model):
    name = models.CharField(max_length=255, verbose_name='Название видео')
    video_url = EmbedVideoField(verbose_name='Ссылка на видео')  # ссылка стороннего видео - django-embed-video
    time_create = models.DateTimeField(auto_now_add=True, verbose_name='Время создания')
    time_update = models.DateTimeField(auto_now=True, verbose_name='Время изменения')
    author_video = models.ForeignKey(User, on_delete=models.SET_DEFAULT, verbose_name='Автор', default=1, blank=False)

    def __str__(self):
        return f'Видео: {self.name}, Автор видео: {self.author_video}'

    class Meta:
        verbose_name = "Видеофайл"
        verbose_name_plural = "Видеофайлы"
        ordering = ['-time_update']</li>
					<li>
						Регистрирую модель VideoYT в админ панеле
						<br>video/admin.py
						<pre>
from django.contrib import admin
from video.models import VideoYT


class VideoYTAdmin(admin.ModelAdmin):
    list_display = ('id', 'name', 'author_video', 'video_url')
    # список полей - ко которым можно вести поиск
    search_fields = ('name', 'author_video')
    # редактирование поля публикации - в списке - в админке
    list_editable = ('name', 'author_video', 'video_url')  # запятая - если 1 поле!
    # фильтр по полям - публикация, время изменения.
    list_filter = ('author_video',)
    
    
# Register your models here.
admin.site.register(VideoYT, VideoYTAdmin)</pre>
					</li>
					<li>
						Создаю и применяю миграцию
						<pre>
python manage.py makemigrations
python manage.py migrate</pre>
					</li>
					<li>
						Через админку создаю записи модели VideoYT
					</li>
					<li>
						Меняю/создаю модель вывода списка видеофайлов
						<br>video/views.py
						<pre>
from django.views.generic import ListView
from blog.utils import DataMixin
from video.models import VideoYT


# представление шаблона со списком видео
class AllVideoListShow(DataMixin, ListView):
    # paginate_by = 8 пагинация на будущее
    model = VideoYT
    template_name = 'video/video.html'
    context_object_name = 'video'  # objects = video (для обращения в шаблоне)

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        c_def = self.get_user_context(title='Видео материалы')
        return {**context, **c_def}</pre>
					</li>
					<li>
						Корректирую маршрут
						<br>video/urls.py
						<pre>path('all/', AllVideoListShow.as_view(), name="video_all"),</pre>
					</li>
					<li>
						Вывожу в шаблоне video.html 
						<pre>
{% extends 'blog/base.html' %} 

&lt;!-- django-embed-video -->
&lt;!-- но и без этого работает(может быть нужно в продакшене) -->
{% load embed_video_tags %}


{% block title %} 
	{{ title }}
{% endblock %}


{% block content %}
&lt;h1 class="text_shadow">{{ title }}</h1>
&lt;hr>

&lt;!-- video = VideoYT.objects.all() -->
{% for v in video %}
&lt;hr>
&lt;h3>Название: {{ v.name }}&lt;/h3>
&lt;h5>Отправитель: {{ v.author_video }}&lt;/h5>
	Ссылка на первоисточник: &lt;a href="{{v.video_url}}">{{v.video_url}}&lt;/a>

&lt;div class="ratio ratio-16x9">
	&lt;iframe src="{{v.video_url}}" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>&lt;/iframe>
&lt;/div>
&lt;hr>
&lt;br>&lt;br>
{% endfor %}

{% endblock %}</pre>
						Вид в самом простом варианте, в последствии размещю по контейнерам (row/col) и зделаю пагинацию, добавлю лайки и комментарии, Добавить себе (по типу закладок) - если это возможно реализовать в цикле видео
					</li>
					<li>
						<span class="spec">
							Проблемы при добавлении видео с YouTube:
						</span>
						<ol>
							<li>
								Не все видео будут показываться с сайта 'Видео не доступно, перейти в Youtube'
							</li>
							<li>
								-При размещениии с YouTube - поделиться - встроить, Youtube даёт html код с сылкой в нутри по типу: src="https://www.youtube.com/embed/aoLVg_RWOFs".  Эти ссылки можно воспроизводить с сайта, если нет ограничения
								<br>-Но если нажать просто поделится ссылка будет в виде: https://youtu.be/aoLVg_RWOFs, а вот данные ссылки youtube запрещает размещать на всех сайтах
								<br><br>Необходимо придумать мутод/функцию которая будет автоматически узменять 'youtu.be' в 'www.youtube.com/embed'
								<br>В модель необходимо добавить метод который будет автоматически изменить ссылку для вставки в ссылку iFrame
							</li>
							<li>
								<span class="spec">Проблемы добавления c RuTube</span>
									<br>
									<br>-Ссылка для пользоавтеля - <strong class="text-info">https://<span class="text-danger">youtu.be</span>/aoLVg_RWOFs</strong>
									<br>-Ссылка для разработчика - <strong class="text-warning">https://<span class="text-danger">www.youtube.com/embed</span>/aoLVg_RWOFs</strong>
							</li>
						</ol>
					</li>
					<li>
						django-embed-video - Django-приложение для легкого встраивания видео с YouTube и Vimeo и музыки из SoundCloud.
						<br><span class="spec">Но по подобному принципу можно добавлять видео и из Rutube VK и тд</span>
						<br>Для этого поле модели VideoYT - video_url - нужно изменить
						<pre>
video_url = EmbedVideoField() 
изменить на
--> models.URLField()</pre>
						Всё остальное по тому же принципу, причём шаблон плеера (iframe) - можно использовать один и тот же, главное это правильная ссылка! внутри src='ссылка'
					</li>
					<li>
						<span class="spec">Проблемы добавления c RuTube</span>
						<br>
						Аналочично как у YouTube:
						<br>-Ссылка для пользоавтеля - <strong class="text-info">https://rutube.ru/<span class="text-danger">video</span>/4fa9c9da04a6803400a73a1b29e3584b/</strong>
						<br>-Ссылка для разработчика - <strong class="text-warning">https://rutube.ru/<span class="text-danger">play/embed</span>/4fa9c9da04a6803400a73a1b29e3584b</strong>
					</li>
					<li>
						<span class="text-danger">Меняем модель из VideoYT в VideoYouTubeRuTube, меняю тип поля video_url</span>
						<br>video/models.py
						<pre>
# Видеофайлы YouTube/Rutube
class <span class="text-danger">VideoYouTubeRuTube</span>(models.Model):
    name = models.CharField(max_length=255, verbose_name='Название видео')
    video_url = <span class="text-danger">models.URLField</span>(verbose_name='Ссылка на видео')  # ссылка стороннего видео - django-embed-video
    time_create = models.DateTimeField(auto_now_add=True, verbose_name='Время создания')
    time_update = models.DateTimeField(auto_now=True, verbose_name='Время изменения')
    author_video = models.ForeignKey(User, on_delete=models.SET_DEFAULT, verbose_name='Автор', default=1, blank=False)

    def __str__(self):
        return f'Видео: {self.name}, Автор видео: {self.author_video}'

    class Meta:
        verbose_name = "Видеофайл c YouTube/RuTube"
        verbose_name_plural = "Видеофайл c YouTube/RuTube"
        ordering = ['-time_update']</pre>
					</li>
					<li>
						Корректирую представление/и админ модель (название модели)
						<br>video/views.py
						<pre>
from video.models import <span class="text-danger">VideoYouTubeRuTube</span>

# представление шаблона со списком видео
class AllVideoListShow(DataMixin, ListView):
    # paginate_by = 8 пагинация на будущее
    model = <span class="text-danger">VideoYouTubeRuTube</span>
    template_name = 'video/video.html'
    context_object_name = 'video'  # objects = video (для обращения в шаблоне)

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        c_def = self.get_user_context(title='Все видео')
        return {**context, **c_def}							
						</pre>
						<br>video/admin.py
						<pre>
from django.contrib import admin
from video.models import <span class="text-danger">VideoYouTubeRuTube</span>


class <span class="text-danger">VideoYouTubeRuTubeAdmin</span>(admin.ModelAdmin):
    list_display = ('id', 'name', 'author_video', 'video_url')
    # список полей - ко которым можно вести поиск
    search_fields = ('name', 'author_video')
    # редактирование поля публикации - в списке - в админке
    list_editable = ('name', 'author_video', 'video_url')  # запятая - если 1 поле!
    # фильтр по полям - публикация, время изменения.
    list_filter = ('author_video',)


# Register your models here.
admin.site.register(<span class="text-danger">VideoYouTubeRuTube</span>, <span class="text-danger">VideoYouTubeRuTubeAdmin</span>)</pre>

					</li>
					<li>
						Делаю и приминяю миграции
						<pre>
python manage.py makemigrations
python manage.py migrate</pre>
					</li>
					<li>
						<span class="spec">Добавляю метод в модель - для корректирования пользовательской ссылки в ссылку для разработчика. Для YouTube и Rutube</span>
						<br>video/models.py - class VideoYouTubeRuTube
						<pre>
# Видеофайлы YouTube/Rutube
class VideoYouTubeRuTube(models.Model):
	....
    # метод будет автоматически конвертировать ссылку, для возможности отображения у себя на сайте
    # Это политика YouTube/RuTube
    # по сути берём ссылку пользователя, и конвертируем в ссылку для разработчика!
    def safe_url(self):
        url = str(self.video_url)  # получаю обычный url
        if 'youtu.be' in url:
            final_url = url[:8] + 'www.youtube.com/embed' + url[16:]
        elif 'rutube.ru/video' in url:
            final_url = url[:18] + 'play/embed' + url[23:]
        else:
            final_url = url
        return final_url</pre>
        				<br>Для отображения метода в шаблоне - {{ запись_модели.safe_url }}
        				<br>То есть к методу обращаемся точно так же как к любому другому полю модели!
					</li>
					<li>
						Подкорректирую Шаблон video.html
						<pre>
{% block content %}
&lt;h1 class="text_shadow">{{ title }}&lt;/h1>



&lt;div class="container-fluid">
	&lt;div class="row">

		&lt;!-- video = VideoYouTubeRuTube.objects.all() -->
		{% for v in video %}
		&lt;div class="col-xl-6 pt-5 ps-5 pe-5">

			&lt;hr>
			&lt;h3>{{ v.name }}&lt;/h3>

				Ссылка на первоисточник:&lt;br> &lt;a href="{{v.video_url}}">{{v.video_url}}&lt;/a>

			&lt;div class="ratio ratio-16x9">
				&lt;!-- {{ v.safe_url }} - Это метод модели! получение ссылки разработчика -->
				&lt;iframe src="{{ v.safe_url }}" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen>&lt;/iframe>
			&lt;/div>
			&lt;h5>Отправитель: {{ v.author_video }}&lt;/h5>
			&lt;br>
			&lt;hr>
		&lt;/div>
		{% endfor %}
	&lt;/div>&lt;!-- row -->
&lt;/div>&lt;!-- container -->


{% endblock %}</pre>
					</li>
				</ol>
			</li>

&lt;
			
			<li>
				<span class="title_text">
					Разделю сайт на отдельные два глобальных приложения (блог и видеоблог)
				</span>
				<br>Для каждого сайта будут свои sidebar
				<ol type="A">
					<li>
						Для того что бы соблюсти принцип деления кода, проще всего в приложении video - иметь свой base.html (изменю только sidebar), и свой side bar
						<br>Итого из blog/templates/blog - копирую в video/templates/video 
						<br>base.html + sidebar.html
					</li>
					<li>
						<br>перименовываю video_base.html
						<br>перименовываю video_sidebar.html
					</li>
					<li>
						video_base.html изменю
						<pre>{% include 'video/video_sidebar.html' %}</pre>
						<span class="spec">navbar, footer - буду брать из blog!</span>
						<br>То есть остальное в video_base.html - без изменений!
					</li>
					<li>
						Подкорректирую video_sidebar.html, она будет показывать:
						<br>-Все видео
						<br>-Моё видео
						<br>-Добавленные видео
						<br>-(возможно) категории видео
						<br>-(возможно) видео по фильтру пользователей
					</li>
					<li>
						В video.html изменю
						<pre>{% extends 'video/video_base.html' %}</pre>
					</li>
					<li>
						video.html переименую в video_all.html
						<br>Сделаю изменения во video/views.py
						<pre>
class AllVideoListShow(DataMixin, ListView):
	...
	template_name = 'video/video_all.html'</pre>
					</li>
					<li>
						Добавить статью уберу из navbar - в blog/sidebar.html, отобдажаться будет всегде (защита от незарегистрированного есть в самой ссылке)
						<pre>
&lt;li class="nav-item">
    &lt;a class="nav-link active text-warning pb-2" aria-current="page" href="{% url 'add_post' %}">Добавить пост&lt;/a>
&lt;/li></pre>

					</li>
					<li>
						home.html переименовываю в allpost.html
					</li>
					<li>
						Изменю маршруты для blog-а,  127/blog/categoryes/.../...
						<br>Основной urls.py avtoblog/ursl.py - изменю маршрут к блогу
						<pre>
path('blog/', include('blog.urls')),  # путь к путям приложения blog</pre>
					</li>
					<li>
						index.html - которая будет являться главной страницей всего приложения, в ней будут показаны прейти перейти в блог, перейти в видеоблог, зарегистрируйся и тд
						<br>
						не буду расширятся от base.html - так как не нужен никакакой sidebar, не хочется менять структуру base.html - очень много переписывать придётся, будут баги.<br>
						<strong>Так лучше не делать, если бы я знал что буду добавлять видеоблог и ещё что то то структура base.html была бы другой изначально</strong>
						<br>
						За основу возьму base.html прямым текстом, добавлю bootstrap, css и всё, так же напрямую расширюсь от navbar и bootstrap
						<br>Вместо sidebar и block content - напиру вручную html - где будут
						<br>Ссылки на регистрацию или авторизацию
						<br>Ссылки и описания блога
						<br>Ссылки и описание видеоблога
						<br>Никаких моделей для index.html добавлять не буду, тупо сухой html + css + bootstrap  - (за исключением {% include 'blog/navbar.html' %} / {% include 'blog/footer.html' %} )
					</li>
					<li>
						В blog.html напишу самую простую функцию представления шаблона index.html
						<pre>
# http://127.0.0.1:8000
def show_index(request):
    return render(request, 'blog/index.html', {'title': 'Вход на сайт'})</pre>
					</li>
					<li>
						В главнов urls.py напишу маршрут, для первой странички
						<br>avtoblog/urls.py
						<pre>path('', show_index, name='index'),</pre>
					</li>
					<li>
						Добавлю ссылки в navbar на приложения blog и video (name='home' и  name="video_all")
						<br>blog/navbar.html (этот navbar общий для всех)
						<pre>
&lt;li class="nav-item mx-3">
    &lt;a class="nav-link active" href="{% url 'home' %}"> Блог &lt;/a>
&lt;/li>
&lt;li class="nav-item mx-3">
    &lt;a class="nav-link active" href="{% url 'video_all' %}"> Видеоблог &lt;/a>
&lt;/li></pre>
					</li>
					<li>
						Полный index.htm
						<pre>
{% load static %}
&lt;!DOCTYPE html>
&lt;html>
&lt;head>
	&lt;meta charset="utf-8">
	&lt;meta name="viewport" content="width=device-width, initial-scale=1">

	&lt;!-- ссыылка BOOTSTRAP CSS -->
	&lt;link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-rbsA2VBKQhggwzxH7pPCaAqO46MgnOM80zW1RWuH61DGLwZJEdK2Kadq2F9CUG65" crossorigin="anonymous">

	&lt;!-- ссыылка к нашему css файлу -->
    &lt;link rel="stylesheet" type="text/css" href="{% static 'blog/css/styles.css' %}">

    &lt;!-- загружаем иконку для отоброжения в браузере где titte-->
    &lt;link rel="shortcut icon" href="{% static 'blog/images/title.png' %}" type="image/x-icon"/>


    &lt;!-- Иконки для лайков -->
    &lt;link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Rounded:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />
    &lt;!-- Иконки для лайков нажатые -->
    &lt;link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@20..48,100..700,0..1,-50..200" />

	&lt;title>{{ title }}&lt;/title>
&lt;/head>
&lt;body>

	{% include 'blog/navbar.html' %}

	&lt;div class="container-fluid bg-gradient content-all">


		&lt;div class="row p-5">
			&lt;div class="col-lg-12">
{% if not request.user.is_authenticated %} <!-- если пользователь НЕАВТОРИЗОВАН -->
				&lt;p style="font-size: 1.5em">
					Для максимального удобства и получения и достпупа к полному функционалу сайта, рекомендуем войти в свой аккаунт или зарегистрироваться если у вас ещё нет аккаунта.
				&lt;/p>

				&lt;div class="text-center">
					&lt;a href="{% url 'login' %}" class="btn btn-outline-info btn-lg">
						Войти
					&lt;/a>
					&lt;a href="{% url 'register' %}" class="btn btn-outline-warning btn-lg">
						Регистрация
					&lt;/a>
				&lt;/div>
{% else %} &lt;!-- если пользователь авторизован -->	
				&lt;h3 class="text_desc text-center">Добро пожаловать, {{ request.user.username }}!&lt;/h3>
{% endif %} &lt;!-- если пользователь НЕАВТОРИЗОВАН -->		
			&lt;/div> <!-- col -->
		&lt;/div> <!-- row -->


		&lt;div class="row">
			&lt;div class="col-lg-6 p-5">
				&lt;a href="{% url 'home' %}" class="nav-link active">
					&lt;h3 class="text_desc text-center">Блог&lt;/h3>				
					&lt;img src="{% static 'blog/images/blog.png' %}" class="img-fluid rounded">
				&lt;/a>						
			&lt;/div> <!-- col -->
			&lt;div class="col-lg-6 p-5">
				&lt;a href="{% url 'video_all' %}" class="nav-link active">
					&lt;h3 class="text_desc text-center">Видеоблог&lt;/h3>
					&lt;img src="{% static 'blog/images/video.png' %}" class="img-fluid rounded">
				&lt;/a>								
			&lt;/div> <!-- col -->
		&lt;/div> <!-- row -->
	&lt;/div> <!-- container -->

	{% include 'blog/footer.html' %}

&lt;!-- JS Bootstrap 5 -->
&lt;script src="https://cdn.jsdelivr.net/npm/@popperjs/core@2.11.6/dist/umd/popper.min.js" integrity="sha384-oBqDVmMz9ATKxIep9tiCxS/Z9fNfEXiDAYTujMAeBAsjFuCZSmKbSSUnQlmh/jp3" crossorigin="anonymous">&lt;/script>
&lt;script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.min.js" integrity="sha384-cuYeSxntonz0PPNlHhBs68uyIAVpIIOZZ5JqeqvYYIcEL727kskC66kF92t6Xl2V" crossorigin="anonymous">&lt;/script>

&lt;/body>
&lt;/html></pre>
					</li>
					<li>
						Дальше можно расщирять эти два отдельных приложения независимо друк от друга.
						<br><strong>Особое внимание на base.html sidebar.html - они в приложениях разные!</strong>
					</li>
				</ol>
			</li>

&lt;
			
			<li>
				<span class="title_text">
					Делаю комментарии для видео.
				</span>
				<hr>
				<span class="spec">
					Форма комментария будет отображаться к каждому видео, на странице списка всех видео! Т.е ListView.  10 видео = 10 форм для комментария = 10 кнопок отправить комментарий!
					<br>Реализация с помошью собственного тега. inclusion_tag(), Вложенный тег - то есть тег шаблон.
				</span>
				<ol type="A">
					<li>
						Создаю модель для комментариев 
						<br> video/models.py
						<pre>
# Комментарии для видео
class CommentVideoYtRt(models.Model):
    video = models.ForeignKey(VideoYouTubeRuTube, on_delete=models.CASCADE, verbose_name='Видео',
                              blank=True, null=True, related_name='comment_video')
    author_comment = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='Автор комментария',
                                       blank=True, null=True)
    time_create = models.DateTimeField(auto_now_add=True, verbose_name='Время создания комментария')
    text_comment = models.TextField(verbose_name='Текст комментария')
    # видно/не видно
    status_comment = models.BooleanField(verbose_name='Видимость комментария', default=True)

    class Meta:
        verbose_name = 'Комментарий к видео'
        verbose_name_plural = 'Комментарии к видео'
        ordering = ['time_create']  # сортировка по дате

    # отображение записи при обращении
    def __str__(self):
        return f'Видео: {self.video}, ' \
               f'Комментатор: {self.author_comment}'</pre>
					</li>
					<li>
						Регистрирую модель в админке
						<br>video/admin.py
						<pre>
from video.models import .., CommentVideoYtRt

# модель комментариев к видео (в админке)
class CommentVideoYtRtAdmin(admin.ModelAdmin):
    list_display = ('pk', 'video', 'author_comment', 'text_comment', 'status_comment')

admin.site.register(CommentVideoYtRt, CommentVideoYtRtAdmin)</pre>
					</li>
					<li>
						Создаю и применяю миграции
						<pre>
python manage.py makemigrations
python manage.py migrate</pre>
					</li>
					<li>
						создаю форму создания комментария
						<br>video/forms.py
						<pre>
from video.models import CommentVideoYtRt


# форма создания комментария к видео
class CommentVideoYtRtForm(forms.ModelForm):
    class Meta:
        model = CommentVideoYtRt
        # поля отображаемые в форме
        fields = ['text_comment']
        # widgets = атрибуты в html, rows = строк в форме, form-control = bootstrap5 class
        widgets = {
            'text_comment': forms.Textarea(attrs={'rows': 1, 'class': 'form-control'}),
        }</pre>
					</li>
					<li>
						<span class="spec">
							Делаю и регистрирую файл для своих теггов!
						</span>
						<ul>
							<li>
								В папке приложения видео создаю папку пакет (с __init__.py внутри) - Python Package
							</li>
							<li>
								avtoblog-project/video --> templatetags (Python Package)
							</li>
							<li>
								В templatetags - создаю файл, в котором буду писать свои тегги
								<br>video/templatetags --> video_tags.py
							</li>
							<li>
								В video_tags.py - регистрирую файл для теггов video_tags.py в библиотеке
								<br>video/templatetags/video_tags.py
								<pre>
from django import template

# регистрируем этот файл в библиотеке
register = template.Library()</pre>
								<strong>Теперь можно создавать свои теги в этом файле!</strong>
							</li>
						</ul>
					</li>
					<li>
						<span class="spec">Делаю вложенный тег inclusion_tag, то есть шаблон, который буду выводить в цикле всех видео, то есть 10 видео = 10 тегов, шаблоны в шаблоне!<br>В самом теге будет форма добавления комментария, будет список комментариев для определенного видео!</span>
						<br>video/templatetags/video_tags.py (полный файл)
						<pre>
from django import template
from django.contrib import messages
from django.shortcuts import redirect
from video.forms import CommentVideoYtRtForm
from video.models import VideoYouTubeRuTube, CommentVideoYtRt

# регистрируем этот файл в библиотеке
register = template.Library()


# тег получение формы комментария + самих комментариев для каждого видео (в списке видео)
@register.inclusion_tag('video/comments_and_comment_form_self_video.html')  # в скобках шаблон тега
# pk_video - (необходимо будет указывать в шаблоне, при вызове тега, думаю в цикле)
# pk_video в шаблоне равно pk_video=v.pk (VideoYouTubeRuTube.objects.get(pk=pk_video).pk)
def show_comments_and_form_comment_self_video(request, pk_video=None):
    # получаем одну запись видео, по параметру pk
    video_obj = VideoYouTubeRuTube.objects.get(pk=pk_video)

    # стандартная обработка формы
    if request.method == 'POST':
        form = CommentVideoYtRtForm(request.POST)
        if form.is_valid():
            # comment_for_self_video по сути одна запись комментария, назвать как угодно.
            # comment_for_self_video - название нигде не фигурирует, кроме этого метода
            comment_for_self_video = form.save(commit=False)  # commit=False, чтобы вписать автора и видео в модель комментария
            comment_for_self_video.author_comment = request.user  # вписываем автора в CommentVideoYtRt.author_comment
            comment_for_self_video.video = video_obj  # вписываем видео в CommentVideoYtRt.video
            comment_for_self_video.save()  # после проверки валидности сохраняем запись комментария
            # всплывающее окно при успешном создании коммента (отображу сверху страницы)
            messages.info(request, f'{request.user.username}! Комментарий к видео: "{video_obj.name}" - создан!')
            # при успешной отправке перенаправит на все видео, т.е останемся на той же странице
            return redirect('video_all')
    else:  # если ещё ничего не отправляли из формы
        form = CommentVideoYtRtForm()  # изначально просто пустая форма

    # получение всех комментариев к конкретному видео!
    all_comments_for_video = CommentVideoYtRt.objects.filter(video__pk=video_obj.pk)
    # то что необходимо передать в шаблон
    context = {
               'form': form,  # форма для отправки комментария
               'all_comments_for_video': all_comments_for_video,  # все комментарии к видео (модель комментарии к видео)
               'video_obj': video_obj,  # одна запись модели Видео
               # 'pk_video': pk_video,
               }
    return context  # передаём контекст, обрати внимание здесь без render, без request и без шаблона</pre>
    					<span class="spec">
    						Что здесь важно (почти всё!):
    					</span>
    						<br><span class="text-danger">-@register.inclusion_tag('шаблон с содержимым тега')</span>
    						<br><span class="text-danger">-(request, pk_video=None)</span> 1) параметр реквест 2) параметр id - видео,  эти параметры необходимо указать в том шаблоне, в котором будем вызывать этот шаблон
    						<br>-video_obj = VideoYouTubeRuTube.objects.get(pk=pk_video) - это экземпляр модели видео
    						<br>-form = CommentVideoYtRtForm(request.POST) - это форма из video/forms.py  - форма создания комментариясписка всех видео
    						<br>- messages.info .. - вспылвающее собщение при успешном отработки формы (добавление комментария)
    						<br>- return redirect('video_all') - при обработке формы перенаправит на страницу 
    						<br>-all_comments_for_video = CommentVideoYtRt.objects.filter(video__pk=video_obj.pk) - <span class="text-danger">получение всех комментариев к конкретному видео!</span>
    						<br>-context - создал словарь со всеми объектами которые нужно передать в шаблон этого тега
    						<br>-<span class="text-danger">return context</span> - передаём контекст, обрати внимание здесь без render, без request и без шаблона
					</li>
					<li>
						<span class="spec">
							Для отработки формы создания комментария (нажатие кнопки добавить комментарий) - необходим маршрут!
						</span>
						<br>
						По этому маршруту будет отправлятся и записываться информация в бд в модель комментариев к видео
						<br>video/urls.py
						<pre>
# путь на добавление комментария, для запуска функции, в нашем случае тега show_comments_and_form_comment_self_video
path('add-comment/&lt;int:pk_video>/', show_comments_and_form_comment_self_video, name='add_comment')</pre>	
						<span class="spec">
							Обрати внимание что &lt;int:pk_video> - это динамическая переменная
						</span>
						<br>http://127.0.0.1:8000/add-comment/ид отдельного видео/
					</li>
					<li>
						<span class="spec">
							Вызываю наш тег в шаблоне video_all.html
						</span>
						<pre>
&lt;!-- вызов файла с собстенными тегами -->
{% load video_tags %} <span class="spec">Обязательно, при использовании своих шаблонов</span>		
&lt;!-- video = VideoYouTubeRuTube.objects.all() -->
{% for v in video %}  # перебираем все видео
	{{ v.name }}  # имя видео
	{{ v.author_video }}  # отправитель видео
	.....  # любые другие поля модели Видео
	&lt;!-- вызываем вложенный тег = show_comments_and_form_comment_self_video -->
	&lt;!-- request - обязательный первый параметр вложенного тега -->
	&lt;!-- v.pk - второй параметр тега, т.е делаем из pk_video=None -> в pk_video=v.pk -->
	{% show_comments_and_form_comment_self_video request v.pk %}

{% endfor %}</pre>
						<span class="spec">
							Что здесь важно!:
						</span>
							<br>-{% show_comments_and_form_comment_self_video <span class="text-danger">request</span> <span class="text-info">v.pk</span> %} - вызываем наш тег! и передаём 2 параметра (request, pk_video=None)
							<br>-<span class="text-danger">request</span> - первый пареметр
							<br>-<span class="text-info">v.pk - это второй параметр pk_video=v.pk</span>
							<br>-То есть в каждой итерации цикла, (каждой записи модели Video) - будет вкладываться наш шаблон, для каждого видео будет своя форма добавления комментария, своя кнопка для создани комментария, и список уже имеющихся комментариев
						
					</li>
					<li>
						В video/templates/video - создаю шаблон (сам тег comments_and_comment_form_self_video.html)
					</li>
					<li>
						<span class="spec">
							Пишу шаблон - вложенный тег
						</span>
						<br>comments_and_comment_form_self_video.html
						<pre>
<div class="text-danger">						
&lt;!-- Вывод списка комментариев, относящихся к каждому видео --></div>
&lt;h5 class="text-warning">
	Все комментарии к видео:&lt;br>
	&lt;!-- перебор всех комментариев к конкретному видео -->
	{% for com in all_comments_for_video %}
		{{ com.author_comment }}: &lt;br>
		{{ com.text_comment}}
		&lt;br>&lt;br>
	{% endfor %}
&lt;/h5>



	&lt;!-- Гипер важно, в action - url = 127/add-comment/&lt;int:pk_video>/ - этой страницы даже не существует, но путь нужен для того чтобы выполнить функцию, в нашем случае функция это вложенный тег! - show_form_comment_video -->
	&lt;!-- pk_video в action - взято имено из urls.py, там оно взято из вложенного тега -->
	&lt;!-- video_obj - это одна запись конкретного видео -->
	&lt;!-- video_obj = VideoYouTubeRuTube.objects.get(pk=pk_video) -->
	&lt;!-- video_obj.pk - id записи видео -->
	&lt;!-- video_obj.name - имя записи видео -->
	&lt;!-- id="{{ video_obj.name }}" = &lt;button form="{{ video_obj.name }}" здесь условие обязательное, это отношение конкретной кнопки к конкретной форме, а у нас на странице video_all - много кнопок и много форм! -->
<div class="text-danger">
&lt;!-- форма для создания комментария к каждому видео --></div>
&lt;form action="{%  url 'add_comment' pk_video=video_obj.pk %}" method="post" id="{{ video_obj.name }}">
{% csrf_token %}
	&lt;div class="col-12" >{{ form.as_p }}&lt;/div>
&lt;/form>

&lt;!-- кнопка для создания комментария к каждому видео -->
&lt;button form="{{ video_obj.name }}" type="submit" class="btn btn-outline-info btn-md">
	Добавить комментарий
&lt;/button>
&lt;br>
&lt;br></pre>
						<span class="spec">
							Что здесь важно:
						</span>
						<br>-video_obj - это одна запись конкретного видео - передавали в контектсте вложенного тега
						<br>-all_comments_for_video - QuerySet - все записис с комментариями к конкретному видео, так же передавали в контексте вложенного тега
						<br><span class="text-danger">- Важно присвоить id к форме и присвоить ворму кнопке</span> Так как форм и кнопок на странице множество. Здесь id формы будет равно имени видео.  То есть у каждого видео собственная форма и кнопка с id формы = имени этого видео
						<br><span class="text-danger">-action='путь для работы формы'</span> путь не совпадает с путём где форма отображается, путь разный для каждый формы, сздесь путь равен 127/add-comment/&lt;int:pk_video>/<br>То есть для каждого видео будет свой путь на обработку своей формы, динамический параметр pk видео
					</li>
					<li>
						<span class="spec">
							Добавляю сворачиваемый контент (сворачивать/разворачивать комментарии к определённому видео)
						</span>
						<br>video/comments_and_comment_form_self_video.html
						<pre>
&lt;!-- если у видео есть комментарии -->
{% if all_comments_for_video.all.count > 0 %}

&lt;!-- логика и кнопка разворачивания списка комментариев -->

  &lt;button class="btn btn-outline-dark ps" type="button" data-bs-toggle="collapse" data-bs-target="#collapse{{ video_obj.pk }}" aria-expanded="false" aria-controls="collapse{{ video_obj.pk }}">
    Посмотреть комментарии
  &lt;/button>

&lt;!-- сворачиваемое содержимое bootstrap -->
&lt;div class="collapse" id="collapse{{ video_obj.pk }}">

	&lt;!-- Вывод списка комментариев, относящихся к каждому видео -->
	&lt;p style="font-size: 1.2em">Все комментарии к видео:</p>
	&lt;!-- перебор всех комментариев к конкретному видео -->
	{% for com in all_comments_for_video %}
	&lt;ul class="list-group">
		
		&lt;li class="list-group-item list-group-item-dark"> 
			&lt;div class="d-flex justify-content-between"> &lt;!-- внешний флекс -->
				&lt;div class="bd-highlight">&lt;!-- автор к -->
					{{ com.author_comment }}:
				&lt;/div>&lt;!-- автор к -->

				&lt;!-- дата | лайк -->
				&lt;div class="bd-highlight text-secondary">
					&lt;div class="d-flex flex-row bd-highlight">
						&lt;div class="pe-2 bd-highlight">&lt;!-- дата -->
						{{ com.time_create |date:'d.m.Y H:i' }}
						&lt;/div>&lt;!-- дата -->

						&lt;div class="ps-2 bd-highlight">&lt;!-- лайк -->
							Лайк
						&lt;/div>&lt;!-- лайк -->
					&lt;/div>
				&lt;/div>
			&lt;/div><!-- внешний флекс -->
		&lt;/li>
		&lt;li class="list-group-item list-group-item-light">{{ com.text_comment}}&lt;/li>
	&lt;/ul>
	&lt;br>
	{% endfor %}&lt;!-- переблр комментариев к видео -->
&lt;/div>

{% endif %}&lt;!-- если у видео есть комментарии --></pre>
						<br><span class="spec">Сворачиваемый контент - кратко</span>
						<pre>
<!-- логика и кнопка разворачивания списка комментариев -->							
&lt;button class="btn btn-outline-dark ps" type="button" data-bs-toggle="collapse" 
data-bs-target="<span class="text-danger">#collapse{{ video_obj.pk }}</span>" aria-expanded="false" 
aria-controls="<span class="text-danger">collapse{{ video_obj.pk }}</span>">
Посмотреть комментарии
&lt;/button>

&lt;!-- сворачиваемое содержимое bootstrap -->
&lt;div class="collapse" id="<span class="text-danger">collapse{{ video_obj.pk }}</span>">
	Контент который можно развернуть
&lt;/div></pre>
						<span class="spec">
							Логика такая же как и для связи кнопка-форма, для каждой кнопки разворачивания и его контента - должен быть свой id
						</span>
					</li>
					<li>
						Добавлю проверку аутентификации пользователя
						<br>
						<span class="spec">
							По дефолту в шаблон тега request не передаётся!
						</span>
						<br>1) В video/templatetads/video_tags.py - в контекст добавляю request!
						<pre>
@register.inclusion_tag('video/comments_and_comment_form_self_video.html')						def show_comments_and_form_comment_self_video(request, pk_video=None):
	....
	....	
    context = {
               ....,  # форма для отправки комментария
               ....,  # все комментарии к видео (модель комментарии к видео)
               ....,  # одна запись модели Видео
               'request': request,  # для того чтобы можно было сделать проверку аутентификации
               }</pre>
               			<br>2) В шаблоне тега  - video/comments_and_comment_form_self_video.html
               			<pre>
{% if request.user.is_authenticated %} &lt;!-- авторизован ли? -для добавление коммментария -->
	Форма и кнопка для добавления комментария
	(есть подробно выше)
{% else %} &lt;!-- НЕ авторизован -для добавление коммментария -->

&lt;p style="font-size: 1.2em" class="text-info">
	Авторизуйтесь чтобы добавить комментарий.
&lt;/p>

{% endif %} &lt;!-- авторизован ли? -для добавление коммментария --></pre>
					</li>
				</ol>
			</li>

&lt;		



			<li>
				<span class="title_text">
					Делаю лакйки и добавить к себе(закладки) - для видео
				</span>
				<hr>
				<span class="spec">
					Особенность в том что они будут в цикле - ListView, скорее всего это будет вложенный тег, скорее всего в том же тегге что и комментарии к видео
				</span>
				<ol class="A">
					<li>
						Пишу модель для лайков и закладок видел
						<br>video.models.py
						<pre>
# лайки + закладки к видео
class LikeMarkVideo(models.Model):
    """ Модель лайк + закладки для видео. 
    Поля:
    1)пользователь, совершающий действия; 2)видео над которым совершают действие;
    3)лайк = нет/да; 4)В закладках у пользователя = нет/да."""
    user_lm_video = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='Пользователь')
    video_lm = models.ForeignKey(VideoYouTubeRuTube, on_delete=models.CASCADE, verbose_name='Видел',
                                 related_name='video_to_lmv')
    is_like_video = models.BooleanField(default=False, verbose_name='Лайк видео')
    is_bookmarks_video = models.BooleanField(default=False, verbose_name='Видео в закладки')

    class Meta:
        verbose_name = 'Лайк/Закладка видео'
        verbose_name_plural = 'Лайки/закладки к видео'

    def __str__(self):
        return f'Пользователь: {self.user_lm_video}, Видео: {self.video_lm}'</pre>
					</li>
					<li>
						Регистрирую модель в админке
						<br>video/admin.py
						<pre>
from video.models import ..., ..., LikeMarkVideo

# модель лайков и закладок к видео (в админке)
class LikeMarkVideoAdmin(admin.ModelAdmin):
    # отображаемые поля в таблице админки
    list_display = ('user_lm_video', 'video_lm', 'is_like_video', 'is_bookmarks_video')
    # поля по которым можно вести поиск
    search_fields = ('user_lm_video', 'video_lm')
    # редактирование в таблице всех реакций (не заходя в конкретную запись)
    list_editable = ('is_like_video', 'is_bookmarks_video')
    # фильтр по полям
    list_filter = ('user_lm_video', 'video_lm')

admin.site.register(LikeMarkVideo, LikeMarkVideoAdmin)</pre>
					</li>
					<li>
						Создам и применю миграцию
						<pre>
python manage.py makemigrations
python manage.py migrate</pre>
					</li>
					<li>
						
						<span class="spec">
							Вывожу информацию о лайках и закладках в пользовательский  вложенный тег.
						</span>
						<ul>
							<li>
								Через админ панель, добавлю пару реакций, пользователь-видео = лайк/закладка
							</li>
							<li>
								В video/templatetags/video_tags.py - пишу отдельную функцию  получения реакции
								<pre>
# реакция(лайк, закладка) пользователя на конкретное видео (нет или запись самой реакции)
def get_likemarks_to_video(request, pk_video):
    # пробуем получить реакцию пользователя на видео (была ли)
    likemarks_to_video = LikeMarkVideo.objects.filter(user_lm_video__pk=request.user.pk,
                                                      video_lm__pk=pk_video)
    if likemarks_to_video.count() > 0:  # если реакция уже была (от пользователя к видео)
        return likemarks_to_video  # возвращаем Queryset - запись из LikeMarkVideo
    else:  # реакции не было
        likemarks_to_video = 'no'  # меняем relation_video на 'no'
        return likemarks_to_video  # возвращаем no</pre>
							</li>
							<li>
								Передаю параметры с функции (вызываю функцию внутри пользовательского вложенного тега). Нужно добавить в контекст тега
								<pre>
@register.inclusion_tag('video/comments_and_comment_form_self_video.html')  # в скобках шаблон 
def show_comments_and_form_comment_self_video(request, pk_video=None):
	....							
    context = {
        'likemarks_to_video': get_likemarks_to_video(request, pk_video),  # получение реакции лайк, закладка
        ....,  # форма для отправки комментария
        ....,  # все комментарии к видео (модель комментарии к видео)
        ....,  # одна запись модели Видео
        'request': request,  # для того чтобы можно было сделать проверку аутентификации
    }
    .
    return context</pre>
							</li>
							<li>
								Вызываю инфу по реакциям в шаблоне тега video/comments_and_comment_form_self_video.html
								<br>(Сухие данные без верстки)
								<pre>
&lt;span class="h5 text-warning">
	{% if likemarks_to_video == 'no' %} &lt;!-- не было реакций от пользователя -->
	&lt;p>Нет реакции 
		{{ request.user.username }}
	  к
	  {{ video_obj.name }}
	&lt;/p>
	{% else %} &lt;!-- БЫЛИ реакций от пользователя -->
	&lt;p>
		{% for lm in likemarks_to_video  %} &lt;!-- перебираю поля записи реакции -->
			Лайк: {{ lm.is_like_video }} &lt;!-- Лайк True/False -->
			&lt;br>
			Закладка: {{ lm.is_bookmarks_video }} &lt;<!-- Закладка True/False -->
		{% endfor %}
	&lt;/p>
	{% endif %} &lt;!-- не было реакций от пользователя -->				
&lt;/span></pre>
							</li>
							<li>
								Должно всё работать
							</li>
						</ul>
					</li>
					<li>
						<span>
							Переименую вложенный тег show_comments_and_form_comment_self_video - в show_all_ralations_to_video
							<br>
							comments_and_comment_form_self_video.html - в all_ralations_to_video
						</span>
						<ul>
							<li>
								В video_tags.py
								<pre>
@register.inclusion_tag('video/all_ralations_to_video.html')
def show_all_ralations_to_video(request, pk_video=None):
	....
	....</pre>
							</li>
							<li>
								В video/urls.py
								<pre>
from .templatetags.video_tags import show_all_ralations_to_video

urlpatterns = [
    # show_all_ralations_to_video - Это вложенный тег(шаблон all_ralations_to_video,
    # В ней находится вывод и обработка формы для комментариев
    # по этому для добавления комментария нужно вызвать эту функцию = вложенный шаблон
    path('add-comment/&lt;int:pk_video>/', show_all_ralations_to_video, name='add_comment'),
    ...,
]</pre>
							</li>
							<li>
								Переименовываю сам шаблон
								В - all_ralations_to_video.html
							</li>
							<li>
								В шаблоне video_all.html меняем вызов вложенного тега
								<pre>
&lt;!-- вызываем вложенный тег = show_all_ralations_to_video -->
&lt;!-- request - обязательный первый параметр вложенного тега -->
&lt;!-- v.pk - второй параметр тега, т.е делаем из pk_video=None -> в pk_video=v.pk -->
{% show_all_ralations_to_video request v.pk %}</pre>
							</li>
						</ul>	
					</li>

					<li>
						<span class="spec">
							Добавляю действия для кнопки лайк
						</span>
						<br>Все функции по реакциям к отдельным видео (лайк, закладки, комментарии) - всё пишу в video_tags.py - так как всё это идёт через вложенный тег. (1 вложенный тег - это все реакции к одному видео),
						Вложенный тег вызывается в каждой итерации цикла перебора видео.
						<ul>
							<li>
								video/templatetags/video_tags.py
								<pre>
# поведение кнопки лайк
@login_required
def like_video(request, pk_video):  # эти параметры будут браться из вложенного тега show_all_ralations_to_video
    video_obj = VideoYouTubeRuTube.objects.get(pk=pk_video)  # оцениваемое видео
    try:  # пробуем получить лайк и/или закладку авторизованного пользователя + на конкретное видео
        like_mark_video_object = LikeMarkVideo.objects.<span class="spec">get</span>(video_lm__pk=pk_video,
                                                           user_lm_video__pk=request.user.pk)
        # тоже самое что и like_mark_video_object.is_like_video == False:
        if not like_mark_video_object.is_like_video:  # если лай не стоит
            # ставим лайк
            LikeMarkVideo.objects.<span class="spec">filter</span>(video_lm__pk=pk_video,
                                         user_lm_video__pk=request.user.pk).update(is_like_video=True)
            messages.info(request, f"{request.user.username}! - вам понравилось видео: '{video_obj.name}'")
        else:  # если лайк стоит
            # убираем лайк
            LikeMarkVideo.objects.<span class="spec">filter</span>(video_lm__pk=pk_video,
                                         user_lm_video__pk=request.user.pk).update(is_like_video=False)
            messages.info(request, f"{request.user.username}! - вам больше не нравится видео: '{video_obj.name}'")
    except LikeMarkVideo.DoesNotExist:  # исключение (пользователь никогда не лайкал и не добавлял в закладки видео)
        # создаём новую реакцию
        like_mark_video_object = LikeMarkVideo.objects.create(
            user_lm_video=request.user,
            video_lm=video_obj,
            # video_obj = VideoYouTubeRuTube.objects.get(pk=pk_video)
            is_like_video=True,  # ставим лайк
            is_bookmarks_video=False  # закладку не создаём
        )
        like_mark_video_object.save()  # сохраняем запись в БД (LikeMarkVideo)
        messages.info(request, f"{request.user.username}! - вам понравилось видео: '{video_obj.name}'")
    return redirect('video_all')  # остаёмся на странице</pre>
							</li>
							<li>
								Пишу маршрут для кнопки лайк
								<br>video/urls.py - urlpatterns
								<pre>
# pk_video = video_obj.pk (определяю в шаблоне/вложенном теге)
path('like_video/&lt;int:pk_video>/', like_video, name='like_video')</pre>
							</li>
							<li>
								Выводу кнопку лайк в шаблоне=вложенном теге (сухие данные, без зависимостей лайкнул или нет) - функционал работает изчачально в независимости от исходных данных
								<br>all_ralations_to_video.html
								<pre>
&lt;!-- кнопка лайк -->
&lt;a href="{%  url 'like_video' pk_video=video_obj.pk %}" class="btn btn-outline-danger">Кнопка лайк&lt;/a></pre>
							</li>
						</ul>
					</li>
					<li>
						<span class="spec">
							Добавляю действия для кнопки добавить/убрать видео из закладок
						</span>
						<ul>
							<li>
								video/templatetags/video_tags.py - пишу повидение для кнопки закладки добавить/убрать
								<pre>
# поведение кнопки закладки
@login_required
def bookmarks_video(request, pk_video):  # эти параметры будут браться из вложенного тега show_all_ralations_to_video
    video_obj = VideoYouTubeRuTube.objects.get(pk=pk_video)  # оцениваемое видео
    try:  # пробуем получить лайк и/или закладку авторизованного пользователя + на конкретное видео
        like_mark_video_object = LikeMarkVideo.objects.<span class="spec">get</span>(video_lm__pk=pk_video,
                                                           user_lm_video__pk=request.user.pk)
        # тоже самое что и like_mark_video_object.is_bookmarks_video == False:
        if not like_mark_video_object.is_bookmarks_video:  # если не в закладках
            # Добавляем в закладки
            LikeMarkVideo.objects.<span class="spec">filter</span>(video_lm__pk=pk_video,
                                         user_lm_video__pk=request.user.pk).update(is_bookmarks_video=True)
            messages.info(request, f"{request.user.username}! - Видео: '{video_obj.name}' - добавлено в ваши закладки")
        else:  # если уже в закладках
            # убираем из закладок
            LikeMarkVideo.objects.<span class="spec">filter</span>(video_lm__pk=pk_video,
                                         user_lm_video__pk=request.user.pk).update(is_bookmarks_video=False)
            messages.info(request, f"{request.user.username}! - Видео: '{video_obj.name}' - удалено из закладок")
    except LikeMarkVideo.DoesNotExist:  # исключение (пользователь никогда не лайкал и не добавлял в закладки видео)
        # создаём новую реакцию
        like_mark_video_object = LikeMarkVideo.objects.create(
            user_lm_video=request.user,
            video_lm=video_obj,
            # video_obj = VideoYouTubeRuTube.objects.get(pk=pk_video)
            is_like_video=False,  # Лайк не делаем
            is_bookmarks_video=True  # Добавляем в закладки
        )
        like_mark_video_object.save()  # сохраняем запись в БД (LikeMarkVideo)
        messages.info(request, f"{request.user.username}! - Видео: '{video_obj.name}' - добавлено в ваши закладки")
    return redirect('video_all')  # остаёмся на странице</pre>
							</li>
							<li>
								Добавляю маршрут для функции убрать/добавить в закладки
								<br>video/urls.py
								<pre>
path('bookmarks_video/&lt;int:pk_video>/', bookmarks_video, name='bookmarks_video'),  # ЗАКЛАДКА ВИДЕО</pre>
							</li>
							<li>
								Вывожу кнопку в закладки в шаблоне-вложенном теге
								<br>all_ralations_to_video.html
								<pre>
&lt;a href="{%  url 'bookmarks_video' pk_video=video_obj.pk %}" class="btn btn-outline-danger"> Кнопка Закладки&lt;/a></pre>
							</li>
						</ul>	
					</li>
					<li>
						<span class="spec">
							Отображаю количество лайков к видео, если они есть 
						</span>
						<ul>
							<li>
								Пишу функцию подсчёта количества лайков отдельно
								<br>video_tags.py
								<pre>
# Количество лайков на видео
def get_total_likes_video(video_obj):
    total_likes_video = LikeMarkVideo.objects.filter(video_lm__pk=video_obj.pk,
                                                     is_like_video=True).count()
    return total_likes_video</pre>
							</li>
							<li>
								Передаю результат функции в контектс пользовательского вложенного тега - show_all_ralations_to_video
								<br>video_tags.py - show_all_ralations_to_video
								<pre>
@register.inclusion_tag('video/all_ralations_to_video.html')
def show_all_ralations_to_video(request, pk_video=None):
	....
    context = {
        'total_likes_video': get_total_likes_video(video_obj),  # количество лайков на видео
        ....
    }
    return context</pre>
							</li>
							<li>
								Отображаю количество лайков в шаблоне
								<br>all_ralations_to_video.html
								<pre>Количество лайков = {{ total_likes_video }}</pre>
							</li>
						</ul>
					</li>
					<li>
						Оформляю шаблон all_ralations_to_video.html - отображаю кнопки лайк и закладки как нужно и где нужно, в зависимости от условий:
						<br>-Авторизован ли пользователь
						<br>-Стоит ли лайк на видео
						<br>-Добавлено ли видео в закладки
						<br>-Отображаю количество лайков, если количество больше 0
						<br><br>
						Полный блок кода в шаблоне all_ralations_to_video.html - для лайков и закладок, с полным функционалом со всмеми проверками
						<pre>
{% load static %}

&lt;div class="d-flex justify-content-between"> &lt;!-- внешний флекс для строчки 'Комментарии: 7     Закл | Лайк' -->
	&lt;div class="bd-highlight mt-2">
		&lt;!-- Колличество комментариев -->
		&lt;span class="h5">Комментарии: {{ all_comments_for_video.all.count }}&lt;/span>
	&lt;/div>

{% if request.user.is_authenticated %} &lt;!-- авторизован ли? - для лайков и комментариев -->

	{% if likemarks_to_video == 'no' %} &lt;!-- если не было реакций от пользователя -->	
		
		&lt;div class="bd-highlight">

			&lt;!-- кнопка закладки НЕАКТИВНАЯ -->
			&lt;a class="btn" href="{%  url 'bookmarks_video' pk_video=video_obj.pk %}">
				&lt;img src="{% static 'blog/images/bookmark-off.png' %}" height="32" width="32" class="img-fluid">
			&lt;/a>

			&lt;!-- кнопка лайк НЕАКТИВНАЯ -->
			&lt;a class="btn" href="{%  url 'like_video' pk_video=video_obj.pk %}">
				&lt;img src="{% static 'blog/images/heart-off.png' %}" height="32" width="32" class="img-fluid">
			&lt;/a>			

			{% if total_likes_video > 0 %} &lt;!-- если лайки есть -->
				{{ total_likes_video }} &lt;!-- количество лайков -->
			{% endif %}	&lt;!-- если лайки есть -->	

		&lt;/div>

	{% else %} &lt;!-- если были реакций от пользователя -->	
		{% for lm_one in likemarks_to_video %} &lt;!-- перебираем поля реакций -->
			&lt;div class="bd-highlight">
				
				{% if lm_one.is_bookmarks_video == True %} &lt;!-- если в закладках -->
					&lt;!-- кнопка закладки АКТИВНАЯ -->
					&lt;a class="btn" href="{%  url 'bookmarks_video' pk_video=video_obj.pk %}">
						&lt;img src="{% static 'blog/images/bookmark-on.png' %}" height="32" width="32" class="img-fluid">
					&lt;/a>
				{% else %} <!-- если не в закладках -->
					<!-- кнопка закладки НЕ АКТИВНАЯ -->
					&lt;a class="btn" href="{%  url 'bookmarks_video' pk_video=video_obj.pk %}">
						&lt;img src="{% static 'blog/images/bookmark-off.png' %}" height="32" width="32" class="img-fluid">
					&lt;/a>
				{% endif %} &lt;!-- если в закладках -->

				{% if lm_one.is_like_video == True %} &lt;!-- если ЛАЙК стоит -->
					&lt;!-- кнопка лайе АКТИВНАЯ -->
					&lt;a class="btn" href="{%  url 'like_video' pk_video=video_obj.pk %}">
						&lt;img src="{% static 'blog/images/heart-on.png' %}" height="32" width="32" class="img-fluid">
					&lt;/a>
				{% else %} &lt;!-- если НЕ стоит ЛАЙК-->
					&lt;a class="btn" href="{%  url 'like_video' pk_video=video_obj.pk %}">
						&lt;img src="{% static 'blog/images/heart-off.png' %}" height="32" width="32" class="img-fluid">
					&lt;/a>
				{% endif %} &lt;!-- если ЛАЙК стоит -->

				{% if total_likes_video > 0 %} &lt;!-- если лайки есть -->
					{{ total_likes_video }} &lt;!-- количество лайков -->
				{% endif %}	&lt;!-- если лайки есть -->	

			&lt;/div>
		{% endfor %} &lt;!-- перебираем поля реакций -->

	{% endif %}	&lt;!-- если не было реакций от пользователя -->	

{% endif %}	&lt;!-- авторизован ли? - для лайков и комментариев -->

&lt;/div>&lt;!-- внешний флекс для строчки 'Комментарии: 7     Закл | Лайк' --></pre>
					</li>	
				</ol>
			</li>


&lt;



			<li>
				<span class="title_text">
					Делаю лайки для комментраия
				</span>
				<hr>
				<span class="spec">
					Буду выводить через вложенный тег.  (1 тег = 1 лайк/нелайк на конеретный комментарий комментарий), тег будет вызываться в цикле, перебора всех комментариев к видел
				</span>
				<br>
				Входные параметры для вложенного тега будут , request + pk комментария
				<ol type="A">
					<li>
						Делаю модель для лайка комментария
						<br>video/models.py
						<pre>
# Лайк для комментария к видео
class LikeCommentVideoYtRt(models.Model):
    # лайкнувший пользователь
    user = models.ForeignKey(User, on_delete=models.CASCADE, verbose_name='Лайкнувший пользователь')
    # Лайкнутый комментарий
    comment = models.ForeignKey(CommentVideoYtRt, on_delete=models.CASCADE, verbose_name='Лайкнутый комментарий')

    class Meta:
        verbose_name = 'Лайк комментария к видео'
        verbose_name_plural = 'Лайки комментариев к видео'
        # db_table = 'Название таблицы в БД'

    def __str__(self):
        return f'Лайк_Ком_Видео - {self.comment},' \
               f'Лайк_Юзер - {self.user}.'</pre>
					</li>
					<li>
						Регистрирую модель LikeCommentVideoYtRt - в админ панеле
						<br>video/admin.py
						<pre>
admin.site.register(LikeCommentVideoYtRt)</pre>
					</li>
					<li>
						Создаю и делаю миграцию
						<pre>
python manage.py makemigrations
python manage.py migrate</pre>
					</li>
					<li>
						Через админку создам пару лайков к комментарию
					</li>
					<li>
						Созадю шаблон вложенного тега, для получения информации и отображении в шаблоне лайка, в зависимости, лайкнул ли пользователь коммент, авторизован ли пользователь, количество лайков комментария - если их больше 0.
						<br>video/templates/video --> like_to_comment_video.html
					</li>
					<li>
						Пишу представление вложенный тег для блока лайка комментария
						<br>video/templatetags/video_tags.py
						<pre>
# вложенный тег получение (отображения) блока лайка на отдельный комментарий к видео
@register.inclusion_tag('video/like_to_comment_video.html')  # в скобках шаблон тега
# pk_com - (необходимо будет указывать в шаблоне, при вызове тега в цикле перебора комментариев)
# pk_video в шаблоне равно pk_video=v.pk (VideoYouTubeRuTube.objects.get(pk=pk_video).pk)
def show_like_to_comment_video(request, pk_com=None):

    # получаем количество лайков для конкретного поста.
    like_comment_count = LikeCommentVideoYtRt.objects.filter(comment__pk=pk_com).count()

    # Получаем объект лайка (конкретный пользователь/конкретный комментарий)
    like_obj = LikeCommentVideoYtRt.objects.filter(user__pk=request.user.pk,
                                                   comment__pk=pk_com)

    # получаем информацию лайкнул ли авторизованный пользователь конкретный комментарий
    if like_obj.count() > 0:  # если нашли запись в модели LikeCommentVideoYtRt (лайк есть)
        is_liked_comment = True  # Лайкал
    else:  # ели записи нет (то есть пользователь не лайкал этот коммент)
        is_liked_comment = False  # НЕ лайкал

    # запишу в словарь все параметры которые нужно передать в шаблон тега
    context = {
        'request': request,  # для того чтобы можно было сделать проверку аутентификации
        'is_liked_comment': is_liked_comment,  # лайкнул ли пользователь коммент
        'like_comment_count': like_comment_count,  # количество лайков на комменте от всех пользователей
        'pk_com': pk_com,  # id комментария
    }

    # передаю словарь в шаблоне тега
    return context</pre>
					</li>
					<li>
						Вызываю вложенный тег блока лайков комментария, внутри вложенного тега по всем реакциям к видео
						<br>вызываю - show_like_to_comment_video
						<br>внутри шаблона другого тега - шаблон video/all_ralations_to_video.html

						<br>
						<br><span class="text-danger">Обязательно подгрузи файл с тегами в шаблоне video_tags.py</span>
						<br>video/all_ralations_to_video.html
						<pre>
{% load video_tags %} &lt;!-- вызов файла с собстенными тегами -->


&lt;!-- НАЧАЛО ТЕГА ЛАЙК НА КОММЕНТАРИЙ-->
	&lt;div class="ps-2 bd-highlight">&lt;!-- лайк -->

		&lt;!-- Вызываю вложенный тег для блока лайк комметанрие -->
		&lt;!-- ТЕГ ВНУТРИ ТЕГА -->
		&lt;!-- (request, pk_com=com.pk -->
		{% show_like_to_comment_video request com.pk %} &lt;!-- ВЫЗОВ БЛОКА ЛАЙК_КОМ -->

	&lt;/div>&lt;!-- лайк -->
&lt;!-- КОНЕЦ ЛАЙК НА КОММЕНТАРИЙ --></pre>
					</li>
					<li>
						В шаблон тега лайков комментария переношу всю инфу по лайкам и дописываю её
						<br><span class="text-danger">СУХИЕ ДАННЫЕ в шаблоне</span>
						<br>templates/vieo/like_to_comment_video.html
						<pre>
{% load static %} <!-- для отображения иконки лайка -->


<span class="text-danger">СУХИЕ ДАННЫЕ:</span>
Лайкнул ли пользоваетель комент - is_liked_comment - {{is_liked_comment}}
Количество лайков комента - like_comment_count - {{ like_comment_count }}
ID комента(для url) - pk_com - {{ pk_com }}</pre> 
					</li>
					<li>
						Пишу логику для кнопки лайк комментария
						<br>video/templatetags/video_tags.py
						<pre>
# логика кнопки лайк для комментария
@login_required
def like_button_comment_video(request, pk_com):
    # пробую получить запись комментария
    comment = get_object_or_404(CommentVideoYtRt, pk=pk_com)

    # LikeCommentVideoYtRt
    # получаю или создаю запись лайка к комментарию, если её нет создаю
    like_comment_video, created = LikeCommentVideoYtRt.objects.get_or_create(
        comment=comment,
        user=request.user
    )

    # проверка создался ли комментарий
    if not created:  # Если запись не создалась (т.е. она уже была)
        like_comment_video.delete()  # удаляем запись = удаляем лайк
        messages.info(request, f"Вам больше не нравиться комментарий, пользователя: {comment.author_comment}.")
    else:  # если запись создалась (т.е поставили лайк)
        like_comment_video.save()  # сохраняем в БД запись лайка
        messages.info(request, f"Вам понравился комментарий, пользователя: {comment.author_comment}.")

    # перенаправляемся/остаёмся на странице списка видео
    return redirect('video_all')</pre>
					</li>
					<li>
						Пишу маршрут для кнопки лайк комментария
						<pre>path('like_comment/&lt;int:pk_com>/', like_button_comment_video, name='like_comment'),  # Лайк комментария</pre>
					</li>
					<li>
						Отображаю кнопку/ссылку добавить убрать комментарий (сухие данные)
						<br>шаблон тега templates/vieo/like_to_comment_video.html
						<pre>
&lt;a href="{% url 'like_comment' pk_com %}" class="btn btn-outline-dark">Лайк комментария&lt;
/a></pre>
					</li>
					<li>
						Весь функционал работает, делаю оформление, и все проверки:
						<br>-проверка авторизован ли, если нет просто серое сердечно и количество лайков если они есть
						<br>-елси авторизован показываю лайк по разному, в зависимости от того стоит ли он от конкретного пользователя или нет
						<br>-отображаю количество лайков если их больше 0 в любом случае (авторизован ли/ стоит ли лайк от пользователя)
						<br>
						<br>Весь код в templates/vieo/like_to_comment_video.html
						<pre>
{% load static %} &lt;!-- для отображения иконки лайка -->


{% if not request.user.is_authenticated %} &lt;!-- Если не авторизован -->
	
	&lt;!-- Неактивный лайк без ссылки -->
	&lt;img src="{% static 'blog/images/heart-off.png' %}" height="20" width="20" class="img-fluid">

	&lt;!-- количество лайков -->
	{% if like_comment_count > 0 %} &lt;!-- Если вообще есть лайки -->
		{{ like_comment_count }} &lt;!-- количество лайков -->
	{% endif %} &lt;!-- Если вообще есть лайки -->

{% else %} &lt;!-- Если Авторизован -->

	{% if is_liked_comment == False %} &lt;!-- Если Нет лайка -->
		&lt;!-- Неактивный лайк -->
		&lt;a class="btn p-0 m-0" href="{% url 'like_comment' pk_com %}">
			&lt;img src="{% static 'blog/images/heart-off.png' %}" height="20" width="20" class="img-fluid pb-1">
		&lt;/a>
	{% else %} &lt;!-- Если лайк стоит -->
		&lt;!-- Активный лайк -->
		&lt;a class="btn p-0 m-0" href="{% url 'like_comment' pk_com %}">
			&lt;img src="{% static 'blog/images/heart-on.png' %}" height="20" width="20" class="img-fluid pb-1">
		&lt;/a>
	{% endif %} &lt;!-- Если Нет лайка -->

	&lt;!-- количество лайков -->
	{% if like_comment_count > 0 %} &lt;!-- Если вообще есть лайки -->
		{{ like_comment_count }} &lt;!-- количество лайков -->
	{% endif %} &lt;!-- Если вообще есть лайки -->


{% endif %} &lt;!-- Если не авторизован --></pre>
					</li>
				</ol>
			</li>
&lt;


			<li>
				<span class="title_text">
					Добавляю удаление комментария
				</span>
				<hr>
				(если пользователь админ или комментатор)
				<ol type="A">
					<li>
						Пишу функцию для удаления комментария
						<br>video/templatetags/video_tags.py	
						<pre>
# логика кнопки удаления комментария
@login_required
def delete_comment_video_button(request, pk_com):
    # пробую получить запись комментария
    comment = get_object_or_404(CommentVideoYtRt, pk=pk_com)
    
    # если вы автор комментария или админ
    if comment.author_comment.pk == request.user.pk or request.user.pk == 1:
        comment.delete()  # удаляю запись комментарий
        messages.info(request, f"{request.user.username} - удалил комментарий!")
    else:
        messages.info(request, f"{request.user.username} - вы не можете удалить чужой комментарий!")
        
    # перенаправляемся/остаёмся на странице списка видео
    return redirect('video_all')</pre>				
					</li>
					<li>
						Пишу маршрут для удаления комментария
						<br>video/urls.py
						<pre>path('delete_comment/&lt;int:pk_com>/', delete_comment_video_button, name='delete_comment'),  # удалить коммент к видео</pre>
					</li>
					<li>
						Отображаю кнопку удаления комментария, в шаблоне тега
						<br>video/all_ralations_to_video.html
						<pre>
&lt;div class="bd-highlight">&lt;!-- автор к и удалить к -->
&lt;!-- Если пользователь автор коммента или админ (id 1) -->
{% if request.user.pk == com.author_comment.pk or request.user.pk == 1 %}
	&lt;!-- кнопка Удаления комментария -->
	&lt;span class="pe-2">
		&lt;a class="btn p-0 m-0" href="{% url 'delete_comment' pk_com=com.pk %}">
			&lt;img src="{% static 'blog/images/delete.png' %}" height="20" width="20" class="img-fluid pb-1">
		&lt;/a>							
	&lt;/span>
{% endif %} &lt;!-- Если пользователь автор коммента или админ (id 1) -->

	&lt;span>{{ com.author_comment }}:&lt;/span>
&lt;/div>&lt;!-- автор к и удалить к --></pre>
					</li>
					<li>
						Проверяем в разных условиях - всё должно работать!
					</li>
				</ol>
			</li>

&lt;

			<li>
				<span class="title_text">
					Добавляю возможность добавить видео, пользователем с сайта
				</span>
				<hr>
				<ol type="A">
					<li>
						Делаю метод get_absolute_url() в модели VideoYouTubeRuTube (необходим при работе с CreateView, UpdateView, DeleteView)
						<br><span class="text-danger">Хотя на него переходить я даже не буду (не предполагаю что будет DetailView) - у меня всё через ListView</span>
						<br>video/models.py  - class VideoYouTubeRuTube
						<pre>
# Видеофайлы YouTube/RuTube
class VideoYouTubeRuTube(models.Model):
	....

    # функция формирования маршрута к ссылке
    def get_absolute_url(self):
        return reverse('update_video', kwargs={'pk_video': self.pk})</pre>
					</li>
					<li>
						Делаю шаблон для обработки формы добавления поста, расширяюсь от video.base.html. (набросок того что нужно)
						<br>video/tyemplates/video --> video_add.html
						<pre>
{% extends 'video/video_base.html' %} 

{% block title %} 
	{{ title }}
{% endblock %}

{% block content %}

Инструкция как добавить видео с YouTube
Инструкция как добавить видео с RuTube

Если залогинен
Форма
Кнопка для формы внутри формы

Если незалогинен
Кнопки на регистрацию или авторизацию

{% endblock %}</pre>
					</li>
					<li>
						Делаю форму создания видеопоста. (не буду выводить автора поста, необходимо автоматизировать этот процесс)
						<br>
						Аналогично с time_create и time_update
						<br>video/forms.py
						<pre>
# форма создания нового видеопоста
class VideoYouTubeRuTubeForm(forms.ModelForm):
    class Meta:
        model = VideoYouTubeRuTube
        fields = ['name', 'video_url']
        widgets = {
            'name': forms.TextInput(attrs={'class': 'form-control, col-5'}),
            'video_url': forms.URLInput(attrs={'class': 'form-control, col-5'}),
        }</pre>
					</li>

					<li>
						Доабвляю путь для представления шаблона создания вилеопоста
						<pre>path('video_add/', AddVideo.as_view(), name='video_add'),  # Добавление видео</pre>
					</li>

					<li>
						Пишу представление на основе классов
						<br>video/views.py
						<pre>
							
Вьюха

						</pre>
					</li>
					<li>
						Пробую форму в шаблоне video_add.html
						<pre>
{% extends 'video/video_base.html' %} 

{% block title %} 
	{{ title }}
{% endblock %}

{% block content %}

&lt;h1>{{ title }}&lt;/h1>
&lt;hr>&lt;br>&lt;br>

&lt;form method="post">
	{% csrf_token %}

	&lt;div class="form-error">{{ form.non_field_errors }}&lt;/div> &lt;!-- общая ошибка формы -->

	{% for f in form %}  &lt;!-- перибираем поля формы -->
	&lt;!-- f.label-название поля / f - само поле -->
	&lt;p>
		&lt;label class="form-label" for="{{ f.id_for_label }}">{{f.label}}: &lt;/label>{{ f }}
	&lt;/p>
	&lt;div class="form-error">{{ f.errors }}&lt;/div> &lt;!-- ошибка в поле -->
	{% endfor %} &lt;!-- перибираем поля формы -->
	&lt;br>
	&lt;button type="submit" class="btn btn-outline-primary btn-lg">
		Добавить видео
	&lt;/button>
&lt;/form>

{% endblock %}</pre>
						Всё должно работать! Осталось только немного оформить!
					</li>
					<li>
						В оформлении:
						<br>-Если пользователь авторизован, форма добавления нового поста
						<br>-Если пользователь авторизован, инфструкция добавления видео
						<br>-Инструкция - скрываемый паратметр - collapse - bootstrap 5
						<br>-Если пользователь не авторизован - ссылки на войти и регистрация
						<br>
						<br>Полный блок кода в шаблоне video_add.html
						<pre>
{% extends 'video/video_base.html' %}
{% load static %}
{% block title %} 
	{{ title }}
{% endblock %}
{% block content %}

&lt;h1 class="text-center">{{ title }}&lt;/h1>
&lt;hr>&lt;br>&lt;br>

{% if request.user.is_authenticated %} &lt;!-- авторизован ли? -->

&lt;form method="post">
	{% csrf_token %}

	&lt;div class="form-error">{{ form.non_field_errors }}&lt;/div> &lt;!-- общая ошибка формы -->

	{% for f in form %}  &lt;!-- перибираем поля формы -->
	&lt;!-- f.label-название поля / f - само поле -->
	&lt;p>
		&lt;label class="form-label" for="{{ f.id_for_label }}">{{f.label}}: &lt;/label>{{ f }}
	&lt;/p>
	&lt;div class="form-error">{{ f.errors }}&lt;/div> &lt;!-- ошибка в поле -->
	{% endfor %} &lt;!-- перибираем поля формы -->
	&lt;br>
	&lt;button type="submit" class="btn btn-outline-info btn-lg">
		Добавить видео
	&lt;/button>
&lt;/form>
&lt;br>

&lt;!-- логика и кнопка разворачивания списка комментариев -->
&lt;button class="btn btn-outline-dark" type="button" data-bs-toggle="collapse" data-bs-target="#collapseTutorial" aria-expanded="false" aria-controls="collapseTutorial">
Посмотреть инструкцию
&lt;/button>

&lt;br>&lt;br>

&lt;!-- сворачиваемое содержимое bootstrap -->
&lt;div class="collapse" id="collapseTutorial">

	&lt;h3 class="text-center">Инструкция добавления видео с YouTube&lt;/h3>
	&lt;hr>
	&lt;br>
	&lt;div class="container-fluid">
		&lt;ol>
			&lt;div class="row"> &lt;!-- row для для Инструкции -->
				&lt;div class="col-xl-4">
					&lt;li>
						Перейдите на страничку видео в &lt;a href="https://www.youtube.com/" class="link-info">https://www.youtube.com/&lt;/a> и наждмите - "Поделиться". 
						&lt;br>&lt;br>
						&lt;img src="{% static 'blog/images/add_vid_1.png' %}" class="img-fluid rounded">
						&lt;br>&lt;br>
					&lt;/li>					
				&lt;/div> &lt;!-- col для для Инструкции -->

				&lt;div class="col-xl-4">					
						&lt;li>
							Нажмите - "Копировать".
							&lt;br>&lt;span class="text-info">Важно чтобы ссылка была именно в таком виде, в котором платформа YouTube нам её передаёт!&lt;/span> 
							&lt;br>&lt;br>
							&lt;img src="{% static 'blog/images/add_vid_2.png' %}" class="img-fluid rounded">
							&lt;br>&lt;br>
						&lt;/li>					
				&lt;/div>

				&lt;div class="col-xl-4">
					
					&lt;li>
						Вставьте ссылку в поле "Ссылка на видео:" - на нашем сайте!
						&lt;br>&lt;br>
						&lt;img src="{% static 'blog/images/add_vid_3.png' %}" class="img-fluid rounded">
						&lt;br>&lt;br>
					&lt;/li>
					&lt;li>
						Придумайте название к добавляемому видео, и напишете в поле "Название видео:" - на нашем сайте!
					&lt;/li>
					&lt;li>
						Жмём кнопку "Добавить видео". Готово!
					&lt;/li>
					
				&lt;/div> &lt;!-- col для Инструкции -->
			&lt;/div> &lt;!-- row для для Инструкции -->
		&lt;/ol>
	&lt;/div> &lt;!-- container для для Инструкции -->

	&lt;p style="font-size: 1.2em" class="text-info">
		- Способ добавления видео с Rutube - полностью аналогичен инструкции на примере YouTube.
	&lt;/p>

&lt;/div> &lt;!-- collaps для для Инструкции -->

{% else %} &lt;!-- НЕ авторизован -->

&lt;p style="font-size: 1.2em">
	- Только авторизованные пользователи могут добавить видео пост, пожалуйста авторизуйтесь или загеристрируйте новый аккаунт.
&lt;/p>
&lt;a href="{% url 'login' %}" class="btn btn-outline-info btn-lg">Войти&lt;/a>
&lt;a href="{% url 'register' %}" class="btn btn-outline-warning btn-lg">Регистрация&lt;/a>

{% endif %} &lt;!-- авторизован ли -->

{% endblock %}</pre>
					</li>
					<li>
						Добавлю ссылку - добавить видео - в video_sidebar.html
						<pre>
&lt;li class="nav-item">
    &lt;a class="nav-link active text-warning pb-2" aria-current="page" href="{% url 'video_add' %}">Добавить видео&lt;/a>
&lt;/li></pre>
					</li>
				</ol>
			</li>


&lt;


<br><br><br><br>
<hr>
<h3>Видео</h3>
			
<br>-Добавить удалить видео, если ты автор
<br>-Добавить добавить новую запись видео
<br>-Добавить редактировать видео (кроме ссылки)
<br>-добавить отображение моих закладок (фильтр)
<br>-добавить отображение моих видео (фильтр)
<br>-добавить отображение видео разных пользователей (фильтр)
<br>-добавить редирект при добавлении комментария??? сейчас редирект на все видео, а как сделать если коммент остваили со странице по фильтрам? - скорее всего только через ajax


<hr>				
<br><br><br><br>





&lt;

			<br><br><br><br><br><br><br><br><br>
			<li>
				<span class="title_text">Сделаю на сайте отдельное приложение магазина (глобально! - подкорректирую шаблоны для магазина, добавлю цены, корзину, модели корзины  итд)</span> 
				<hr>
				<br>
				<span class="spec">В разделе будет много полезной информации: информация сессии, добавление количеста чегото (оставаяь на той же странице), расчёты в моделях и так далее</span>
				<hr>
				<ol type="I">
					<li>
						<span class="title_text">Создаю новое приложение shop, регистрирую настраиваю</span>
						<hr>
							<ol type="a">
								<li>
									создаю приложение
								</li>
								<li>
									регистрирую в INSTALLED_APPS
								</li>
							</ol>
					</li>
					<li>
						<span class="title_text">МАГАЗИН</span>
						<hr>
							<ol type="a">
								<li>
									магазин
								</li>
								<li>
									магазин
								</li>
							</ol>
					</li>


					<li>
						<span class="title_text">МАГАЗИН</span>
						<hr>
							<ol type="a">
								<li>
									магазин
								</li>
								<li>
									магазин
								</li>
							</ol>
					</li>




					<li>
						<span class="title_text">МАГАЗИН</span>
						<hr>
							<ol type="a">
								<li>
									магазин
								</li>
								<li>
									магазин
								</li>
							</ol>
					</li>
					


					<li>
						<span class="title_text">МАГАЗИН</span>
						<hr>
							<ol type="a">
								<li>
									магазин
								</li>
								<li>
									магазин
								</li>
							</ol>
					</li>



					<li>
						<span class="title_text">МАГАЗИН</span>
						<hr>
							<ol type="a">
								<li>
									магазин
								</li>
								<li>
									магазин
								</li>
							</ol>
					</li>
				</ol> <!-- магазин -->
			</li> <!-- магазин -->
			<br><br><br><br><br><br><br><br><br>

&lt;





			<li>
				<span class="title_text">Что делаем</span>
				<hr>
				<ol>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
				</ol>
			</li>


&lt;




			<li>
				<span class="title_text">Что делаем</span>
				<hr>
				<ol>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
				</ol>
			</li>


&lt;





		</ol><!-- общий список -->
	</div><!-- container-md all -->
&lt; &lt; &lt;





































# Ctrl + Alt + L 

	<br>
	<br><br><br><br>


	<div class="container-md all_2"><!-- container-md all ОБЩИЙ -->
		<h1 class="title_text border">Полезности</h1><br>
		<hr>
		<ol><!-- общий список -->


			<li>
				<span class="title_text">
					Пользовательские Теги шаблонов
					<br>@register.simple_tag()
					<br>@register.inclision_tag(шаблон-тег.html')
				</span>
				<hr>
				<ol>
					<li>
						<span class="spec">simple_tag - Простой тег (QuerySet)</span>
						<ul>
							<li>
								В каталоге приложения создаём подкаталог templatestags
							</li>
							<li>
								В templatestags  - создаём файл - python file - __init__.py
							</li>
							<li>
								В templatestags создаём файл в котором будем писать теги, например video_tags.py
							</li>
							<li>
								В video_tags.py пишем превый simple_tag()
								<pre>
register = template.Library()  # регистрируем наш файл  video_tags в Library	

# пишем сам тег
@register.simple_tag()  (в скобках можно указать name='getcats') - для вызова в шаблоне как getcats
def get_caterories():
    return Category.objects.all()</pre>
							</li>
							<li>
								В шаблоне где хотим вызвать тег
								<pre>
{% load video_tags %}  # подгружаем файл с теггами

{% get_caterories%}  # вызываем тег (выведет QuerySet)

Лучше сделать так, Чтобы можно было перибирать записи из этого тега
{% get_caterories as catigories %}  # catigories - придумали сами
{% for cat in catigories %}  # перебираем все записи
    {{ cat.name }}  # вывдеем название категорий (обычный цикл)
{% endfor %}</pre>
						</ul>
					</li>



					<li>
						<span class="spec">Добавление пареметров, фильтов в simple_tag</span>
						<ul>
							<li>
								Передаём параметры в простой тег. В video_tags
								<pre>
@register.simple_tag()
def get_caterories(filter=None):
	if not filter:
    	return Category.objects.all()
    else
    	return Category.objects.filter(pk=filter)</pre>
							</li>
							<li>
								Передаём параметр filter в шаблоне
								<pre>
QuerySet									
{% get_caterories filter=1 %}  # Category.objects.filter(pk=1)</pre>
								Или ещё проще
								<pre>
QuerySet
{% get_caterories 2 %}  # Category.objects.filter(pk=2)</pre>
							</li>
						</ul>								
					</li>




					<li>
						<span class="spec">inclision_tag - Вложенный тег (шаблон)</span>

						<ul>
							<li>
								В video_tags.py пишем включающий тег
								<pre>
register = template.Library()  - это обязательно, 1 раз в файле тего сверху

#Включающий тег, который возввратит html шаблон, внутри другого шаблона
@register.inclision_tag('blog/list_categories.html')  #отдельный шаблон
def show_categories():
   cats = Categories.objects.all()
   return {'cats':cats}</pre>
							</li>
							<li>
								В шаблоне blog/list_categories.html - Пишем html - например список который будет через цикл выводить все названия категорий, со всеми дивами и так далее
							</li>
							<li>
								В шаблоне, в который хотим вставить вложенный тег
								<pre>
{% show_categories %}  # в это место целиком будет вставлен шаблон blog/list_categories.html</pre>
							</li>
						</ul>
					</li>


					<li>
						<span class="spec">Передача нескольких параметров во вложенный тег</span>
						<ul>
							<li>
								video_tags.py
								<pre>
#Включающий тег, который возввратит html шаблон, внутри другого шаблона
@register.inclision_tag('blog/list_categories.html')  #отдельный шаблон
def show_categories(sort=None, cat_selected=0):
	if not sort:
		cats = Category.objects.all()
	else:
		cats = Category.objects.all(sort)

   return {'cats':cats, 'cat_selected': cat_selected}</pre>
							</li>
							<li>
								В шабллоне - blog/list_categories.html, Вывод имени категорий через цикл for
								<pre>
{% for c in cats %}
	&lt;li>{{ c.name }}&lt;/li>
{% endfor %}</pre>
							</li>
							<li>
								Вывод в шаблоне
								<pre>
{% show_categories '-name' cat_selected %}
# вывделет все имена категорий
# cat_selected - в шаблоне уже должно быть!</pre>
							</li>
							<li>
								Есл сортировка не нужна, в шаблоне можно указать просто
								<pre>{% show_categories cat_selected=cat_selected %}</pre>
							</li>
						</ul>
					</li>			
				</ol>
			</li>




&lt;



			<li>
				<span class="title_text">
					Получение динамического маршрута [3 динамических параметра из трёх разных моделей] 
					<br>.../cat_slug/car_slug/com_id
					<br>http://127.0.0.1:8000/category/uk/aston-martin-db11-amr/57/
				</span>
				<hr>
				<ol>
					<li>
						В модели крайнего параметра - Comment - добавляем метод get_absolute_url
						<br>models.py - Comment
						<pre>
# функция формирования маршрута к ссылке
def get_absolute_url(self):  # self - ссылка на один экземпляр(строку) таблицы модели
    # reverse('имя пути', kwargs={ Category-slug, Car-slug, Comment-slug}
    return reverse('sss_path', kwargs={'cat_slug': self.car_post.cat.slug,
                                       'car_slug': self.car_post.slug,
                                       'com_id': self.pk})</pre>
                        <br>-sss_path - это имя маршрута
                        <br>-self.car_post.cat.slug = Category - поле slug
                        <br>-self.car_post.slug = Car - поле slug
                        <br>-self.self.pk = Comment - поле slug
                        <br>
                        <br>
                        где car_post = ForeignKey Car | cat = ForeignKey Category
                        <br>То есть самой удалённой модели дошли до первой, с помощью ForeingKey
					</li>
					<li>
						Пишем маршрут для всего этого в urls.py - urlpatterns
						<pre>path('category/&lt;slug:cat_slug>/&lt;slug:car_slug>/&lt;int:com_id>/', comment, name='sss_path'),</pre>
						<br>comment - функция представления
					</li>
					<li>
						Делаем функцию представления
						<pre>
def comment(request, cat_slug, car_slug, com_id):
    comment_post = Comment.objects.get(pk=com_id)
    context = {'comment_post': comment_post}
    return render(request, 'blog/sss.html', context=context)</pre>
    					<br>cat_slug, car_slug, com_id - это параметры из get_absolute_url - в модели
					</li>
					<li>
						Создаём шаблон sss.html - в нём пару параметров для понимания
						<pre>
Комментарий с ID/PK: {{ comment_post.pk }}
ТЕКСТ Комментария: {{ comment_post.text_comment }}
Автор Комментария: {{ comment_post.author_comment }}
Название статьи, на которую сделан комментарий: {{ comment_post.car_post.title }}
Название категории, где находится статья, на которой сделан комментарий: {{ comment_post.car_post.cat.name }}</pre>
						<span class="spec">
							Причём в контектс шаблона мы отправляли только комментарий - но внетри шаблона через комментарий добрались до статьи, а через статью добрались и до категории!
						</span><br><br>
					</li>
					<li>
						<span class="spec">Ссылка на страницу с тремя динамическими параметрами</span><br>
						Получаем url, ссылку на html странице, для того чтобы перейти со страницы статьи на страницу комментария
						<br>Шаблон car.html (статья)
						<pre>
&lt;a href="{% url 'sss_path' car_slug=car.slug cat_slug=car.cat.slug com_id=сom_element.pk %}">Ссылка на каждый комментарий&lt;/a></pre>
						<br>
						<span class="spec">
							-sss_path - имя маршрута<br>
							-далее без запятых, в любом порядке(вроде) необходимо указать все динамические параметры, до них всегда можно добраться с той страницы где размещаем ссылку<br>
							-сom_element - это одна статья (элемент цикла for) - я сам назвал её так в шаблоне, ничего трудного
						</span><br><br><br><br>
						<span class="spec">ИЛИ</span>
						<hr><br><br><br><br>
					</li>
					<li>
						<span class="spec">Создание ссылки в шаблоне a href=''  - с помощью get_absolute_url (предпочтительнее далать так!)</span>
						
						<pre>
&lt;a href="{{ сom_element.get_absolute_url }}">Cсылка через get_absolute_url&lt;/a>

# ссылка равносильна - {% url 'sss_path' car_slug=car.slug cat_slug=car.cat.slug com_id=сom_element.pk %}
# сom_element - это одна запись из модели Comment (просто взятая из цикла for)
</pre>
					</li>
				</ol>
			</li>

			<li>
				<span class="title_text">
					Получение информации о пользователе в сессии (в представлении, в шаблоне) request.user
				</span>
				<hr>
				<ul>
					<li>
						Получение данных о пользователи (какой пользователь аутентифицирован) в views.py - из реквеста
						<pre>
def sample_view(request):
    current_user = request.user
    print current_user.id</pre>
					</li>
					<li>
						Получение записи одного пользователя в request - из модели User
						<pre>
def show_profile(request):
    current_user = request.user

    user_info = User.objects.get(username=current_user)</pre>
				    	<br>Передача в шаблон
				    	<pre>
def show_profile(request):
    current_user = request.user

    user_info = User.objects.get(username=current_user)

    all_user = User.objects.all()
    context = {
        'all_user': all_user,
        'current_user': current_user,
        'user_info': user_info,
    }
    return render(request, 'account/profile.html', context=context)</pre>
				    	<br>Отображение в шаблоне
				    	<pre>
login: {{ user_info.username }}
мыло: {{ user_info.email }}
Имя: {{ user_info.first_name }}
Фамилия: {{ user_info.last_name }}
Пароль: {{ user_info.password }}</pre>
					</li>
					<li>
						Проверка аутетефицирован ли пользователь в функции представления
						<pre>
if request.user.is_authenticated:
    # Do something for authenticated users.
else:
    # Do something for anonymous users.</pre>
				    <li>
				    	Проверка аутентефицирован ли пользователь внутри шаблона
    	<pre>
{% if request.user.is_authenticated %}
блок кода покажета если пользователь щалогинен</pre>
				    </li>
				    <li>
				    	Получение id пользоватьеля из request
				    	<pre>request.user.id</pre>
				    </li>
				    <li>
				    	<span class="spec">ПЕРЕДАВАТЬ ЗНАЧЕНИЯ ПОЛЬЗОВАТЕЛЯ В ШАБЛОН НЕ ОБЯЗАТЕЛЬНО</span>
				    	его передаёт request.   (requuest.user) 
				    	<br>Можно просто сразу обращаться в шаблоне {{user}} {{user.id}} {{user.last_name}} и тд
				    </li>
				    <li>
				    	<span class="spec">Что хранится в request? - полный список</span>
				    </li>
				</ul>
			</li>

		</ol><!-- общий полезности -->
	</div><!-- общий полезности -->

&lt;




<!-- JS Bootstrap 5 -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-gtEjrD/SeCtmISkJkNUaaKMoLD0//ElJ19smozuHV6z3Iehds+3Ulb9Bn9Plx0x4" crossorigin="anonymous"></script>


</body>
</html>


