<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- css bootstrap 5 -->
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x" crossorigin="anonymous">

	<title>Автоблог - конспект работы</title>

	<style type="text/css">
		
		pre{
			color: black;
			background: #ffe2e2;
			margin-right: 30px;
			margin-left: 15px;
			margin-bottom: 2px;
			margin-top: 5px;
		}
		
		.all{
			background: #003802;
			color: white;

		}
		
		body{
			background: #c1ffcb;
		}
		
		.spec {
			font-size: 18px;
			letter-spacing: .2em;
			font-weight: 500;
/*			text-transform: uppercase;*/
			color: #ff7575;
			margin-top: 15px;
			margin-bottom: 2px;
		}

		.title_text {
			letter-spacing: .1em;
			font-weight: 500;
			color: #f2cb71;

		}

	</style>


&lt; &lt; &lt;
</head>


<body>
<!-- 	<p><a href="https://www.youtube.com/@selfedu_rus">selfedu</a></p>
	<p><a href="https://www.youtube.com/watch?v=FyTL1bnUx5I&list=PLA0M1Bcd0w8xO_39zZll2u1lz_Q-Mwn1F">Django 3 для Python(плейлист)</a></p> -->
	<p><a href="https://proproprogs.ru/django">https://proproprogs.ru/django</a></p>
	<p><a href="https://django.fun/ru/articles/tutorials/">Статьи о Django</a></p>
	<p><a href="https://habr.com/ru/post/514348/">Шесть Python-пакетов, которые рекомендуется использовать в каждом веб-приложении на Django</a></p>
	<p><a href="https://django.fun/ru/docs/">Документация по фреймворку и библиотекам Django</a></p>
	<p><a href="https://translated.turbopages.org/proxy_u/en-ru.ru.5b0ed4c9-6378aa3f-3f4ce05c-74722d776562/https/hackr.io/blog/top-django-interview-questions-and-answers">50 лучших вопросов и ответов для интервью Django на 2022 год</a></p>
	<p><a href="https://pypi.org/">pypi.org</a></p>

	<div class="container-md all"><!-- container-md all ОБЩИЙ -->
		<h1 class="title_text">Автоблог</h1>
		<ol><!-- общий список -->




<!-- -delete-delete-delete-delete-delete-delete-delete-delete-delete-delete-delete- -->
			<br><br>
			<h4 class="title_text border">[1]. Начало</h4>
			<li><span class="spec">Особый текст</span>
				<br>
				<img src="images\avtoblog\host.jpg" class="img-fluid">
				<br>
			</li>
			<li>
				Код
				<pre>
python manage.py runserver
python manage.py sdfsdsd</pre>
			</li>
			</li>
			<li>
				
			</li>
<!-- -delete-delete-delete-delete-delete-delete-delete-delete-delete-delete-delete- -->

			<br><br>
			<h4 class="title_text border">[1]. Начало</h4>
			<li>
				Сделал окружение
			</li>
			<li>
				Создаём Новый проект в PyCharm - C:\Хранилище\IT\IT Projects\avtoblog-project
				<br>Окружение venv_2022 - указывал путь к venv_2022\Scripts\python.exe
			</li>
			<li>
				Внутри окружения уже есть большинство пакетов которые будут необходимы:
				<br>-Pillow - для работы с изображениями
				<br>-django-crycpy-forms - использовал в eccomerce
				<br>-Django 4.1.3
				<br>-psycopg2 - для работы с PostgreSQL
				<br>-virtuslenv
				<br>-pip
				<br><br>Консоль работает, должно быть всё норм
			</li>
			<li>
				Стартую проект django
				<pre>django-admin startproject avtoblog</pre>
				<br>В ручную подкорректировал папки в проекте:
				<br>-IT Projects\avtoblog-project\avtoblog (manage.py в avtoblog, .idea - в avtoblog-project)
				<br>-В Pycharm - папке avtoblog-project - присвоил source root
			</li>
			<li>
				Из <a href="www.toptal.com">www.toptal.com</a> генерируем .gitignore  - и помещаем в avtoblog-project
				<br>Раскомментируй .idea/ поставь сверху
			</li>
			<li>
				Создаём Базу данных DB - Для проекта в SQL Shell (PostgreSQL)
				<pre>
Server [localhost]:
Database [postgres]:
Port [5432]:
Username [postgres]:
Пароль пользователя postgres:blog1234

psql \! chcp 1251  # для отображении кириллицы
\l смортрим список всех DB
CREATE DATABASE avtoblogdb;  # создали базу данных - avtoblogdb
-->CREATE DATABASE
\l - смотрим DB создана
				</pre>
			</li>
			<li>
				Сразу привыязваем наш проект к базеданных postgreSQL - avtoblogdb - в settings.py
				<pre>
DATABASES = {
    'default': {
        # 'ENGINE': 'django.db.backends.sqlite3',  # стандартная БД
        # 'NAME': BASE_DIR / 'db.sqlite3',  # стандартная БД
        'ENGINE': 'django.db.backends.postgresql',  # БД PostrgeSQL
        'NAME': 'avtoblogdb',  # Имя нашей БД
        'USER': 'postgres',  # пользователь postgres - который создал БД
        'PASSWORD': 'blog1234',  # пароль в PostgreSQL, для пользователя postgres
        'HOST': '127.0.0.1',  # либо просто - 'localhost'
        'PORT': '5432',  # стандартный порт
    }
}</pre>
			</li>
			<li>
				В settings.py сразу настроим часовой пояс и русский язык в админке
				<pre>
LANGUAGE_CODE = 'ru-Ru'  # русский язык в admin

TIME_ZONE = 'Europe/Moscow'  # время по МСК</pre>
			</li>
			<li>
				На github - создадим репозиторий - avtoblog
			</li>
			<li>
				Инициализируем git репозиторий на PC, и запушим первый коммит
				<pre>
git –v  # посмотреть версию git
git init  # инициализируем git репозиторикй- папку на pc
git status  # смотрим какие файлы не отслеживаются на данный момент
git add .  # добавляем все файлы
git status  # смотрим что теперь всё отслеживается
git commit -m "имя коммита(что сделали/стадия)"  # создаём коммит
git remote add origin  - https://github.com/Mello134/репозиторий.git  # туда будем загружать
git branch -M main
git push -u origin main  # отправили на github - в репозитор</pre>
			</li>
			<li>
				Создаём приложение blog  в avtoblog-project
				<pre>python manage.py startapp blog</pre>
			</li>
			<li>
				Регистрируем приложение blog в settings.py - INSTALLED_APPS. Информацию берём из blog/apps.py
				<pre>'blog.apps.BlogConfig',  # наше приложение blog</pre>
			</li>
			<li>
				Создадим urls.py в blog в него сразу импортируем path и views.py
				<pre>
from django.urls import path
from .views import *</pre>
				Создаём свой список urlpatterns, запишим первый путь
				<pre>
urlpatterns = [
    path('', home, name='home'),
]</pre>
			</li>
				Расширим основной avtoblog/urls.py  + avtoblog/urls.py (include)
				<br>Для этого добавляем маршрут к urls.py из blog  + имортируем include()
				<pre>
from django.urls import path, include

path('', include('blog.urls')),  # путь к путям приложения blog
				</pre>

			<li>
				Создадим первую функцию представления во blog/views.py
				<pre>
from django.http import HttpResponse
				</pre>
			</li>
			<li>
				Добавим две функции представления категорий и отдельной машины. В blog/views.py
				<pre>
# страница категорий
def categories(request):
    return HttpResponse('Страница категорий')


# страница отдельной машины
def car(request):
    return HttpResponse('Страница отдельной машины')</pre>
			</li>
			<li>
				Сразу пропишем маршруты к ним в url.py
				<pre>
path('category/', categories, name="category"),
path('car/', car, name='car'),</pre>
			</li>
			<li>
				Увеличим функции представления и маршруты catregory/1-2-3.. и car/1-2-3
				<br>Во views.py
				<pre>
# страница категорий
def categories(request, category_id):  # в скобках то что получаем в запросе
    # в return то что отдаём для отображения
    return HttpResponse(f'&lt;h1>Страница категорий&lt;/h1>&lt;p>№ {category_id}&lt;/p>')


# страница отдельной машины
def car(request, car_id):
    return HttpResponse(f'&lt;h1>Страница отдельной машины&lt;/h1>&lt;p>№ { car_id }&lt;/p>')</pre>
				<br>В urls.py
				<pre>
path('category/&lt;int:category_id>/', categories, name="category"),
path('car/&lt;int:car_id>/', car, name='car'),</pre>
			</li>
			<li>
				<span class="spec">Искочения и 404 не далал на данном этапе. П33 КОНСПЕКТА SELFEDU</span>
			</li>
			<li>
				Пропишим 2 модели Сar, Category в models.py
				<pre>
class Car(models.Model):
    # Id прописывать не нужно - Model Это делает автоматически
    title = models.CharField(max_length=255, verbose_name='Заголовок')  # длина 255 символов
    # unique=True - поле уникально, db_index=True - индексируемое (для ускорения поиска, verbose_name - отображение в адм.)
    slug = models.SlugField(max_length=255, unique=True, db_index=True, verbose_name='URL')
    content = models.TextField(blank=True, verbose_name='Текст статьи')  # текстовое поле без ограничений, blank=True - поле может быть пустым
    tth = models.TextField(blank=True, verbose_name='Технические характеристики авто')
    photo = models.ImageField(upload_to='photos/%Y/%m', verbose_name='Фото')  # загружать будем в photos/год/месяц
    time_create = models.DateTimeField(auto_now_add=True, verbose_name='Время создания')
    time_update = models.DateTimeField(auto_now=True, verbose_name='Время изменения')
    is_published = models.BooleanField(default=True, verbose_name='Публикация')  # default=True
    # cat_id - id добавится автоматом, ForeignKey - связь Car - c Category
    cat = models.ForeignKey('Category', on_delete=models.PROTECT, verbose_name='Категории')


class Category(models.Model):
    # db_index - для того чтобы поле было индексированным, поиск по небу будет происходить быстрей
    name = models.CharField(max_length=100, db_index=True, verbose_name='Категория')
    slug = models.SlugField(max_length=255, unique=True, db_index=True, verbose_name='URL')</pre>
			</li>
			<li>
				Сделаем первую миграцию и применим её - без этого путь admin не работает!
				<pre>
python manage.py makemigrations
python manage.py migrate</pre>
			</li>
			<li>
				Создадим superuser
				<pre>
python manage.py createsuperuser  # создаём суперюзера

Имя пользователя: Mello
Адрес электронной почты: elproject220@yandex.ru
Password:blog1234
Password (again):blog1234
Superuser created successfully.  # пользователь создан</pre>
			</li>
			<li>
				Зарегистрируем наши моделе в админке. в blog/admin.py
				<pre>
admin.site.register(Car)
admin.site.register(Category)</pre>
			</li>
			<li>
				Настраиваем MEDIA_ROOT - MEDIA_URL в settings.py
				<pre>
MEDIA_ROOT = BASE_DIR / 'media'  # будет загружать медиа в папку media
MEDIA_URL = '/media/'  # добавили url - будет отображаться в браузере</pre>
			</li>
			<li>
				Для эмуляции работы сервер для получения ранее загруженных файлов, и передачи их нашему приложению.
				<br>В avtoblog/urls.py добавим маршруты к статическим файлам и к медиафайлам
				<pre>
from django.conf.urls.static import static  # пути к статическим файлам
from . import settings  # для MEDIA_URL MEDIA_ROOT

if settings.DEBUG:
    # к путям добавляем путь к статическим данным, графическим данным
    # на реальных серверах обычно это не используется
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)</pre>
			</li>
			<li>
				Настраиваем STATIC_URL STATIC_ROOT STATICFILES_DIRS
				<br>-STATIC_URL - префикс URL-адреса
				<br>-STATIC_ROOT - путь к общей статической папке, используемый реальым веб-сервером
				<br>-STATICFILES_DIRS - список дополнительных(нестандартных) путей к статическим файлам, используемых для сбора и для рещима отладки
				<br><br>в settings.py
				<pre>
STATIC_URL = 'static/'  # стандартно
# STATIC_ROOT добавили, в эту папку при collectstatic - django перемещает все статические файлы
# путь avtoblog-project/avtoblog - из этой папке, статический файлы будут пользоваться в режиме эксплуатации сайта на сервере
STATIC_ROOT = BASE_DIR / 'static'
# добавили пустой список, список нестандартных путей, пока у нас нет, оставим пустым
STATICFILES_DIRS = []</pre>
			</li>
			<li>
				Создам вручную папку для статических фалов. В blog:
				<br>blog/static
				<br>blog/static/blog
				<br>blog/static/blog/css 
				<br>blog/static/blog/images - туда буду загружать иконки
				<br>blog/static/blog/js
			</li>
			<li>
				Создам файл стилей styles.css - в blog/static/blog/css 
			</li>
			<li>
				Создам вручную папку для шаблонов фалов. В blog:
				<br>blog/templates
				<br>blog/templates/blog
			</li>
			<li>
				Создам base.html - в blog/templates/blog
			</li>
			<li>
				Привяжу функцию представления def home - к base.html, в vievs.py
				<pre>
# домашняя страница
def home(request):
    context = {
        'title': 'Базовый шаблон',
        'ключ 2': 'Значение2',        
    }
    return render(request, 'blog/base.html', context=context)</pre>
			</li>
			<li>
				В base.html  - чтото напишу для проверки
				<pre>
&lt;!DOCTYPE html>
&lt;html>
&lt;head>
	&lt;meta charset="utf-8">
	&lt;meta name="viewport" content="width=device-width, initial-scale=1">
	&lt;title>{{ title }}&lt;/title>
&lt;/head>
&lt;body>
	&lt;h1>{{ title }}&lt;/h1>
&lt;/body>
&lt;/html></pre>
			</li>
			<li>
				Далее верстаю страницу base.html, Добавляю bootstrap, ссылку на css, подкгружаю статические файлы - В base.html - будет navbar, sidebar, footer
				<pre>
---в самом верху---
{% load static %}

---до title, в head---
ссыылка BOOTSTRAP CSS -->
ссыылка к нашему css файлу -->
ссылка для отображении иконки в браузере (где title) -->

---в title---
{% block title %} {% endblock %}

---до закрытия body---
ссыылка BOOTSTRAP JS --></pre>
			</li>
			<li>
				Сделал навбар, сайдбар и футер в base.html - указал промежуток {% block content %}
			</li>
			<li>
				Создал home.html в нём унаследовался от base.html - указал block kontent с минимальным содержимым
				<pre>
{% extends 'blog/base.html' %} 

{% block title %} 
	{{ title }}
{% endblock %}

{% block content %}
&lt;h1>{{ title }}&lt;/h1>
&lt;p>{{ key_2 }}&lt;p>
{% endblock %}</pre>
			</li>
			<li>
				Подгорректировал def home во views.py
				<pre>
# домашняя страница
def home(request):
    context = {
        'title': 'Главная страница',
        'key_2': 'Значение2',
    }
    return render(request, 'blog/home.html', context=context)</pre>
			</li>
			<li>
				Пропишим метод __str__ в моделях Car, Category - чтобы при обращении к категории или посту нам отображался title Car, name - Category
				<pre>
--class Car--
# с помощью метода запись нашего класса будет выводиться по её заголовку
def __str__(self):
    return self.title

--class Category--
# будем обращаться к категории по полю name
def __str__(self):
    return self.name</pre>
			</li>
			<li>
				В модели дпбавим класс Meta - для нормального отображенияв админ панели и сортировки
				<pre>
--class Car--
class Meta:
    verbose_name = "Автомобиль"
    verbose_name_plural = "Автомобили"
    ordering = ['-time_create', 'title']  # сортировка, сначала по дате создания, потом по имени

--class Category--
class Meta:
    verbose_name = "Категория"
    verbose_name_plural = "Категории"
    ordering = ['id']  # сортировка, сначала по id</pre>
			</li>
			<li>
				Отобразим на нормальном языке наше приложение в админке
				<br>В blog/apps.py - class BlogConfig - добавим 1 поле
				<pre>verbose_name = 'Авто блог'  # отображение названия приложения</pre>
			</li>
			<li>
				Добавим пару записей в категорию и посты
			</li>
			<li>
				Для отображения столбцов в админ панеле в admin.py добавим классы, и опишем их
				<pre>
class CarAdmin(admin.ModelAdmin):
    # список отображаемых столбцов в админ-панели
    list_display = ('id', 'title', 'time_create', 'photo', 'is_published')
    prepopulated_fields = {'slug': ('title',)}  # автозаполнение слага по имени поста
    # список полей на которые можно кликнуть - для редактирования
    list_display_links = ('id', 'title')
    # список полей - ко которым можно вести поиск
    search_fields = ('title', 'content')
    # редактирование поля публикации - в списке - в админке
    list_editable = ('is_published',)  # запятая - если 1 поле!
    # фильтр по полям - публикация, время изменения.
    list_filter = ('is_published', 'time_create')</pre>
    			<pre>
    class CategoryAdmin(admin.ModelAdmin):
    prepopulated_fields = {'slug': ('name',)}  # автозаполнение слага по имени категории
    list_display = ('id', 'name')
    list_display_links = ('id', 'name')
    search_fields = ('name',)  # ЗАПЯТАЯ В КОНЦЕ- при одном поле</pre>
    			<pre>
admin.site.register(Car, CarAdmin)
admin.site.register(Category, CategoryAdmin)</pre>
			</li>
			<li>
				Для отображения миниатюр фото вместо ссылки на фото добавим метод get_html_photo (назвали сами) - там же в class CarAdmin(admin.ModelAdmin):
				<pre>
from django.utils.safestring import mark_safe

list_display = ('id', 'title', 'time_create', 'get_html_photo', 'is_published')

# отображение миниатюр фото в админке
    def get_html_photo(self, object):
        if object.photo:  # если фото есть
            # mark_safe - не экранирует теги
            return mark_safe(f"<img src='{object.photo.url}' width=50>")</pre>
			</li>
			<li>
				Создам шаблон для отображения 1 поста car.html, наследуюсь от base.html
				<pre>
{% extends 'blog/base.html' %} 

{% block title %} 
	{{ title }}
{% endblock %}

{% block content %}
&lt;h1>{{ title }}&lt;/h1><
{% endblock %}</pre>
			</li>
			<li>
				Изменю функцию представления def car
				<pre>
# страница отдельной машины
def car(request, car_slug):
    car = Car.objects.get(slug=car_slug)
    context = {
        'car': car,
    }
    return render(request, 'blog/car.html', context=context)</pre>
			</li>
			<li>
				Добавлю метод get_absolute_url - для Модели Car - для получения маршрута по слагу
				<pre>
from django.urls import reverse

# функция формирования маршрута к ссылке
def get_absolute_url(self):  # self - ссылка на один экземпляр(строку) таблицы модели
    # получаем путь('path name=car, 'car/&lt;slug:car_slug>/) = 127/car/supra)
    return reverse('car', kwargs={'car_slug': self.slug})  # self.slug - атрибут slug</pre>
			</li>
			<li>
				Изменяем маршрут в urls.py  name='car'
				<pre>
path('car/&lt;slug:car_slug>/', car, name='car'),</pre>
			</li>
			<li>
				Отображаю все поля на в шаблоне car.html
				<pre>
{% extends 'blog/base.html' %} 

{% block title %} 
	{{ car.title }}
{% endblock %}

{% block content %}

&lt;h1>{{ car.title }}&lt;/h1>
{% if post.photo %}
&lt;img src="{{ car.photo.url }}" class="img-fluid">&lt;br>
{% endif %}

&lt;p>Производство: {{ car.cat }}&lt;/p>
&lt;h3>Технические характеристики&lt;/h3>
&lt;p>{{ car.tth|linebreaks}}&lt;/p>&lt;br>
&lt;h3>Описание модели&lt;/h3>
&lt;p>{{ car.content|linebreaks }}&lt;/p>&lt;br>
&lt;p>Время обновления поста: {{ car.time_update }}&lt;/p>
&lt;
{% endblock %}</pre>
			</li>
			<li>
				Занимаемся оформлением шаблона car.html
			</li>
			<li>
				Делаем отображение на главной странице (будут показывать все записи в модели)
			</li>
			<li>
				Во views.py - передаём в шаблон, все записи модели Car - в функции представления
				<pre>
# домашняя страница
def home(request):
    cars = Car.objects.all()
    context = {
        'title': 'Главная страница',
        'cars': cars,
    }
    return render(request, 'blog/home.html', context=context)</pre>
			</li>
			<li>
				Выводим все записи в шаблоне home.html
				<br>Оформляем шаблон home.html
			</li>
			<li>
				Пишем get_absolute_url - Category  - по слагу - в models.py
				<pre>
# функция формирования маршрута к ссылке
def get_absolute_url(self):
    return reverse('category', kwargs={'cat_slug': self.slug})</pre>
			</li>
			<li>
				Меняем маршрут по слагу urls.py
				<pre>path('category/&lt;slug:cat_slug>/', categories, name="category"),</pre>
			</li>
			<li>
				Меняем функцию представления views.py
				<pre>
# вывод записей Car - по выбранной категории
def categories(request, cat_slug):  # в скобках то что получаем в запросе
    # cat__slug - обращение из модели Car - к полю slug модели Category
    # cat_slug - значение поля slug - выбранной категории - см get_abs_url Category
    cars = Car.objects.filter(cat__slug=cat_slug)
    context = {
        'title': f'Производство: {category_1}',
        'cars': cars,
    }
    return render(request, 'blog/home.html', context=context)</pre>
			</li>
			<li>
				Выводим информацию в шаблон - в home.html
				<br>Ничего менять не нужно - будут отображаться только выбранные по категории авто
			</li>
			<li>
				Sidebar вывожу в отдельный шаблон sidebar.html
				<br>Просто удаляю всё из base.html - переношу в sidebar.html
				<br>В base.html - 1 строка в нужном месте
				<pre>{% include 'blog/sidebar.html' %}</pre>
			</li>
			<li>
				Выводим категории (ссылки в sidebar)
				views.py  - создаём переменную all_categories - выше всех функций представления
				<pre>
all_categories = Category.objects.all()</pre>
				<br>В context - Каждой функции представления добавим all_categoryies - чтобы при "вызове" функции представления на html - страницах отображались категории
				<pre>
# домашняя страница
def show_home(request):
    cars = Car.objects.all()
    context = {
        'cat_selected': 'all',
        'all_categories': all_categories,
        'title': 'Все модели',
        'cars': cars,
    }
    return render(request, 'blog/home.html', context=context)


# вывод записей Car - по выбранной категории
def show_categories(request, cat_slug):  # в скобках то что получаем в запросе
    # cat__slug - обращение из модели Car - к полю slug модели Category
    # cat_slug - значение поля slug - выбранной категории - см get_abs_url Category
    cars = Car.objects.filter(cat__slug=cat_slug)
    category_1 = Category.objects.get(slug=cat_slug)
    context = {
        'all_categories': all_categories,
        'cat_selected': category_1.slug,
        'title': f'Производство: {category_1}',
        'cars': cars,
    }
    return render(request, 'blog/home.html', context=context)


# страница отдельной машины
def show_car(request, car_slug):
    car = Car.objects.get(slug=car_slug)
    context = {
        'all_categories': all_categories,
        'car': car,
    }
    return render(request, 'blog/car.html', context=context)</pre>
			</li>
			<li>
				В шаблоне sidebar.html  - сделаем вывод всех категорий, через цикл фор, так же добавим конструкцию if (сравниваем cat_selected) -  для отображания ссылки в виде активной ссылки либо в виде уже выбранной категории, причем будем сравнивать отдельно для кнопки  Все категории, и отдельно для остальных категорий
				<pre>
{% if cat_selected != 'all' %}
&lt;li class="nav-item">
&lt;a class="nav-link active" aria-current="page" href="{% url 'home' %}">Все категории&lt;/a>
&lt;/li>
{% else %}
&lt;li class="nav-item">
&lt;a class="nav-link disabled" href="{% url 'home' %}" tabindex="-1" aria-disabled="true">Все категории&lt;/a>
&lt;/li>
{% endif %}	


{% for category in all_categories %}


{% if cat_selected == category.slug %}
&lt;li class="nav-item">
&lt;a class="nav-link disabled" href="{{ category.get_absolute_url }}" tabindex="-1" aria-disabled="true">{{ category.name }}&lt;/a>
&lt;/li>
{% else %}
&lt;li class="nav-item">
&lt;a class="nav-link" href="{{ category.get_absolute_url }}">{{ category.name }}&lt;/a>
&lt;/li>
{% endif %}

{% endfor %}</pre>
			</li>
			<li>
				<span class="spec">Зелаю путь для отдельной машины - http://127.0.0.1:8000/category/japan/nissan-silvia-s14</span>
				<ol>
					<li>
						Самое важное, models.py - class Car - get_absolute_url
						<pre>
def get_absolute_url(self):
    return reverse('car', kwargs={'cat_slug': self.cat.slug, 'car_slug': self.slug})</pre>
    					<strong>ПОРЯДОК cat_slug/car_slut - важен, точно такой эе как и в маршруте!</strong>
					</li>
					<li>
						Меняем маршрут urls.py
						<pre>path('category/&lt;slug:cat_slug>/&lt;slug:car_slug>', show_car, name='car'),</pre>
					</li>
					<li>
						Меняем функцию представления для отдельной машины
						<br><strong>на входе необходимо принимать как car_slug так и cat_slug</strong>
						<br>car/cat_slug - это ключи в get_absolute_url - models.py - class Car
						<pre>
# страница отдельной машины
def show_car(request, car_slug, cat_slug):
    car = Car.objects.get(slug=car_slug)
    context = {
        'all_categories': all_categories,
        'car': car,
    }
    return render(request, 'blog/car.html', context=context)</pre>
					</li>
					<li>
						Всё работает! Но последним штрихом def show_car - добавлю cat_selected в context
						<pre>
# страница отдельной машины
def show_car(request, car_slug, cat_slug):
    car = Car.objects.get(slug=car_slug)
    context = {
        'cat_selected': cat_slug,
        'all_categories': all_categories,
        'car': car,
    }
    return render(request, 'blog/car.html', context=context)</pre>
					</li>
				</ol>
			</li>
			<li>
				<span class="spec">Делаем пагинацию главной страницы и отображения категорий</span>
				<ol>
					<li>
						View.py
						<pre>
from django.core.paginator import Paginator

# домашняя страница
def show_home(request):
    cars = Car.objects.all()

    paginator = Paginator(cars, 4)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    context = {
        'page_obj': page_obj,
        'cat_selected': 'all',
        'all_categories': all_categories,
        'title': 'Все модели',
        # 'cars': cars,
    }
    return render(request, 'blog/home.html', context=context)

# вывод записей Car - по выбранной категории
def show_categories(request, cat_slug):  # в скобках то что получаем в запросе
    # cat__slug - обращение из модели Car - к полю slug модели Category
    # cat_slug - значение поля slug - выбранной категории - см get_abs_url Category
    cars = Car.objects.filter(cat__slug=cat_slug)
    category_1 = Category.objects.get(slug=cat_slug)

    paginator = Paginator(cars, 2)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    context = {
        'page_obj': page_obj,
        'all_categories': all_categories,
        'cat_selected': cat_slug,
        'title': f'Производство: {category_1}',
        # 'cars': cars,
    }
    return render(request, 'blog/home.html', context=context)</pre>
					</li>
					<li>
						В шаблоне home.html - для отображения кнопок (делал bootstrap) - из коробки html тоже приемлимый вид
						<pre>
	&lt;div class="pagination justify-content-center">
    	&lt;span class="step-links">
    		&lt;ul class="pagination justify-content-center ">
    	
	    	{% if page_obj.has_previous %}
	    		&lt;&lt;li>
	            	&lt;&lt;a class="page-link bg-dark"  href="?page=1">&laquo; Первая&lt;&lt;/a>
	            &lt;&lt;/li>
	            &lt;&lt;li>
	            	&lt;&lt;a class="page-link bg-dark" href="?page={{ page_obj.previous_page_number }}">Предыдущая&lt;&lt;/a>
	            &lt;&lt;/li>
	        {% endif %}&lt;&lt;

	        &lt;li class="page-item disabled">
		        &lt;span class="page-link bg-dark">
		            Страница {{ page_obj.number }} из {{ page_obj.paginator.num_pages }}.
		        &lt;/span>
		    &lt;/l&lt;i>


	        {% if page_obj.has_next %}
	        	&lt;li>
	            	&lt;a class="page-link bg-dark" href="?page={{ page_obj.next_page_number }}">Следующая&lt;/a>
	            &lt;/li>&lt;
	            &lt;li>	
	            	&lt;a class="page-link bg-dark" href="?page={{ page_obj.paginator.num_pages }}">Последняя &raquo;&lt;/a>
	            &lt;/li>
	        {% endif %}
	        &lt;/ul>
    	&lt;/span>
    &lt;/div></pre>
				</ol>
			</li>
			<li>
				<span class="spec">Регистрация пользователя</span>
			</li>
			<li>
				В base.html - делаю ссылки для регистрация и войти
				<pre>
&lt;span class="navbar-text">
	&lt;a class="nav-link active" href="{% url 'register' %}">Регистрация&lt;/a> | 
	&lt;a class="nav-link active" href="{% url 'login' %}">Войти&lt;/a>
&lt;/span></pre>
			</li>
			<li>
				Прописываем марщруты в urls.py
				<li>
path('', show_login, name='login'),
path('', RegisterUser.as_view(), name='register'),
				</li>
			</li>
			<li>
				Создаю шаблоны login.html +  register.html - в них наследуюсь от base.html
				<pre>
{% extends 'blog/base.html' %} 

{% block title %} 
	Регистрация пользователя
{% endblock %}

{% block content %}

Форма для регистрации

{% endblock %}</pre>
				Аналогично для формы аутентификации
			</li>
			<li>
				Создам класс Mixin - для формирования первоначальных контектсов всех функций представления, в будущем перейду на них
			</li>
			<li>
				в avtoblog-project/blog создам utils.py - и добавим Mixin для формирования общего контекста
				<pre>
from blog.models import Category  # наша модель

all_categories = Category.objects.all()  # общий для всех список в sidebar


# общий класс
class DataMixin:
    # формируем общий контекст
    def get_user_context(self, **kwargs):
        # контекст будет словарём {'ключ':'значение'}
        context = kwargs
        # в словарь контекст добавили { 'all_categories' : Category.objects.all()}
        context['all_categories'] = all_categories
        # if 'cat_selected'
        return context</pre>
			</li>
			<li>
				Деляю класс представления для регистрации пользователя во views.py - перед этим импортировав всё что нужно
				<pre>
from django.views.generic import CreateView  # класс представления
from django.contrib.auth.forms import UserCreationForm  # форма django
from django.urls import reverse_lazy  # перенаправление на маршрут
from .utils import DataMixin  # наш Mixin


# класс представления RegisterUser
class RegisterUser(DataMixin, CreateView):
    form_class = UserCreationForm  # стандартная форма django
    template_name = 'blog/register.html'  # шаблон куда передаём
    success_url = reverse_lazy('login')  # При успешной регистрации направит path 'login'

    # формируем полный словарь context
    def get_context_data(self, object_list=None, **kwargs):
        # берём контекст из этого класса представления
        context = super().get_context_data(**kwargs)  # на данный момент form_class
        # берём контекст из DataMixin - и в него сразу добавляем title
        c_def = self.get_user_context(title='Регистрация')
        # передаём в шаблон общий контекст (RegisterUser + DataMixin)
        return {**context, **c_def}
        # или
        # return dict(list(context.items()) + list(c_def.items()))</pre>
			</li>
			<li>
				В шаблоне register.html - выведем стандартную форму django
				<pre>
{% block content %}

&lt;form method="post">
	{% csrf_token %}
	{{ form.as_p }}
	&lt;button type="submit">
		Зарегистрироваться
	&lt;/button>
&lt;/form>	
{% endblock %}</pre>
				Форма уже рабочая но фид у неё так себе
			</li>
			<li>
				Создадим свою форму (на основе стандартной просто изменим вид, отцентруем и так далее).
				<br>Формы будем создавать в отдельном файле - создаём blog/forms.py
			</li>
			<li>
				В forms.py - создаём свою форму на основе стандартной формы django - UserCreationForm
				<pre>
from django.contrib.auth.forms import UserCreationForm  # стандартная форма django
from django.contrib.auth.models import User  # из djando достаём записи модели User (все пользователи)
from django import forms  # модуль forms - для написания полей


# форма регистрации
class RegisterUserForm(UserCreationForm):
    # прописываем все необходимые поля, самостоятельно
    # тк django в meta их не видит почему-то без этого
    # название полей можно посмотреть в коде html - или в документации
    username = forms.CharField(label='Логин', widget=forms.TextInput(attrs={'class': 'form-input'}))
    email = forms.EmailField(label='Email', widget=forms.EmailInput(attrs={'class': 'form-input'}))
    password1 = forms.CharField(label='Пароль', widget=forms.PasswordInput(attrs={'class': 'form-input'}))
    password2 = forms.CharField(label='Повтор пароля', widget=forms.PasswordInput(attrs={'class': 'form-input'}))

    class Meta:
        model = User  # связываемся с моделью User
        # отображаем поля модели User
        fields = ('username', 'email', 'password1', 'password2')</pre>
			</li>
			<li>
				Во views.py изменим  в классе представление связь с формой - class RegisterUser - form_class = RegisterUserForm
				<pre>
from .forms import *  # наш forms.py

form_class = RegisterUserForm  # наша форма из forms.py</pre>
				Форма работает, но вид можно ещё улучшить
			</li>
			<li>
				В styles.css  - добавим стилей form-label/form-input/form-error/form-button
				<br>Отступы, размеры, цыет, выравнивание а такдалее
			</li>
			<li>
				Улучшаем вид в register.html - будем выводить все поля через цикл for
				<pre>
{% for f in form %}
&lt;p>
&lt;label class="form-label" for="{{ f.id_for_label }}">{{f.label}}: &lt;/label>{{ f }}
&lt;/p>
&lt;div class="form-error">{{ f.errors }}&lt;/div>
{% endfor %}</pre>
				Форма рабочая, с подобающим видом
			</li>
			<li>
				<span class="spec">Делаю авторизацию пользователя</span>
			</li>
			<li>
				Сразу создам свою форму аутентификации в forms.py на основе стандартной формы AuthenticationForm, пропишем 2 поля логин и пароль
				<pre>
from django.contrib.auth.forms import AuthenticationForm  # стандартные формы

# Форма авторизации
class LoginUserForm(AuthenticationForm):  # AuthenticationForm - стандартная форма
    username = forms.CharField(label='Логин', widget=forms.TextInput(attrs={'class': 'form.input'}))
    password = forms.CharField(label='Пароль', widget=forms.PasswordInput(attrs={'class': 'form.input'}))</pre>
			</li>
			<li>
				Во views.py - сделю класс представления авторизацтт
				<pre>
from django.contrib.auth.views import LoginView  # стандартная логика авторизации

# Класс представления формы авторизации
# Логика работы базового класса LoginView + сама форма LoginUserForm
class LoginUser(DataMixin, LoginView):
    form_class = LoginUserForm  # наша форма из forms.py
    template_name = 'blog/login.html'  # шаблон
    
    # формируем полный контекст
    def get_context_data(self, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)  # распаковываем изначальный контекст
        c_def = self.get_user_context()  # переменная контекста DataMixin
        return {**context, **c_def}  # в шаблон передаём полный контекст</pre>
			</li>
			<li>
				Поправляем маршрут login - ссылкаемся на класс представления LoginUser
				<br>В urls.py
				<pre>path('login/', LoginUser.as_view(), name='login'),</pre>
			</li>
			<li>
				Выводим в шаблон login.html - нашу форму, По сути можно скопировать код из register.html - только изменить имя кнопки, так же добавил ошибки сверху и снизу
				<pre>
&lt;form method="post">
	{% csrf_token %}

	<!-- ошибки если неверный логин и пароль -->
	&lt;div class="form-error">
		{{ form.non_field_errors }}
	&lt;/div>
	&lt;
	{% for f in form %}
	&lt;p>
	&lt;label class="form-label" for="{{ f.id_for_label }}">{{f.label}}: &lt;/label>{{ f }}
	&lt;/p>
	&lt;div class="form-error">{{ f.errors }}&lt;/div>
&lt;
	<!-- ошибки если возникнут -->
	&lt;div class="form-error">
		{{ f.errors }}
	&lt;/div>


	{% endfor %}

	&lt;button type="submit" class="btn btn-primary btn-lg">
		Войти
	&lt;/button>
&lt;/form></pre>
			</li>
			<li>
				<span class="spec">Страница аккаунта - сделаю позже!</span>
			</li>
			<li>
				Стандартно после залогинивания - пренаправляет по url - http://127.0.0.1:8000/accounts/profile/ - Но такого маршрута нету, по этому будем перенаправлять на домашнюю страницу
				<br>
				Для этого в views.py - в классе представления LoginUser - в самом инзу добавим метод для перенаправление при успешной авторизации
				<pre>
def get_success_url(self):
    return reverse_lazy('home')  # при успешном входе перенаправит домой</pre>
    			<br><strong>Второй вариант сделать перенаправление через settings.py</strong>
    			<pre>LOGIN_REDIRECT_URL = '/'  # При успешной аутентификации - перенаправление на home-page</pre>
			</li>
			<li>
				Для залогиненого пользователя, вместо регистрации и войти в навбар будем отображать - имя пользователя и выйти
				<br>Редактируем base.html - добавляя конструкцию if

				<pre>
	      	&lt;span class="nav-text text-light">

	      		<!-- если пользователь залогиненый -->
	      		{% if request.user.is_authenticated %}
	      		&lt;span class="text-info" style="letter-spacing: .2em; font-size: 30px;">{{ user.username }} &lt;/span> &lt;a class="nav-link active text-warning" href="{% url 'logout' %}">Выйти&lt;/a>

	      		<!-- иначе пользователь незалогинен -->
	      		{% else %}
		      	&lt;a class="nav-link active" href="{% url 'register' %}">Регистрация&lt;/a>
		      	&lt;a class="nav-link active" href="{% url 'login' %}">Войти&lt;/a>
		      	{% endif %}

	      	&lt;/span></pre>
			</li>
			<li>
				Делаем маршрут и функцию представляния для logout
				<br>Во views.py
				<pre>
from django.contrib.auth import logout  # выход пользователя django
from django.shortcuts import ..., redirect

# выход из аккаунта
def logout_user(request):
    logout(request)  # стандартный выход пользователя
    return redirect('login')  # перенаправляет залогиниться</pre>
				<br>
				В urls.py
				<pre>path('logout/', logout_user, name='logout'),</pre>
				<br>
				<span class="spec">redirect делает перенаправление по сформированному маршруту, а reverse только формирует маршрут (без перенаправления)</span>
			</li>
			<li>
				Добавлю вункцию чтобы при успешной регистрации  - пользователь сразу был залогинен
				<br>Для этого во views.py - в классе представления RegisterUser - добавим метод form_valig
				<pre>
from django.contrib.auth import logout, login  # выход/вход пользователя django

# автозалогинивание при успешной регистрации
def form_valid(self, form):
    user = form.save()  # сохраняем данные пользователя в БД (User)
    login(self.request, user)  # авторизовывает пользователя
    return redirect('home')  # перенаправляет домой</pre>
			</li>

&lt;



http://127.0.0.1:8000/car/toyota-supra-a80/

germany


		</ol><!-- общий список -->
	</div><!-- container-md all -->
&lt; &lt; &lt;

# Ctrl + Alt + L 


<!-- JS Bootstrap 5 -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-gtEjrD/SeCtmISkJkNUaaKMoLD0//ElJ19smozuHV6z3Iehds+3Ulb9Bn9Plx0x4" crossorigin="anonymous"></script>


</body>
</html>