<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- css bootstrap 5 -->
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x" crossorigin="anonymous">

	<title>Автоблог - конспект работы</title>

	<style type="text/css">
		
		pre{
			color: black;
			background: #ffe2e2;
			margin-right: 30px;
			margin-left: 15px;
			margin-bottom: 2px;
			margin-top: 5px;
		}
		
		.all{
			background: #003802;
			color: white;

		}
		
		body{
			background: #c1ffcb;
		}
		
		.spec {
			font-size: 18px;
			letter-spacing: .2em;
			font-weight: 500;
/*			text-transform: uppercase;*/
			color: #ff7575;
			margin-top: 15px;
			margin-bottom: 2px;
		}

		.title_text {
			letter-spacing: .1em;
			font-weight: 500;
			color: #f2cb71;
			font-size: 25px;

		}

	</style>


&lt; &lt; &lt;
</head>


<body>
<!-- 	<p><a href="https://www.youtube.com/@selfedu_rus">selfedu</a></p>
	<p><a href="https://www.youtube.com/watch?v=FyTL1bnUx5I&list=PLA0M1Bcd0w8xO_39zZll2u1lz_Q-Mwn1F">Django 3 для Python(плейлист)</a></p> -->
	<p><a href="https://proproprogs.ru/django">https://proproprogs.ru/django</a></p>
	<p><a href="https://django.fun/ru/articles/tutorials/">Статьи о Django</a></p>
	<p><a href="https://habr.com/ru/post/514348/">Шесть Python-пакетов, которые рекомендуется использовать в каждом веб-приложении на Django</a></p>
	<p><a href="https://django.fun/ru/docs/">Документация по фреймворку и библиотекам Django</a></p>
	<p><a href="https://translated.turbopages.org/proxy_u/en-ru.ru.5b0ed4c9-6378aa3f-3f4ce05c-74722d776562/https/hackr.io/blog/top-django-interview-questions-and-answers">50 лучших вопросов и ответов для интервью Django на 2022 год</a></p>
	<p><a href="https://pypi.org/">pypi.org</a></p>


	<div class="container-md all"><!-- container-md all ОБЩИЙ -->
		<h1 class="title_text border">Автоблог</h1><br>

		<!-- <img src="images\avtoblog\host.jpg" class="img-fluid"><br> -->



		<ol><!-- общий список -->


			<li>
				<span class="title_text">Старт проекта</span>

				<ol>

					<li>
						Сделал окружение
					</li>
					<li>
						Создаём Новый проект в PyCharm - C:\Хранилище\IT\IT Projects\avtoblog-project
						<br>Окружение venv_2022 - указывал путь к venv_2022\Scripts\python.exe
					</li>
					<li>
						Внутри окружения уже есть большинство пакетов которые будут необходимы:
						<br>-Pillow - для работы с изображениями
						<br>-django-crycpy-forms - использовал в eccomerce
						<br>-Django 4.1.3
						<br>-psycopg2 - для работы с PostgreSQL
						<br>-virtuslenv
						<br>-pip
						<br><br>Консоль работает, должно быть всё норм
					</li>
					<li>
						Стартую проект django
						<pre>django-admin startproject avtoblog</pre>
						<br>В ручную подкорректировал папки в проекте:
						<br>-IT Projects\avtoblog-project\avtoblog (manage.py в avtoblog, .idea - в avtoblog-project)
						<br>-В Pycharm - папке avtoblog-project - присвоил source root
					</li>
				</ol>
			</li>
--------------------------------------------------
			<li>
				<span class="title_text">Git, .gitignore, База данных, настройка времени языка</span>
				<ol>

					<li>
						Из <a href="www.toptal.com">www.toptal.com</a> генерируем .gitignore  - и помещаем в avtoblog-project
						<br>Раскомментируй .idea/ поставь сверху
					</li>
					<li>
						Создаём Базу данных DB - Для проекта в SQL Shell (PostgreSQL)
						<pre>
Server [localhost]:
Database [postgres]:
Port [5432]:
Username [postgres]:
Пароль пользователя postgres:blog1234

psql \! chcp 1251  # для отображении кириллицы
\l смортрим список всех DB
CREATE DATABASE avtoblogdb;  # создали базу данных - avtoblogdb
-->CREATE DATABASE
\l - смотрим DB создана
				</pre>
					</li>
					<li>
						Сразу привыязваем наш проект к базеданных postgreSQL - avtoblogdb - в settings.py
						<pre>
DATABASES = {
    'default': {
        # 'ENGINE': 'django.db.backends.sqlite3',  # стандартная БД
        # 'NAME': BASE_DIR / 'db.sqlite3',  # стандартная БД
        'ENGINE': 'django.db.backends.postgresql',  # БД PostrgeSQL
        'NAME': 'avtoblogdb',  # Имя нашей БД
        'USER': 'postgres',  # пользователь postgres - который создал БД
        'PASSWORD': 'blog1234',  # пароль в PostgreSQL, для пользователя postgres
        'HOST': '127.0.0.1',  # либо просто - 'localhost'
        'PORT': '5432',  # стандартный порт
    }
}</pre>
					</li>
					<li>
						В settings.py сразу настроим часовой пояс и русский язык в админке
						<pre>
LANGUAGE_CODE = 'ru-Ru'  # русский язык в admin

TIME_ZONE = 'Europe/Moscow'  # время по МСК</pre>
					</li>
					<li>
						На github - создадим репозиторий - avtoblog
					</li>
					<li>
						Инициализируем git репозиторий на PC, и запушим первый коммит
						<pre>
git –v  # посмотреть версию git
git init  # инициализируем git репозиторикй- папку на pc
git status  # смотрим какие файлы не отслеживаются на данный момент
git add .  # добавляем все файлы
git status  # смотрим что теперь всё отслеживается
git commit -m "имя коммита(что сделали/стадия)"  # создаём коммит
git remote add origin  - https://github.com/Mello134/репозиторий.git  # туда будем загружать
git branch -M main
git push -u origin main  # отправили на github - в репозитор</pre>
					</li>

				</ol>
			</li>

--------------------------------------------------
			<li>
				<span class="title_text"> Создание и регистрация приложения<br>Расшарение маршрутов urls.py [ inclide() ]</span>
				<ol>

				
					<li>
						Создаём приложение blog  в avtoblog-project
						<pre>python manage.py startapp blog</pre>
					</li>
					<li>
						Регистрируем приложение blog в settings.py - INSTALLED_APPS. Информацию берём из blog/apps.py
						<pre>'blog.apps.BlogConfig',  # наше приложение blog</pre>
					</li>
					<li>
						Создадим urls.py в blog в него сразу импортируем path и views.py
						<pre>
from django.urls import path
from .views import *</pre>
						Создаём свой список urlpatterns, запишим первый путь
						<pre>
urlpatterns = [
    path('', home, name='home'),
]</pre>
					</li>
						Расширим основной avtoblog/urls.py  + avtoblog/urls.py (include)
						<br>Для этого добавляем маршрут к urls.py из blog  + имортируем include()
						<pre>
from django.urls import path, include

path('', include('blog.urls')),  # путь к путям приложения blog
				</pre>

				</ol>
			</li>

			
--------------------------------------------------
			<li>
				<span class="title_text">Первые функции представления (заглушки) - первые маршруты, динамические маршруты по id</span>
				<ol>

					<li>
						Создадим первую функцию представления во blog/views.py
						<pre>
from django.http import HttpResponse
						</pre>
					</li>
					<li>
						Добавим две функции представления категорий и отдельной машины. В blog/views.py
						<pre>
# страница категорий
def categories(request):
    return HttpResponse('Страница категорий')


# страница отдельной машины
def car(request):
    return HttpResponse('Страница отдельной машины')</pre>
					</li>
					<li>
						Сразу пропишем маршруты к ним в url.py
						<pre>
path('category/', categories, name="category"),
path('car/', car, name='car'),</pre>
					</li>
					<li>
						Увеличим функции представления и маршруты catregory/1-2-3.. и car/1-2-3
						<br>Во views.py
						<pre>
# страница категорий
def categories(request, category_id):  # в скобках то что получаем в запросе
    # в return то что отдаём для отображения
    return HttpResponse(f'&lt;h1>Страница категорий&lt;/h1>&lt;p>№ {category_id}&lt;/p>')


# страница отдельной машины
def car(request, car_id):
    return HttpResponse(f'&lt;h1>Страница отдельной машины&lt;/h1>&lt;p>№ { car_id }&lt;/p>')</pre>
						<br>В urls.py
						<pre>
path('category/&lt;int:category_id>/', categories, name="category"),
path('car/&lt;int:car_id>/', car, name='car'),</pre>
					</li>
					<li>
						<span class="spec">Искочения и 404 не далал на данном этапе. П33 КОНСПЕКТА SELFEDU</span>
					</li>

				</ol>
			</li>


--------------------------------------------------
			
			<li>
				<span class="title_text">Модели, миграции, суперпользователь, регистрация моделей в админке</span>
				<ol>

					<li>
						Пропишим 2 модели Сar, Category в models.py
						<pre>
class Car(models.Model):
    # Id прописывать не нужно - Model Это делает автоматически
    title = models.CharField(max_length=255, verbose_name='Заголовок')  # длина 255 символов
    # unique=True - поле уникально, db_index=True - индексируемое (для ускорения поиска, verbose_name - отображение в адм.)
    slug = models.SlugField(max_length=255, unique=True, db_index=True, verbose_name='URL')
    content = models.TextField(blank=True, verbose_name='Текст статьи')  # текстовое поле без ограничений, blank=True - поле может быть пустым
    tth = models.TextField(blank=True, verbose_name='Технические характеристики авто')
    photo = models.ImageField(upload_to='photos/%Y/%m', verbose_name='Фото')  # загружать будем в photos/год/месяц
    time_create = models.DateTimeField(auto_now_add=True, verbose_name='Время создания')
    time_update = models.DateTimeField(auto_now=True, verbose_name='Время изменения')
    is_published = models.BooleanField(default=True, verbose_name='Публикация')  # default=True
    # cat_id - id добавится автоматом, ForeignKey - связь Car - c Category
    cat = models.ForeignKey('Category', on_delete=models.PROTECT, verbose_name='Категории')


class Category(models.Model):
    # db_index - для того чтобы поле было индексированным, поиск по небу будет происходить быстрей
    name = models.CharField(max_length=100, db_index=True, verbose_name='Категория')
    slug = models.SlugField(max_length=255, unique=True, db_index=True, verbose_name='URL')</pre>
					</li>
					<li>
						Сделаем первую миграцию и применим её - без этого путь admin не работает!
						<pre>
python manage.py makemigrations
python manage.py migrate</pre>
					</li>
					<li>
						Создадим superuser
						<pre>
python manage.py createsuperuser  # создаём суперюзера

Имя пользователя: Mello
Адрес электронной почты: elproject220@yandex.ru
Password:blog1234
Password (again):blog1234
Superuser created successfully.  # пользователь создан</pre>
					</li>
					<li>
						Зарегистрируем наши модели в админке. в blog/admin.py
						<pre>
admin.site.register(Car)
admin.site.register(Category)</pre>
					</li>
				</ol>
			</li>


--------------------------------------------------
			<li>
				<span class="title_text">MEDIA_ROOT, MEDIA_URL, STATIC_URL, STATIC_ROOT, STATICFILES_DIRS, if settings.DEBUG:</span>
			
				<ol>

					<li>
						Настраиваем MEDIA_ROOT - MEDIA_URL в settings.py
						<pre>
MEDIA_ROOT = BASE_DIR / 'media'  # будет загружать медиа в папку media
MEDIA_URL = '/media/'  # добавили url - будет отображаться в браузере</pre>
			</li>
					<li>
						Для эмуляции работы сервер для получения ранее загруженных файлов, и передачи их нашему приложению.
						<br>В avtoblog/urls.py добавим маршруты к статическим файлам и к медиафайлам
						<pre>
from django.conf.urls.static import static  # пути к статическим файлам
from . import settings  # для MEDIA_URL MEDIA_ROOT

if settings.DEBUG:
    # к путям добавляем путь к статическим данным, графическим данным
    # на реальных серверах обычно это не используется
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)</pre>
					</li>
					<li>
						Настраиваем STATIC_URL STATIC_ROOT STATICFILES_DIRS
						<br>-STATIC_URL - префикс URL-адреса
						<br>-STATIC_ROOT - путь к общей статической папке, используемый реальым веб-сервером
						<br>-STATICFILES_DIRS - список дополнительных(нестандартных) путей к статическим файлам, используемых для сбора и для рещима отладки
						<br><br>в settings.py
						<pre>
STATIC_URL = 'static/'  # стандартно
# STATIC_ROOT добавили, в эту папку при collectstatic - django перемещает все статические файлы
# путь avtoblog-project/avtoblog - из этой папке, статический файлы будут пользоваться в режиме эксплуатации сайта на сервере
STATIC_ROOT = BASE_DIR / 'static'
# добавили пустой список, список нестандартных путей, пока у нас нет, оставим пустым
STATICFILES_DIRS = []</pre>
					</li>
				</ol>
			</li>


--------------------------------------------------
			
			<li>
				<span class="title_text">Папки статических фалов, первые шаблоны, base.html, функции представления, context, {% load static %}, {% extends 'blog/base.html' %}, Bootstrap5</span>

				<ol>


					<li>
						Создам вручную папку для статических фалов. В blog:
						<br>blog/static
						<br>blog/static/blog
						<br>blog/static/blog/css 
						<br>blog/static/blog/images - туда буду загружать иконки
						<br>blog/static/blog/js
					</li>
					<li>
						Создам файл стилей styles.css - в blog/static/blog/css 
					</li>
					<li>
						Создам вручную папку для шаблонов фалов. В blog:
						<br>blog/templates
						<br>blog/templates/blog
					</li>
					<li>
						Создам base.html - в blog/templates/blog
					</li>
					<li>
						Привяжу функцию представления def home - к base.html, в vievs.py
						<pre>
# домашняя страница
def home(request):
    context = {
        'title': 'Базовый шаблон',
        'ключ 2': 'Значение2',        
    }
    return render(request, 'blog/base.html', context=context)</pre>
					</li>
					<li>
						В base.html  - чтото напишу для проверки
						<pre>
&lt;!DOCTYPE html>
&lt;html>
&lt;head>
	&lt;meta charset="utf-8">
	&lt;meta name="viewport" content="width=device-width, initial-scale=1">
	&lt;title>{{ title }}&lt;/title>
&lt;/head>
&lt;body>
	&lt;h1>{{ title }}&lt;/h1>
&lt;/body>
&lt;/html></pre>
					</li>
					<li>
						Далее верстаю страницу base.html, Добавляю bootstrap, ссылку на css, подкгружаю статические файлы - В base.html - будет navbar, sidebar, footer
				<pre>
---в самом верху---
{% load static %}

---до title, в head---
ссыылка BOOTSTRAP CSS -->
ссыылка к нашему css файлу -->
ссылка для отображении иконки в браузере (где title) -->

---в title---
{% block title %} {% endblock %}

---до закрытия body---
ссыылка BOOTSTRAP JS --></pre>
					</li>
					<li>
						Сделал навбар, сайдбар и футер в base.html - указал промежуток {% block content %}
					</li>
					<li>
						Создал home.html в нём унаследовался от base.html - указал block kontent с минимальным содержимым
						<pre>
{% extends 'blog/base.html' %} 

{% block title %} 
	{{ title }}
{% endblock %}

{% block content %}
&lt;h1>{{ title }}&lt;/h1>
&lt;p>{{ key_2 }}&lt;p>
{% endblock %}</pre>
					</li>
					<li>
						Подгорректировал def home во views.py
						<pre>
# домашняя страница
def home(request):
    context = {
        'title': 'Главная страница',
        'key_2': 'Значение2',
    }
    return render(request, 'blog/home.html', context=context)</pre>
					</li>
				</ol>
			</li>


--------------------------------------------------
			<li>
				<span class="title_text">Методы __str__, class Meta:</span>

				<ol>


					<li>
						Пропишим метод __str__ в моделях Car, Category - чтобы при обращении к категории или посту нам отображался title Car, name - Category
						<pre>
--class Car--
# с помощью метода запись нашего класса будет выводиться по её заголовку
def __str__(self):
    return self.title

--class Category--
# будем обращаться к категории по полю name
def __str__(self):
    return self.name</pre>
					</li>
					<li>
						В модели дпбавим класс Meta - для нормального отображенияв админ панели и сортировки
						<pre>
--class Car--
class Meta:
    verbose_name = "Автомобиль"
    verbose_name_plural = "Автомобили"
    ordering = ['-time_create', 'title']  # сортировка, сначала по дате создания, потом по имени

--class Category--
class Meta:
    verbose_name = "Категория"
    verbose_name_plural = "Категории"
    ordering = ['id']  # сортировка, сначала по id</pre>
					</li>
				</ol>
			</li>


--------------------------------------------------
			<li>
				<span class="title_text">Отображение в админке/настройка</span>
				<ol>


					<li>
						Отобразим на нормальном языке наше приложение в админке
						<br>В blog/apps.py - class BlogConfig - добавим 1 поле
						<pre>verbose_name = 'Авто блог'  # отображение названия приложения</pre>
					</li>
					<li>
						Добавим пару записей в категорию и посты
					</li>
					<li>
						Для отображения столбцов в админ панеле в admin.py добавим классы, и опишем их
						<pre>
class CarAdmin(admin.ModelAdmin):
    # список отображаемых столбцов в админ-панели
    list_display = ('id', 'title', 'time_create', 'photo', 'is_published')
    prepopulated_fields = {'slug': ('title',)}  # автозаполнение слага по имени поста
    # список полей на которые можно кликнуть - для редактирования
    list_display_links = ('id', 'title')
    # список полей - ко которым можно вести поиск
    search_fields = ('title', 'content')
    # редактирование поля публикации - в списке - в админке
    list_editable = ('is_published',)  # запятая - если 1 поле!
    # фильтр по полям - публикация, время изменения.
    list_filter = ('is_published', 'time_create')</pre>
		    			<pre>
class CategoryAdmin(admin.ModelAdmin):
    prepopulated_fields = {'slug': ('name',)}  # автозаполнение слага по имени категории
    list_display = ('id', 'name')
    list_display_links = ('id', 'name')
    search_fields = ('name',)  # ЗАПЯТАЯ В КОНЦЕ- при одном поле</pre>
		    			<pre>
admin.site.register(Car, CarAdmin)
admin.site.register(Category, CategoryAdmin)</pre>
					</li>
					<li>
						<span class="spec">get_html_photo</span><br>
						Для отображения миниатюр фото вместо ссылки на фото добавим метод get_html_photo (назвали сами) - там же в class CarAdmin(admin.ModelAdmin):
						<pre>
from django.utils.safestring import mark_safe

list_display = ('id', 'title', 'time_create', 'get_html_photo', 'is_published')

# отображение миниатюр фото в админке
    def get_html_photo(self, object):
        if object.photo:  # если фото есть
            # mark_safe - не экранирует теги
            return mark_safe(f"}&lt;img src='{object.photo.url}' width=50>")</pre>
					</li>
				</ol>
			</li>


--------------------------------------------------
			<li>
				<span class="title_text">Страницы отдельного поста, get_absolute_url, динамический марщрут по слагу</span>
				<ol>

					<li>
						Создам шаблон для отображения 1 поста car.html, наследуюсь от base.html
						<pre>
{% extends 'blog/base.html' %} 

{% block title %} 
	{{ title }}
{% endblock %}

{% block content %}
&lt;h1>{{ title }}&lt;/h1><
{% endblock %}</pre>
					</li>
					<li>
						Изменю функцию представления def car
						<pre>
# страница отдельной машины
def car(request, car_slug):
    car = Car.objects.get(slug=car_slug)
    context = {
        'car': car,
    }
    return render(request, 'blog/car.html', context=context)</pre>
					</li>
					<li>
						Добавлю метод get_absolute_url - для Модели Car - для получения маршрута по слагу
						<pre>
from django.urls import reverse

# функция формирования маршрута к ссылке
def get_absolute_url(self):  # self - ссылка на один экземпляр(строку) таблицы модели
    # получаем путь('path name=car, 'car/&lt;slug:car_slug>/) = 127/car/supra)
    return reverse('car', kwargs={'car_slug': self.slug})  # self.slug - атрибут slug</pre>
			</li>
					<li>
						Изменяем маршрут в urls.py  name='car'
						<pre>
path('car/&lt;slug:car_slug>/', car, name='car'),</pre>
					</li>
					<li>
						Отображаю все поля на в шаблоне car.html
						<pre>
{% extends 'blog/base.html' %} 

{% block title %} 
	{{ car.title }}
{% endblock %}

{% block content %}

&lt;h1>{{ car.title }}&lt;/h1>
{% if post.photo %}
&lt;img src="{{ car.photo.url }}" class="img-fluid">&lt;br>
{% endif %}

&lt;p>Производство: {{ car.cat }}&lt;/p>
&lt;h3>Технические характеристики&lt;/h3>
&lt;p>{{ car.tth|linebreaks}}&lt;/p>&lt;br>
&lt;h3>Описание модели&lt;/h3>
&lt;p>{{ car.content|linebreaks }}&lt;/p>&lt;br>
&lt;p>Время обновления поста: {{ car.time_update }}&lt;/p>
&lt;
{% endblock %}</pre>
					</li>
					<li>
						Занимаемся оформлением шаблона car.html
					</li>
				</ol>
			</li>


--------------------------------------------------
			<li>
				<span class="title_text">
					Вывод всех записей и запизей по поределённому фильтру (категории) - в один шаблон, по разным функциям представления. (home / categories)
				</span>
				<ol>

					<li>
						Делаем отображение на главной странице (будут показывать все записи в модели)
					</li>
					<li>
						Во views.py - передаём в шаблон, все записи модели Car - в функции представления
						<pre>
# домашняя страница
def home(request):
    cars = Car.objects.all()
    context = {
        'title': 'Главная страница',
        'cars': cars,
    }
    return render(request, 'blog/home.html', context=context)</pre>
					</li>
					<li>
						Выводим все записи в шаблоне home.html
						<br>Оформляем шаблон home.html
					</li>
					<li>
						Пишем get_absolute_url - Category  - по слагу - в models.py
						<pre>
# функция формирования маршрута к ссылке
def get_absolute_url(self):
    return reverse('category', kwargs={'cat_slug': self.slug})</pre>
					</li>
					<li>
						Меняем маршрут по слагу urls.py
						<pre>path('category/&lt;slug:cat_slug>/', categories, name="category"),</pre>
					</li>
					<li>
						Меняем функцию представления views.py
						<pre>
# вывод записей Car - по выбранной категории
def categories(request, cat_slug):  # в скобках то что получаем в запросе
    # cat__slug - обращение из модели Car - к полю slug модели Category
    # cat_slug - значение поля slug - выбранной категории - см get_abs_url Category
    cars = Car.objects.filter(cat__slug=cat_slug)
    context = {
        'title': f'Производство: {category_1}',
        'cars': cars,
    }
    return render(request, 'blog/home.html', context=context)</pre>
					</li>
					<li>
						Выводим информацию в шаблон - в home.html
						<br>Ничего менять не нужно - будут отображаться только выбранные по категории авто
					</li>
				</ol>
			</li>	


--------------------------------------------------
			<li>
				<span class="title_text">Sidebar, cat_selected, Вывод категорий в панель навигации из бады данных</span>
				<ol>

					<li>
						Sidebar вывожу в отдельный шаблон sidebar.html
						<br>Просто удаляю всё из base.html - переношу в sidebar.html
						<br>В base.html - 1 строка в нужном месте
						<pre>{% include 'blog/sidebar.html' %}</pre>
					</li>
					<li>
						Выводим категории (ссылки в sidebar)
						views.py  - создаём переменную all_categories - выше всех функций представления
						<pre>
		all_categories = Category.objects.all()</pre>
						<br>В context - Каждой функции представления добавим all_categoryies - чтобы при "вызове" функции представления на html - страницах отображались категории
						<pre>
# домашняя страница
def show_home(request):
    cars = Car.objects.all()
    context = {
        'cat_selected': 'all',
        'all_categories': all_categories,
        'title': 'Все модели',
        'cars': cars,
    }
    return render(request, 'blog/home.html', context=context)


# вывод записей Car - по выбранной категории
def show_categories(request, cat_slug):  # в скобках то что получаем в запросе
    # cat__slug - обращение из модели Car - к полю slug модели Category
    # cat_slug - значение поля slug - выбранной категории - см get_abs_url Category
    cars = Car.objects.filter(cat__slug=cat_slug)
    category_1 = Category.objects.get(slug=cat_slug)
    context = {
        'all_categories': all_categories,
        'cat_selected': category_1.slug,
        'title': f'Производство: {category_1}',
        'cars': cars,
    }
    return render(request, 'blog/home.html', context=context)


# страница отдельной машины
def show_car(request, car_slug):
    car = Car.objects.get(slug=car_slug)
    context = {
        'all_categories': all_categories,
        'car': car,
    }
    return render(request, 'blog/car.html', context=context)</pre>
					</li>
					<li>
						В шаблоне sidebar.html  - сделаем вывод всех категорий, через цикл фор, так же добавим конструкцию if (сравниваем cat_selected) -  для отображания ссылки в виде активной ссылки либо в виде уже выбранной категории, причем будем сравнивать отдельно для кнопки  Все категории, и отдельно для остальных категорий
						<pre>
{% if cat_selected != 'all' %}
&lt;li class="nav-item">
&lt;a class="nav-link active" aria-current="page" href="{% url 'home' %}">Все категории&lt;/a>
&lt;/li>
{% else %}
&lt;li class="nav-item">
&lt;a class="nav-link disabled" href="{% url 'home' %}" tabindex="-1" aria-disabled="true">Все категории&lt;/a>
&lt;/li>
{% endif %}	


{% for category in all_categories %}


{% if cat_selected == category.slug %}
&lt;li class="nav-item">
&lt;a class="nav-link disabled" href="{{ category.get_absolute_url }}" tabindex="-1" aria-disabled="true">{{ category.name }}&lt;/a>
&lt;/li>
{% else %}
&lt;li class="nav-item">
&lt;a class="nav-link" href="{{ category.get_absolute_url }}">{{ category.name }}&lt;/a>
&lt;/li>
{% endif %}

{% endfor %}</pre>
					</li>
				</ol>
			</li>


--------------------------------------------------

			<li>
				<span class="title_text">Динамический маршрут с двумя слагами (cat_slug/car_clug)<br>Делаю путь для отдельной машины - http://127.0.0.1:8000/category/japan/nissan-silvia-s14</span>
				<ol>
					<li>
						Самое важное, models.py - class Car - get_absolute_url
						<pre>
def get_absolute_url(self):
    return reverse('car', kwargs={'cat_slug': self.cat.slug, 'car_slug': self.slug})</pre>
    					<strong>ПОРЯДОК cat_slug/car_slut - важен, точно такой эе как и в маршруте!</strong>
					</li>
					<li>
						Меняем маршрут urls.py
						<pre>path('category/&lt;slug:cat_slug>/&lt;slug:car_slug>', show_car, name='car'),</pre>
					</li>
					<li>
						Меняем функцию представления для отдельной машины
						<br><strong>на входе необходимо принимать как car_slug так и cat_slug</strong>
						<br>car/cat_slug - это ключи в get_absolute_url - models.py - class Car
						<pre>
# страница отдельной машины
def show_car(request, car_slug, cat_slug):
    car = Car.objects.get(slug=car_slug)
    context = {
        'all_categories': all_categories,
        'car': car,
    }
    return render(request, 'blog/car.html', context=context)</pre>
					</li>
					<li>
						Всё работает! Но последним штрихом def show_car - добавлю cat_selected в context
						<pre>
# страница отдельной машины
def show_car(request, car_slug, cat_slug):
    car = Car.objects.get(slug=car_slug)
    context = {
        'cat_selected': cat_slug,
        'all_categories': all_categories,
        'car': car,
    }
    return render(request, 'blog/car.html', context=context)</pre>
					</li>
				</ol>
			</li>

--------------------------------------------------		

			<li>
				<span class="title_text">Делаем пагинацию главной страницы и отображения категорий</span>
				<ol>
					<li>
						View.py
						<pre>
from django.core.paginator import Paginator

# домашняя страница
def show_home(request):
    cars = Car.objects.all()

    paginator = Paginator(cars, 4)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    context = {
        'page_obj': page_obj,
        'cat_selected': 'all',
        'all_categories': all_categories,
        'title': 'Все модели',
        # 'cars': cars,
    }
    return render(request, 'blog/home.html', context=context)

# вывод записей Car - по выбранной категории
def show_categories(request, cat_slug):  # в скобках то что получаем в запросе
    # cat__slug - обращение из модели Car - к полю slug модели Category
    # cat_slug - значение поля slug - выбранной категории - см get_abs_url Category
    cars = Car.objects.filter(cat__slug=cat_slug)
    category_1 = Category.objects.get(slug=cat_slug)

    paginator = Paginator(cars, 2)
    page_number = request.GET.get('page')
    page_obj = paginator.get_page(page_number)

    context = {
        'page_obj': page_obj,
        'all_categories': all_categories,
        'cat_selected': cat_slug,
        'title': f'Производство: {category_1}',
        # 'cars': cars,
    }
    return render(request, 'blog/home.html', context=context)</pre>
					</li>
					<li>
						В шаблоне home.html - для отображения кнопок (делал bootstrap) - из коробки html тоже приемлимый вид
						<pre>
	&lt;div class="pagination justify-content-center">
    	&lt;span class="step-links">
    		&lt;ul class="pagination justify-content-center ">
    	
	    	{% if page_obj.has_previous %}
	    		&lt;&lt;li>
	            	&lt;&lt;a class="page-link bg-dark"  href="?page=1">&laquo; Первая&lt;&lt;/a>
	            &lt;&lt;/li>
	            &lt;&lt;li>
	            	&lt;&lt;a class="page-link bg-dark" href="?page={{ page_obj.previous_page_number }}">Предыдущая&lt;&lt;/a>
	            &lt;&lt;/li>
	        {% endif %}&lt;&lt;

	        &lt;li class="page-item disabled">
		        &lt;span class="page-link bg-dark">
		            Страница {{ page_obj.number }} из {{ page_obj.paginator.num_pages }}.
		        &lt;/span>
		    &lt;/l&lt;i>


	        {% if page_obj.has_next %}
	        	&lt;li>
	            	&lt;a class="page-link bg-dark" href="?page={{ page_obj.next_page_number }}">Следующая&lt;/a>
	            &lt;/li>&lt;
	            &lt;li>	
	            	&lt;a class="page-link bg-dark" href="?page={{ page_obj.paginator.num_pages }}">Последняя &raquo;&lt;/a>
	            &lt;/li>
	        {% endif %}
	        &lt;/ul>
    	&lt;/span>
    &lt;/div></pre>
				</ol>
			</li>

--------------------------------------------------


			<li>
				<span class="title_text">Регистрация пользователя</span>
				<ol>
					<li>
						В base.html - делаю ссылки для регистрация и войти
						<pre>
&lt;span class="navbar-text">
	&lt;a class="nav-link active" href="{% url 'register' %}">Регистрация&lt;/a> | 
	&lt;a class="nav-link active" href="{% url 'login' %}">Войти&lt;/a>
&lt;/span></pre>
					</li>
					<li>
						Прописываем марщруты в urls.py
						<pre>
path('', show_login, name='login'),
path('', RegisterUser.as_view(), name='register'),</pre>
					</li>
					<li>
						Создаю шаблоны login.html +  register.html - в них наследуюсь от base.html
						<pre>
{% extends 'blog/base.html' %} 

{% block title %} 
	Регистрация пользователя
{% endblock %}

{% block content %}

Форма для регистрации

{% endblock %}</pre>
						Аналогично для формы аутентификации
					</li>
					<li>
						Создам класс Mixin - для формирования первоначальных контектсов всех функций представления, в будущем перейду на них
					</li>
					<li>
						в avtoblog-project/blog создам utils.py - и добавим Mixin для формирования общего контекста
						<pre>
from blog.models import Category  # наша модель

all_categories = Category.objects.all()  # общий для всех список в sidebar


# общий класс
class DataMixin:
    # формируем общий контекст
    def get_user_context(self, **kwargs):
        # контекст будет словарём {'ключ':'значение'}
        context = kwargs
        # в словарь контекст добавили { 'all_categories' : Category.objects.all()}
        context['all_categories'] = all_categories
        # if 'cat_selected'
        return context</pre>
					</li>
					<li>
						Деляю класс представления для регистрации пользователя во views.py - перед этим импортировав всё что нужно
						<pre>
from django.views.generic import CreateView  # класс представления
from django.contrib.auth.forms import UserCreationForm  # форма django
from django.urls import reverse_lazy  # перенаправление на маршрут
from .utils import DataMixin  # наш Mixin


# класс представления RegisterUser
class RegisterUser(DataMixin, CreateView):
    form_class = UserCreationForm  # стандартная форма django
    template_name = 'blog/register.html'  # шаблон куда передаём
    success_url = reverse_lazy('login')  # При успешной регистрации направит path 'login'

    # формируем полный словарь context
    def get_context_data(self, object_list=None, **kwargs):
        # берём контекст из этого класса представления
        context = super().get_context_data(**kwargs)  # на данный момент form_class
        # берём контекст из DataMixin - и в него сразу добавляем title
        c_def = self.get_user_context(title='Регистрация')
        # передаём в шаблон общий контекст (RegisterUser + DataMixin)
        return {**context, **c_def}
        # или
        # return dict(list(context.items()) + list(c_def.items()))</pre>
					</li>
					<li>
						В шаблоне register.html - выведем стандартную форму django
						<pre>
{% block content %}

&lt;form method="post">
	{% csrf_token %}
	{{ form.as_p }}
	&lt;button type="submit">
		Зарегистрироваться
	&lt;/button>
&lt;/form>	
{% endblock %}</pre>
						Форма уже рабочая но фид у неё так себе
					</li>
					<li>
						Создадим свою форму (на основе стандартной просто изменим вид, отцентруем и так далее).
						<br>Формы будем создавать в отдельном файле - создаём blog/forms.py
					</li>
					<li>
						В forms.py - создаём свою форму на основе стандартной формы django - UserCreationForm
						<pre>
from django.contrib.auth.forms import UserCreationForm  # стандартная форма django
from django.contrib.auth.models import User  # из djando достаём записи модели User (все пользователи)
from django import forms  # модуль forms - для написания полей


# форма регистрации
class RegisterUserForm(UserCreationForm):
    # прописываем все необходимые поля, самостоятельно
    # тк django в meta их не видит почему-то без этого
    # название полей можно посмотреть в коде html - или в документации
    username = forms.CharField(label='Логин', widget=forms.TextInput(attrs={'class': 'form-input'}))
    email = forms.EmailField(label='Email', widget=forms.EmailInput(attrs={'class': 'form-input'}))
    password1 = forms.CharField(label='Пароль', widget=forms.PasswordInput(attrs={'class': 'form-input'}))
    password2 = forms.CharField(label='Повтор пароля', widget=forms.PasswordInput(attrs={'class': 'form-input'}))

    class Meta:
        model = User  # связываемся с моделью User
        # отображаем поля модели User
        fields = ('username', 'email', 'password1', 'password2')</pre>
					</li>
					<li>
						Во views.py изменим  в классе представление связь с формой - class RegisterUser - form_class = RegisterUserForm
						<pre>
from .forms import *  # наш forms.py

form_class = RegisterUserForm  # наша форма из forms.py</pre>
						Форма работает, но вид можно ещё улучшить
					</li>
					<li>
						В styles.css  - добавим стилей form-label/form-input/form-error/form-button
						<br>Отступы, размеры, цыет, выравнивание а такдалее
					</li>
					<li>
						Улучшаем вид в register.html - будем выводить все поля через цикл for
						<pre>
{% for f in form %}
&lt;p>
&lt;label class="form-label" for="{{ f.id_for_label }}">{{f.label}}: &lt;/label>{{ f }}
&lt;/p>
&lt;div class="form-error">{{ f.errors }}&lt;/div>
{% endfor %}</pre>
						Форма рабочая, с подобающим видом
					</li>

				</ol>
			</li>

--------------------------------------------------

			<li>
				<span class="title_text">Делаю авторизацию пользователя (login+logout)</span>
				<ol>
					<li>
						Сразу создам свою форму аутентификации в forms.py на основе стандартной формы AuthenticationForm, пропишем 2 поля логин и пароль
						<pre>
from django.contrib.auth.forms import AuthenticationForm  # стандартные формы

# Форма авторизации
class LoginUserForm(AuthenticationForm):  # AuthenticationForm - стандартная форма
    username = forms.CharField(label='Логин', widget=forms.TextInput(attrs={'class': 'form.input'}))
    password = forms.CharField(label='Пароль', widget=forms.PasswordInput(attrs={'class': 'form.input'}))</pre>
					</li>
					<li>
						Во views.py - сделю класс представления авторизацтт
						<pre>
from django.contrib.auth.views import LoginView  # стандартная логика авторизации

# Класс представления формы авторизации
# Логика работы базового класса LoginView + сама форма LoginUserForm
class LoginUser(DataMixin, LoginView):
    form_class = LoginUserForm  # наша форма из forms.py
    template_name = 'blog/login.html'  # шаблон
    
    # формируем полный контекст
    def get_context_data(self, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)  # распаковываем изначальный контекст
        c_def = self.get_user_context()  # переменная контекста DataMixin
        return {**context, **c_def}  # в шаблон передаём полный контекст</pre>
					</li>
					<li>
						Поправляем маршрут login - ссылкаемся на класс представления LoginUser
						<br>В urls.py
						<pre>path('login/', LoginUser.as_view(), name='login'),</pre>
					</li>
					<li>
						Выводим в шаблон login.html - нашу форму, По сути можно скопировать код из register.html - только изменить имя кнопки, так же добавил ошибки сверху и снизу
						<pre>
&lt;form method="post">
	{% csrf_token %}

	<!-- ошибки если неверный логин и пароль -->
	&lt;div class="form-error">
		{{ form.non_field_errors }}
	&lt;/div>
	&lt;
	{% for f in form %}
	&lt;p>
	&lt;label class="form-label" for="{{ f.id_for_label }}">{{f.label}}: &lt;/label>{{ f }}
	&lt;/p>
	&lt;div class="form-error">{{ f.errors }}&lt;/div>
&lt;
	<!-- ошибки если возникнут -->
	&lt;div class="form-error">
		{{ f.errors }}
	&lt;/div>


	{% endfor %}

	&lt;button type="submit" class="btn btn-primary btn-lg">
		Войти
	&lt;/button>
&lt;/form></pre>
					</li>
					<li>
						<span class="spec">Страница аккаунта - сделаю позже!</span>
					</li>
					<li>
						Стандартно после залогинивания - пренаправляет по url - http://127.0.0.1:8000/accounts/profile/ - Но такого маршрута нету, по этому будем перенаправлять на домашнюю страницу
						<br>
						Для этого в views.py - в классе представления LoginUser - в самом инзу добавим метод для перенаправление при успешной авторизации
						<pre>
def get_success_url(self):
    return reverse_lazy('home')  # при успешном входе перенаправит домой</pre>
    			<br><strong>Второй вариант сделать перенаправление через settings.py</strong>
    			<pre>
LOGIN_REDIRECT_URL = '/'  # При успешной аутентификации - перенаправление на home-page
LOGOUT_REDIRECT_URL = 'home'  # При выходе из акккунта перенаправление домой
    			</pre>
					</li>
					<li>
						Для залогиненого пользователя, вместо регистрации и войти в навбар будем отображать - имя пользователя и выйти
						<br>Редактируем base.html - добавляя конструкцию if

						<pre>
  	&lt;span class="nav-text text-light">

  		<!-- если пользователь залогиненый -->
  		{% if request.user.is_authenticated %}
  		&lt;span class="text-info" style="letter-spacing: .2em; font-size: 30px;">{{ user.username }} &lt;/span> &lt;a class="nav-link active text-warning" href="{% url 'logout' %}">Выйти&lt;/a>

  		<!-- иначе пользователь незалогинен -->
  		{% else %}
      	&lt;a class="nav-link active" href="{% url 'register' %}">Регистрация&lt;/a>
      	&lt;a class="nav-link active" href="{% url 'login' %}">Войти&lt;/a>
      	{% endif %}

  	&lt;/span></pre>
					</li>
					<li>
						Делаем маршрут и функцию представляния для logout
						<br>Во views.py
						<pre>
from django.contrib.auth import logout  # выход пользователя django
from django.shortcuts import ..., redirect

# выход из аккаунта
def logout_user(request):
    logout(request)  # стандартный выход пользователя
    return redirect('login')  # перенаправляет залогиниться</pre>
						<br>
						В urls.py
						<pre>path('logout/', logout_user, name='logout'),</pre>
						<br>
						<span class="spec">redirect делает перенаправление по сформированному маршруту, а reverse только формирует маршрут (без перенаправления)</span>
					</li>
					<li>
						Добавлю вункцию чтобы при успешной регистрации  - пользователь сразу был залогинен
						<br>Для этого во views.py - в классе представления RegisterUser - добавим метод form_valig
						<pre>
from django.contrib.auth import logout, login  # выход/вход пользователя django

# автозалогинивание при успешной регистрации
def form_valid(self, form):
    user = form.save()  # сохраняем данные пользователя в БД (User)
    login(self.request, user)  # авторизовывает пользователя
    return redirect('home')  # перенаправляет домой</pre>
					</li>
					<li>
						Немного подкорректирую шаблон login.html
					</li>
				</ol>
			</li>

--------------------------------------------------

			<li>
				<span class="title_text">Вынесу аутентификацию пользователей в отдельное приложение</span>
			<ol>
					<li>
						В двух словах, нежны свои urls.py, forms.py, templates, vievs.py
					</li>
					<li>
						Создам новой приложение account.
						<pre>python manage.py startapp account</pre>
					</li>
					<li>
						В settings.py - регистрирую приложение
						<pre>
INSTALLED_APPS = [ 
....,
'account.apps.AccountConfig',  # наше приложение аккаунт
]</pre>
					</li>
					<li>
						В account/urls.py добавляем пути - перемещаем  всё необходимое из blog/urls.py
						<pre>
from django.urls import path
from .views import *

urlpatterns = [
    path('login/', LoginUser.as_view(), name='login'),
    path('logout/', logout_user, name='logout'),
    path('register/', RegisterUser.as_view(), name='register'),
]</pre>
					</li>
					<li>
						В Главном urls.py - расширимся путями из account/urls.py
						<pre>path('', include('account.urls')),  # путь к путям приложения account</pre>
					</li>
					<li>
						blog/forms.py - полностью переносим в account/urls.py (сейчас там только формы регистрации и автоиризации)
					</li>
					<li>
						В account  - создаём подкаталоги templates/account. В него переносим наши шаблоны login.html, register.html
					</li>
					<li>
						Из blog/views.py переносим все классы и функции представления в account/views.py, связанные с пользователем  - Везде где указан путь к шаблону меняем путь
						<pre>
'account/register.html'
template_name = 'account/login.html'</pre>
						<br>Все функции и класса представления в account views.py
						<pre>
# Create your views here.
# класс представления RegisterUser
class RegisterUser(DataMixin, CreateView):
    form_class = RegisterUserForm  # наша форма из forms.py
    template_name = 'account/register.html'  # шаблон куда передаём
    success_url = reverse_lazy('login')  # При успешной регистрации направит path 'login'

    # формируем полный словарь context
    def get_context_data(self, object_list=None, **kwargs):
        # берём контекст из этого класса представления
        context = super().get_context_data(**kwargs)  # на данный момент form_class
        # берём контекст из DataMixin - и в него сразу добавляем title
        c_def = self.get_user_context(title='Регистрация')
        # передаём в шаблон общий контекст (RegisterUser + DataMixin)
        return {**context, **c_def}
        # или
        # return dict(list(context.items()) + list(c_def.items()))

    # автозалогинивание при успешной регистрации
    def form_valid(self, form):
        user = form.save()  # сохраняем данные пользователя в БД (User)
        login(self.request, user)  # авторизовывает пользователя
        return redirect('home')  # перенаправляет домой


# Класс представления формы авторизации
# Логика работы базового класса LoginView + сама форма LoginUserForm
class LoginUser(DataMixin, LoginView):
    form_class = LoginUserForm  # наша форма из forms.py
    template_name = 'account/login.html'  # шаблон

    # формируем полный контекст
    def get_context_data(self, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)  # распаковываем изначальный контекст
        c_def = self.get_user_context(title='Авторизация')  # переменная контекста DataMixin
        return {**context, **c_def}  # в шаблон передаём полный контекст

    def get_success_url(self):
        return reverse_lazy('home')  # при успешном входе перенаправит домой


# выход из аккаунта
def logout_user(request):
    logout(request)  # стандартный выход пользователя
    return redirect('login')  # перенаправляет залогиниться</pre>
					</li>
					<li>
						Выделенные красным мктоды, классы, формы  - импортируем в account/views.py - Это очень просто сделать в PyCharm.  - он почти всегда знает что откуда импортировать
						<pre>
from django.contrib.auth import logout, login
from django.contrib.auth.views import LoginView
from django.shortcuts import render, redirect
from django.urls import reverse_lazy
from django.views.generic import CreateView

from account.forms import RegisterUserForm, LoginUserForm
from blog.utils import DataMixin</pre>
					</li>
					<li>
						Пробуем запускать сервер и в терминале читаем ошибки, что и где не состыковывается
						<br>В blog.views.py - удаляем ИМПОРТ forms.py
						<pre>from .forms import *  # наш forms.py  -  УДАЛЯЕМ</pre>
						<strong>Всё работает! Точно так же как и до создания прилодения account и переноса туда всеи информации!</strong>
					</li>
					<li>
						Финальнцы штрих - удалим все неиспользуемые импорты в blog/Views.py
						<pre>
---DELETE---DELETE---DELETE---DELETE---DELETE---DELETE---
from django.contrib.auth import logout, login  # выход/вход пользователя django
from django.contrib.auth.forms import UserCreationForm  # форма django
from django.contrib.auth.views import LoginView  # стандартная логика авторизации
from django.http import HttpResponse

from django.urls import reverse_lazy  # перенаправление на маршрут
from django.views.generic import CreateView  # класс представления

from .utils import DataMixin  # наш Mixin

from django.shortcuts import redirect
---DELETE---DELETE---DELETE---DELETE---DELETE---DELETE---</pre>
						<br>Даже если что то и понадобится в будующем - импортируем заново
					</li>
				</ol>
			</li>
			


--------------------------------------------------


			<li>
				<span class="title_text">Добавляем страницу добавления поста - пользователем сайта</span>
			
				<ol>

					<li>
						В blog/forms.py - создаём форму - по сути ссылаемся на нашу модель Car, и указываем какие поля будем отображать
						<pre>
from django import forms
from blog.models import Car


class CarForm(forms.ModelForm):
    class Meta:
        model = Car  # наша модель
        # поля отображаемые в форме
        fields = ('title', 'slug', 'content', 'tth', 'photo', 'is_published', 'cat')</pre>
					</li>
					<li>
						Создаём шаблон add_post.html - по стандарту, расщиряемся от base.html , block content, block title
					</li>
					<li>
						Создаём функция представления show_add_post
						<pre>
from .forms import CarForm			

def show_add_post(request):
    form = CarForm()
    context = {
        'all_categories': all_categories,
        'form': form,
    }
    return render(request, 'blog/add_post.html', context=context)</pre>
					</li>
					<li>
						Добавляем маршрут name='add_post'
						<pre>path('add_post/', show_add_post, name='add_post'),</pre>

					</li>
					<li>
						Добавим ссылку в навбар для добавления поста (base.html)
						<pre>href="{% url 'add_post' %}</pre>
					</li>
					<li>
						<span class="spec">Внутри шаблона обязательно сразу указать form method='POST' и csrf_token - Без этого ничего сервер не запустится!</span>
						<pre>
&lt;h1>New post&lt;/h1>
&lt;form method="POST" class="post-form">
	{% csrf_token %}
    {{ form.as_p }}
    &lt;button type="submit" class="save btn btn-default">Save&lt;/button>
&lt;/form></pre>
					</li>
					<li>
						На данном этапе, форма уже отображается, только при её заполнении ничего не происходит так как у нас по сути нет кода чтобы сохранить её, так же нужно сделать валидацию данных
					</li>
					<li>
						Во первых в шаблоне add_post - необходимо обязательно добавить в тегах форм
						<pre>
&lt;form action="{%  url 'add_post' %}" method="post" enctype="multipart/form-data"></pre>
					</li>
					<li>
						Добавим параметры отображения полей (по сути автозаполнение тегов при пережаче в шаблон)
						<br>
						В forms.py - class CarAddForm(forms.ModelForm): -  class Meta: - widgets
						<pre>
widgets = {
    'title': forms.TextInput(attrs={'class': 'form-input'}),

    'content': forms.Textarea(attrs={'cols': 60, 'rows': 6}),
    'tth': forms.Textarea(attrs={'cols': 60, 'rows': 3}),
}</pre>
					</li>
					<li>
						В add_post - отобразим  ошибка форм - сразу после csrf -{{ form.non_field_errors }} / до закрытия цикла фор - {{ f.errors }}
						<br>
						Готовй шаблон add_post.html
						<pre>
&lt;h1>{{ title }}&lt;/h1>
&lt;form action="{%  url 'add_post' %}" method="post" enctype="multipart/form-data">
	{% csrf_token %}
	
&lt;div class="form-error">{{ form.non_field_errors }}&lt;/div>
	
	{% for f in form %}

	&lt;p>
		&lt;label class="form-label" for="{{ f.id_for_label }}">{{ f.label }}:&lt;/label>{{ f }}
	&lt;/p>

&lt;div class="form-error">{{ f.errors }}&lt;/div>

{% endfor %}

&lt;button type="submit" class="btn btn-primary btn-lg">
	Сохранить запись
&lt;/button>

{% endblock %}</pre>
					</li>
					<li>
						Готовая функция представления (добавление поста)
						<pre>
def show_add_post(request):
    if request.method == 'POST':  # если уже введены какие-то данные
        # request.FILES - Обязательно если есть файлы, изображения и ТД
        form = CarAddForm(request.POST, request.FILES)  # форма = заполненная форма
        if form.is_valid():  # проверка правильности формы, если форма заполнена правильно
            form.save()  # сохраняет запись в БД
            return redirect('home')  # перенаправление домой при успешном заполнении
    else:  # если никаких данный пользователь ещё не вводил
        form = CarAddForm()  # отображаем пустую форму для заполнения

    context = {
          'title': 'Добавление статьи',
          'all_categories': all_categories,
          'form': form,
      }
    return render(request, 'blog/add_post.html', context=context)</pre>
					</li>
				</ol>
			</li>

--------------------------------------------------


			<li>
				<span class="title_text">Редактирование поста через класс представления UpdateView</span>
				
				<ol>

					<li>
						Создаю форму в forms.py - на данном этапе почти такаяже как и добавление поста - но не указываю slug в полях
						<pre>
# форма редактирования поста
class CarUpdateForm(forms.ModelForm):
    <span class="spec"># Чтобы не отображалось - На данный момент: http:///...</span>
    photo = forms.ImageField(widget=forms.FileInput)
    # photo = forms.ImageField(required=False, widget=forms.FileInput)
    class Meta:
        model = Car  # связываемся с моделью Car
        # поля отображаемые в форме - URL - не указываю!
        # c photo не всё так просто, коряво + обязательно необходимо изменить изображение
        fields = ['title', 'content', 'tth', 'cat', 'photo']
        widgets = {
            'title': forms.TextInput(attrs={'class': 'form-input'}),
            'content': forms.Textarea(attrs={'cols': 60, 'rows': 6}),
            'tth': forms.Textarea(attrs={'cols': 60, 'rows': 3}),
        }</pre> 
					</li>
					<li>
						Делаем класс представления c помощью. UpdateView, во views.py
						<pre>
# редактирование Поста
class UpdatePostView(DataMixin, UpdateView):
    model = Car  # связываемся с моделью Car
    form_class = CarUpdateForm  # связываемся с формой
    # указываем только car_slug - из get_absolute_ur
    # несмотря на то что в пути есть и car_slug ? почему так хз
    slug_url_kwarg = 'car_slug'
    template_name = 'blog/update_post.html'  # путь к шаблону

    # формируем полный контекст
    def get_context_data(self, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)  # распаковываем изначальный контекст
        c_def = self.get_user_context(title='Изменение поста')  # переменная контекста DataMixin + title
        return {**context, **c_def}  # в шаблон передаём полный контекст</pre>
					</li>
					<li>
						Маршрут urls.py 
						<pre>
		path('category/&lt;slug:cat_slug>/&lt;slug:car_slug>/update/', UpdatePostView.as_view(), name='update_post'),</pre>
					</li>
					<li>
						Cоздаём шаблон  - лучше сделать отдельный update_post.html - по сути внитри всё тоже самое что и в add_post.html - но очень важная особенность, в тегах form в action=' ' получение пути по слагу!'
						<br><span class="spec">{%  url 'update_post' car_slug=car.slug cat_slug=car.cat.slug %}</span>
						<br><span class="spec"> = http://127.0.0.1:8000/category/japan/nissan_gt-r/</span>
						<pre>
&lt;form action="{%  url 'update_post' car_slug=car.slug cat_slug=car.cat.slug %}" method="post" enctype="multipart/form-data">

# {%  url 'update_post' car_slug=car.slug cat_slug=car.cat.slug %} - для получения пути ../&lt;slug: cat_slug>/&lt;slug:car_slug>/.../
# method="post" - для отправки информации на сервер (исопльзовать в форме отправки)
№ enctype="multipart/form-data" - при отправке не только текста но и файлов (например изображенией)</pre>
					</li>
					<li>
						Тот же шаблон update. html - отображаем изображение внизу вместо ссылки<br>
						<span class="spec">КРИТИЧЕСКИИЯ ФАЖНАЯ ИНФОРМАЦИЯ - ОТОБРАЖЕНИЕ ФОТО С СЕРВЕРА, ПОЛУЧЕНИЕ ССЫЛКИ НА НЕЁ, ФОТО ОТНОСЕЩИЕСЯ К ОПРЕДЕЛЕННОЙ ЗАПИСИ</span>
						<br>Для начала будем выводить все поля кроме фото, фото стоит последним полем в форме UpdatePostView
						<br>-Ниже выводим отдельно поле фото - вместе с текущи изображение
						<pre>
&lt;form action="{%  url 'update_post' car_slug=car.slug cat_slug=car.cat.slug %}" method="post" enctype="multipart/form-data">
	{% csrf_token %}
	
	&lt;!-- # &lt;div class="form-error"> form.non_field_errors }}&lt;/div> -->
    &lt;!-- # одибки сверху см add_post.html - нажна ли? -->

	{% for f in form %}

	{% if not forloop.last %}

	&lt;p>
		&lt;label class="form-label" for="{{ f.id_for_label }}">{{ f.label }}:&lt;/label>{{ f }}
	&lt;/p>

    {% else %}
    &lt;br>

<span class="spec">
# ССЫЛКА НА ИЗОБРАЖЕНИЕ ОБЪЕКТА (записи модели из БД) <br>(вставлять в &lt;img src='ссылка') : <br>{{object.photo.url }}</span>

    	&lt;label class="form-label" for="{{ f.id_for_label }}">
    		&lt;img src="{{object.photo.url }}" class="img-fluid" style="max-width: 50%;">&lt;br>

    		&lt;p class="text-info">- Если хотите оставить указанное фото, &lt;br>в этом поле не нужно ничего изменять.&lt;/p>{{ f }}
    	&lt;/label>
  

	{% endif %}

	&lt;!-- # &lt;div class="form-error"> f.errors }}&lt;/div> -->
    &lt;!-- # ошибки снизу см add_post.html нужна ли? -->

	{% endfor %}
	
	&lt;br>&lt;br>
	&lt;button type="submit" class="btn btn-primary btn-lg">
		Сохранить изменения
	&lt;/button>
&lt;/form></pre>
					</li>
					<li>
						Кнопка 'Редактировать' - в шаблоне car.html - важно так же указать car_slug cat_clug
						<br><span class="spec">href="{% url 'update_post' car_slug=car.slug cat_slug=car.cat.slug %}"</span>
						<br><span class="spec"> = http://127.0.0.1:8000/category/japan/nissan_gt-r/</span>
						<pre>
&lt;a class="btn btn-warning" href="{% url 'update_post' car_slug=car.slug cat_slug=car.cat.slug %}">Редактировать статью&lt;/a></pre>
					</li>
				</ol>
			</li>

--------------------------------------------------

			<li>
				<span class="title_text">Удаление статьи пользователем сайта</span>
				<ol>
					<li>
						Пишем маршрут в blog/urls.py
						<pre>path('category/&lt;slug:cat_slug>/&lt;slug:car_slug>/delete/', DeletePostView.as_view(), name='delete_post'),</pre>
					</li>
					<li>
						Во views.py пишим класс представления - для удаления статьи
						<pre>
from django.views.generic import ..., DeleteView  # представление для удаления
from django.urls import reverse_lazy  # перенаправление

# Представление для удаления статьи
class DeletePostView(DataMixin, DeleteView):
    model = Car  # модель из models.py
    template_name = 'blog/delete_post.html'  # шаблон
    success_url = reverse_lazy('home')  # после удаления отправит домой

    # !указываем только car_slug - из get_absolute_ur
    # !несмотря на то что в пути есть и car_slug ? почему так хз
    slug_url_kwarg = 'car_slug'
    
    # form_class = не нужно никакой формы

    # формируем полный контекст
    def get_context_data(self, object_list=None, **kwargs):
        context = super().get_context_data(**kwargs)  # распаковываем изначальный контекст
        c_def = self.get_user_context(title='Удаление поста')  # переменная контекста DataMixin + title
        return {**context, **c_def}  # в шаблон передаём полный контекст</pre>
						<br><span class="spec">Обрати внимаание на комменатрии к slug_url_kwarg = 'car_slug'</span>
					</li>
					<li>
						Создаём шаблон delete_post.html - в нем расширяемся от base.html + block title + block content
						<br>В блок контент добавим - кнопку удалить, проверку аутентификации пользователя, альтернативный вариант (войти/зарегестрироваться)
						<br>Форма простая просто method = 'post'
						<pre>
{% block content %}

&lt;h1>{{ title }}&lt;/h1>&lt;br>

&lt;!-- если пользователь залогиненый -->
{% if request.user.is_authenticated %}

&lt;&lt;div class="form-error">Удалить статью: "{{ object }}"!?&lt;/div>
&lt;br>
<span class="spec"># {{ object }} - это запись в таблице, отображает Сar - title
обрещение к записи через {{ object }} - вроде как в классах представления или формах</span>


&lt;form method="post">

	{% csrf_token %}
	
	&lt;button type="submit" class="btn btn-danger btn-lg">
		Удалить статью
	&lt;/button>
&lt;/form>

{% else %}
&lt;div class="form-error">
	&lt;p>Только авторизованные пользователи могут удалть статьи.</p>
	&lt;br>&lt;br>
	&lt;p>
		Пройдите авторизацию: &lt;a href="{% url 'login' %}" class="btn btn-primary btn-sm">Войти</a>
	&lt;/p>
	&lt;p>
		Либо зарегистрируйтесь:&lt;a href="{% url 'register' %}" class="btn btn-warning btn-sm">Регистрация&lt;/a>
	&lt;/p>
&lt;/div>

{% endif %}
{% endblock %}
						</pre>
					</li>
					<li>
						Добавим кнопку/ссылку удалить на страницу отдельной статьи - car.html
						<pre>
&lt;a class="btn btn-danger" href="{% url 'delete_post' car_slug=car.slug cat_slug=car.cat.slug %}">Удалить статью&lt;/a></pre>
						<br><span class="spec">Обрати внимание, для написания динамической ссылки в шаблоне, где есть id/pk или slug - все их необходимо указывать в href!</span>
					</li>
				</ol>
			</li>


--------------------------------------------------
			<li>
				<span class="title_text">
					
				</span>

				<ol>
					<li>
						
					</li>
					<li>
						
					</li>
				</ol>




			</li>

&lt;
		</ol><!-- общий список -->
	</div><!-- container-md all -->
&lt; &lt; &lt;

# Ctrl + Alt + L 
























-------------------------------------------------------------------------------------------
<ol>
	<li>
		Получение данных о пользователи (какой пользователь аутентифицирован) в views.py - из реквеста
		<pre>
def sample_view(request):
    current_user = request.user
    print current_user.id</pre>
	</li>
	<li>
		Получение записи одного пользователя в request - из модели User
		<pre>
def show_profile(request):
    current_user = request.user

    user_info = User.objects.get(username=current_user)</pre>
    	<br>Передача в шаблон
    	<pre>
def show_profile(request):
    current_user = request.user

    user_info = User.objects.get(username=current_user)

    all_user = User.objects.all()
    context = {
        'all_user': all_user,
        'current_user': current_user,
        'user_info': user_info,
    }
    return render(request, 'account/profile.html', context=context)</pre>
    	<br>Отображение в шаблоне
    	<pre>
login: {{ user_info.username }}
мыло: {{ user_info.email }}
Имя: {{ user_info.first_name }}
Фамилия: {{ user_info.last_name }}
Пароль: {{ user_info.password }}</pre>
	</li>
	<li>
		Проверка аутетефицирован ли пользователь в функции представления
		<pre>
if request.user.is_authenticated:
    # Do something for authenticated users.
else:
    # Do something for anonymous users.</pre>
    <li>
    	Проверка аутентефицирован ли пользователь внутри шаблона
    	<pre>
{% if request.user.is_authenticated %}
блок кода покажета если пользователь щалогинен</pre>
    </li>
    <li>
    	Получение id пользоватьеля из request
    	<pre>request.user.id</pre>
    </li>
    <li>
    	<span class="spec">ПЕРЕДАВАТЬ ЗНАЧЕНИЯ ПОЛЬЗОВАТЕЛЯ В ШАБЛОН НЕ ОБЯЗАТЕЛЬНО</span>
    	его передаёт request.   (requuest.user) 
    	<br>Можно просто сразу обращаться в шаблоне {{user}} {{user.id}} {{user.last_name}} и тд
    </li>
    <li>
    	<span class="spec">Что хранится в request? - полный список</span>
    </li>


</ol>





<!-- JS Bootstrap 5 -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-gtEjrD/SeCtmISkJkNUaaKMoLD0//ElJ19smozuHV6z3Iehds+3Ulb9Bn9Plx0x4" crossorigin="anonymous"></script>


</body>
</html>


