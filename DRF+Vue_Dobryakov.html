<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- css bootstrap 5 -->
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x" crossorigin="anonymous">

	<title>Django REST + VUE</title>

	<style type="text/css">
		pre{
			color: white;
			background: #2c4352;
			padding-right: 35px;
			padding-left: 5px;
			padding-bottom: 7px;
			padding-top: 10px;
		}
		
		.all{
			background: #e5fdff;


		}

		
		body{
			background: #2c4352;

		}
		
		.spec {
			font-size: 16px;
			letter-spacing: .2em;
			font-weight: 500;
/*			text-transform: uppercase;*/
			color: #f70000;
			margin-top: 15px;
			margin-bottom: 2px;
		}

		.title_text {
			letter-spacing: .1em;
			font-weight: 500;
			color: #ce0000;
			font-size: 25px;

		}

		li{
			margin-bottom: 25px;

		}
	</style>
&lt; &lt; &lt;


</head>
<body>

	Patch - запрос что это
	<br>
	access и refresh в JWT  - что это

	<p><a href="https://www.youtube.com/playlist?list=PLAhg4XYCffEk-Sa5xxvpcpWpQFlckLIMy">YT курс Django REST + VUE</a></p>
	
	<p>
		<a href="https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbW9QOUtPU3lFdE9pNWIyRjVFLTNYOGFBRFZtd3xBQ3Jtc0ttZWVoTGhRd2RqZUR1djA4NkpsNGxvang2Sm55ZFl4YlB1VEdiOEtxMWpWQWh5MTI2MWRGMThzeGRkQ3oxNHI1YUxPSW5FNC1QTlN4OTJmNjRXUldxNDVDVnY1Y0FURG5tSnV4cEF1bGtNX2VZanZiUQ&q=https%3A%2F%2Fwww.figma.com%2Ffile%2Fa8YM4L49zJdTWSFjEH5DgJ%2FBootstrap-v4-uikit-Copy%3Fnode-id%3D0%253A1&v=_lN3fGnkmms">Figma Bootstrap UI Kit</a>
	</p>

	<p><a href="https://unsplash.com/">https://unsplash.com/ - картинки для сайтов</a></p>

	<p>
		<a href="https://www.youtube.com/watch?v=vAqcdFrbPhY">
			С 39 минуты - простое приложение на Vue - с нуля, с объяснениями роутинга и так далее
		</a>
	</p>

	<p>
		<a href="https://docs.google.com/document/d/1Q2okFWi3E2SqRkKmRrBFaM6nszJKEQTe4y5_pTfS0PY/edit#">Мануал по работе с Vue.JS с минимально необходимым набором пунктов</a>
	</p>

	<p>
		<a href="https://github.com/imcvampire/vue-axios#usage">git - axios (установки и использование)</a>
	</p>



	<p>
		<a href="https://bootstrap-vue.org/docs">
			Bootstrap Vue
		</a>
		<br>Здесь Bootstrap v4 и Vue.js v 2.6+
	</p>


	<p>
		<a href="https://bootstrap-vue.org/docs/components">
			Комомненты Bootstrap vue
		</a>
	</p>

	<p>
		<a href="https://www.youtube.com/watch?v=0jPwrj5f8no">Как работает SPA? Роутинг на фронтенде. Компонетный подход (+ пишем свой роутер)</a>
	</p>

	<h3 class="text-danger">Vuetifi - это готовые UI компоненты типо bootstrap</h3>


	<div class="container-md all"><!-- container-md all ОБЩИЙ -->

		<br>
		<h1 class="title_text border text-center">Django REST + VUE<br>David Dobryakov<br>Фриланс Биржа</h1><br>
		<!-- <img src="images\avtoblog\host.jpg" class="img-fluid"><br> -->


		<ul> <!-- ОБЩИЙ -->

&lt;

			<li>
				<hr><h1 class="title_text">1. DJANGO REST + VUE, НАСТРОЙКА ОКРУЖЕНИЯ (Django REST, PostgreSQL, Vue, Make)</h1><hr>
				<ol>
					<li>
						Устанавливаю новый проект через PyCharm
						<br>Сам проект
						<pre>C:\Хранилище\IT\IT Разное\Обучение\David Dobryakov\DRF3+Vue2\freelance</pre>
						<br>Новое собственное окружения
						<pre>C:\Хранилище\IT\IT Разное\Обучение\David Dobryakov\DRF3+Vue2\freelance\venv_freelance</pre>
						Никаких других галочек нет
						<br>
						<br>
						Получился каталог freelance - внутри файлы папка idea и папка venv_freelance
					</li>
					<li>
						Создаю новую папку для Бэка - в папке freelance
						<pre>C:\Хранилище\IT\IT Разное\Обучение\David Dobryakov\DRF3+Vue2\freelance\django_backend</pre>
					</li>
					<li>В терминале - 
						сd DRF3+Vue2\freelance\django_backend
						<br>Устанавливаю Django
						<pre> pip install django</pre>
						<br>Обновляю pip
						<pre>python.exe -m pip install --upgrade pippip</pre>
						<br>Устанавливаю Django REST
						<pre>pip install django-rest-framework</pre>
						<br><strong class="text-danger">Устанавливаю djoser - для авторизации и регистрации (для DRF)</strong>
						<pre>pip install djoser</pre>
						<br><strong class="text-danger">Устанавливаю django-cors-headers - это фитча для фронтенда в джанге</strong>
						<br>django-cors-headers - это определённые заголовки сервера, благодоря которым, мы можем получить данные с сервера и какието данные ему отдать.
						<br>Без этой настройки не получится пообщатся с сервером никаким образом, то есть не будет доступен REST API - ни для кого
						<pre>pip install django-cors-headers</pre>
					</li>
					<li>
						Стартуем проект <br>
						В (venv_freelance) PS C:\Хранилище\IT\IT Разное\Обучение\David Dobryakov\DRF3+Vue2\freelance\django_backend>
						<pre>django-admin startproject django_freelance</pre>
						Название проекта в джанге, лучше делать либо слитно, либо через нижнее подчёркивание, т.к джанга не любит дефисов и пробелов
					</li>
					<li>
						(venv_freelance) PS C:\Хранилище\IT\IT Разное\Обучение\David Dobryakov\DRF3+Vue2\freelance\django_backend\django_freelance> 
						<br>
						(В папке django_freelance - manage.py + вложенная папка django_freelance)
						<br>Создаём приложение freelance
						<pre>
(venv_freelance) PS C:\Хранилище\IT\IT Разное\Обучение\David Dobryakov\DRF3+Vue2\freelance\django_backend\django_freelance>

python manage.py startapp freelance</pre>
					</li>
					<li>
						cd DRF3+Vue2\freelance\django_backend\django_freelance\freelance>
						<br>freelance - это папка приложения, внутри admin.py, apps.py, __init__.py, tests.py, views.py
					</li>
					<li>
						Делаем настроку проекта
						<br>DRF3+Vue2\freelance\django_backend\django_freelance\settings.py
						<br>В INSTALLED_APPS - добавляем приложения
						<pre>
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    <strong class="text-danger">'freelance.apps.FreelanceConfig',  # наше приложение freelance
    'rest_framework',  # DRF
    'djoser',  # djoser
    'corsheaders',  # corsheaders</strong>
]</pre>
						<strong>Необходимо добавить corsheaders - в MIDDLEWARE</strong>
						<br>Так же в settings.py - добавляем, инфу берём из официального гита
						<pre>
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    <strong class="text-danger">"corsheaders.middleware.CorsMiddleware",  # corsheaders
    "django.middleware.common.CommonMiddleware",  # corsheaders</strong>
]</pre>
						Для corsheaders - нужен лист с хостами, <strong class="text-danger">на деплое измени!</strong>
						<br>В settings.py - выше языка и времени
						<pre>
# Для corsheaders - разрешённые хосты
CORS_ALLOWED_ORIGINS = [
    # "https://example.com", # измени на деплое
    # "https://sub.example.com", # измени на деплое
    "http://localhost:8080",  # тестовый web сервер джанги
    # "http://127.0.0.1:9000",  # можно ужалить
]</pre>
						Для corsheaders - нужен лист разрешёнными методами
						<br>settings.py - ниже
						<pre>
# Для corsheaders - список разрешённых методов обращения к серверу
CORS_ALLOW_METHODS = [
    "DELETE",
    "GET",
    "OPTIONS",
    "PATCH",
    "POST",
    "PUT",
]</pre>
					</li>
					<li>
						В виртуальное окружение устанавливаем psycopg2 (для PostrgeSQL)
						<pre>pip install psyco
pg2</pre>
					</li>
					<li>
						Сразу создаю базу данных в SQL Shell(psql)
						<pre>
Server [localhost]:
Database [postgres]:
Port [5432]:
Username [postgres]:
Пароль пользователя postgres:blog1234

psql \! chcp 1251  # для отображении кириллицы
\l смортрим список всех DB
CREATE DATABASE freelance;  # создали базу данных - freelance
-->CREATE DATABASE
\l - смотрим DB создана</pre>
						<br>
						В settings.py - привязываем к проекту базу данных и PostrgeSQL
						<pre>
DATABASES = {
    'default': {
        # 'ENGINE': 'django.db.backends.sqlite3',  # стандартная БД
        # 'NAME': BASE_DIR / 'db.sqlite3',  # стандартная БД
        'ENGINE': 'django.db.backends.postgresql',  # БД PostrgeSQL
        'NAME': 'freelance',  # Имя нашей БД
        'USER': 'postgres',  # пользователь postgres - который создал БД
        'PASSWORD': 'blog1234',  # пароль в PostgreSQL, для пользователя postgres
        'HOST': '127.0.0.1',  # либо просто - 'localhost'
        'PORT': '5432',  # стандартный порт
    }
}</pre>
					</li>
					<li>
						Меняю язык в settings.py на русский
						<pre>
# LANGUAGE_CODE = 'en-En'  # англ. в admin
# TIME_ZONE = 'UTC'  # стандарт
LANGUAGE_CODE = 'ru-Ru'  # русский язык в admin

TIME_ZONE = 'Europe/Moscow'  # время по МСК</pre>
						<strong class="text-danger">Ctrl + Alt + L = автоформат в PyCharm</strong>
					</li>
					<li>
						В папке C:\Хранилище\IT\IT Разное\Обучение\David Dobryakov\DRF3+Vue2\freelance
						<br>Внутри .idea, django_backend, venv_freelance
						<br>Добавляю .gitignore
						<br>Тут же будет git init
						<br>Обязательно проверь что бы в .gitignore было
						<pre>
.idea/
.venv_freelance/
venv_freelance/</pre>
						Полный gitignore
						<pre>
.idea/
.venv_freelance/
venv_freelance/

# Created by https://www.toptal.com/developers/gitignore/api/django
# Edit at https://www.toptal.com/developers/gitignore?templates=django

### Django ###
*.log
*.pot
*.pyc
__pycache__/
local_settings.py
db.sqlite3
db.sqlite3-journal
media
/media
/static

# If your build process includes running collectstatic, then you probably don't need or want to include staticfiles/
# in your Git repository. Update and uncomment the following line accordingly.
# &lt;django-project-name>/staticfiles/

### Django.Python Stack ###
# Byte-compiled / optimized / DLL files
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo

# Django stuff:

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#pdm.lock
#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
#   in version control.
#   https://pdm.fming.dev/#use-with-ide
.pdm.toml

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
.idea/  #РАСКОММЕНТИРУЙ

# End of https://www.toptal.com/developers/gitignore/api/django





# для Vue

.DS_Store
node_modules/
/dist/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Editor directories and files
.idea
.vscode
*.suo
*.ntvs*
*.njsproj
*.sln

# для idea
# Default ignored files
/shelf/
/workspace.xml</pre>
					</li>
					<li>
						Необходимо создать и применить миграции
						<br>Чувак изменил команды python manage.py makemigrations && mygrate
						<br>python manage.py runserver && run
						<br>
						<br>Создаём и и применяем миграции
						<pre>
python manage.py makemigrations  # создаём миграции (первый раз не обязательно)
python manage.py migrate (Применяем миграции_)</pre>
						После применения, можно проверить создались ли таблицы в базе данных - в pgAdmin
					</li>
<hr>
					<li>
						Установим сразу vue
						<br>В командной строке cd C:\Хранилище\IT\IT Разное\Обучение\David Dobryakov\DRF3+Vue2\freelance 
						<br>И устанавливем сам Vue в проект
						<pre>
<strong class="text-danger">vue init webpack vue-freelance</strong>

? Project name <strong class="text-danger">vue-freelance</strong>
? Project description <strong class="text-danger">freelance frontend</strong>
? Author <strong class="text-danger">Mello134 &lt;elproject220@yandex.ru></strong>
? Vue build standalone
? Install vue-router? <strong class="text-danger">Yes</strong>
? Use ESLint to lint your code? <strong class="text-danger">Yes</strong>
? Pick an ESLint preset (Use arrow keys)
> Standard (https://github.com/standard/standard)
  <strong class="text-danger">Airbnb (https://github.com/airbnb/javascript)</strong>
  none (configure it yourself)
? Set up unit tests <strong class="text-danger">No</strong>
? Setup e2e tests with Nightwatch? <strong class="text-danger">No</strong>
? Should we run `npm install` for you after the project has been created? (recommended) (Use arrow keys)
> <strong class="text-danger">Yes, use NPM</strong>
  Yes, use Yarn
  No, I will handle that myself
</pre>
						Далее можно проверить что Vue работает
						<pre>
cd vue-freelance  # переходим в папку установленного Vue
npm start  # webpack - собирает все модули
npm run dev # старт сервера Node? не обязательно npm start?</pre>
						Проверяем в браузере по маршруту
						<pre>http://localhost:8080</pre>
						<br>Для остановки в консоле Ctrl + C
					</li>
					<li>
						<strong class="text-danger">Устанавливаем модули для фронтенда заранее</strong>
						<br>C:\Хранилище\IT\IT Разное\Обучение\David Dobryakov\DRF3+Vue2\freelance\vue-freelance
						<br>Устанавливаем axios и vue-axios
						<pre>
npm i axios vue-axios -D</pre>
					</li>
<hr>
					<li>
						Создаю репозиторий на github
						<pre>https://github.com/Mello134/freelance_project</pre>
						<br>
						Подсказки для данного репозитория с гита
						<pre>
…or create a new repository on the command line
echo "# freelance_project" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/Mello134/freelance_project.git
git push -u origin main


…or push an existing repository from the command line
git remote add origin https://github.com/Mello134/freelance_project.git
git branch -M main
git push -u origin main</pre>
					</li>
					<li>
						Инициализируем git в C:\Хранилище\IT\IT Разное\Обучение\David Dobryakov\DRF3+Vue2\freelance
						<pre>
git –v  # посмотреть версию git
git init  # инициализируем git репозиторикй- папку на pc
git status  # смотрим какие файлы не отслеживаются на данный момент
git add .  # добавляем все файлы
git status  # смотрим что теперь всё отслеживается
git commit -m "имя коммита(что сделали/стадия)"  # создаём коммит
git remote add origin  - https://github.com/Mello134/репозиторий.git  # туда будем загружать
git branch -M main
git push -u origin main  # отправили на github - в репозитор</pre>
					</li>
				</ol>

			</li>


&lt;


			<li>
				<hr><h1 class="title_text">2. ПРОЕКТИРОВАНИЕ БД, DJANGO ORM, АДМИНКА (Django ORM, models, admin)</h1><hr>
				<ol>
					<li>
						Каталог django_freelance (папка с manage.py) - пометил как Source Root
					</li>
					<li>
						Центральные фигуры, Исполнитель -> Юзер <- Заказчик
						<br>Услуга -> Тэг <- Заказ
						<br>Ordering - таблица для соединения заказчика и исполнителя, услуги и сервиса
						<br>Сообщение (исполнитель, заказчик, дата, время, из эдитебл)
						<br>Тикеты, для безопасности заказчика, если исполнитель получил предоплату и слился, либо наоборот.
						<br>Ревью - рейтинг и комментарий
						<br>Авторство ревью -> Юзер
					</li>
					<li>
						Пишем модели
						<br>freelance/models.py
						<pre>
from django.db import models
from django.contrib.auth.models import User


# Модель Исполнителя
class Executor(models.Model):
    # Связь со встроенной моделью User,
    # CASCADE - при удалении пользователя, из таблицы Executor, удалятся все записи с его участием
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    # телефон, максимально 11 символов
    phone = models.CharField(max_length=11)

    # краткое отображения, для отдельной записи таблицы Executor
    def __str__(self):
        return "Пользователь(исп) {}, телефон: {}".format(self.user, self.phone)


# модель Заказчика - все поля аналогичны модели исполнителя
class Customer(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    phone = models.CharField(max_length=11)

    def __str__(self):
        return "Пользователь(зак) {}, телефон: {}".format(self.user, self.phone)


# Модель Услуги (связь с исполнителем)
class Service(models.Model):
    # ЧОЙСЫ УСЛУГ (типы услуг)
    SERVICE_TYPES = [
        ('1', 'Веб разработка'),
        ('2', 'Маркетинг'),
        ('3', 'Копирайтинг'),
        ('4', 'Рерайтинг'),
        ('5', 'Переводы'),
        ('6', 'Видеомонтаж'),
        ('7', 'Фотография'),
    ]

    # Услуга связана с исполнителем (модель Executor) / Удалился исполнитель, удалится и его услуги
    executor = models.ForeignKey(Executor, on_delete=models.CASCADE)
    # Имя услуги
    name = models.CharField(max_length=250)
    # Описание услуги
    desc = models.CharField(max_length=1000)
    # цена услуги
    price = models.IntegerField()
    # Тип услуги, стандартно 1, макс длина 1
    service_type = models.CharField(choices=SERVICE_TYPES, default='1', max_length=1)

    def __str__(self):
        # ВАЖНО <strong class="text-danger">self.get_service_type_display</strong> - чтобы отображалось именно название чойса, а не цифры от 1 до 7
        return "{}, {}, цена: {}".format(self.name, self.get_service_type_display(), self.price)


# Модель Заказ (связь с заказчиком)
class Order(models.Model):
    # ЧОЙСЫ УСЛУГ (типы услуг)
    ORDER_TYPES = [
        ('1', 'Веб разработка'),
        ('2', 'Маркетинг'),
        ('3', 'Копирайтинг'),
        ('4', 'Рерайтинг'),
        ('5', 'Переводы'),
        ('6', 'Видеомонтаж'),
        ('7', 'Фотография'),
    ]

    customer = models.ForeignKey(Customer, on_delete=models.CASCADE)
    name = models.CharField(max_length=250)
    desc = models.CharField(max_length=1000)
    price = models.IntegerField()
    order_type = models.CharField(choices=ORDER_TYPES, default='1', max_length=1)

    def __str__(self):
        <strong class="text-danger"># ВАЖНО self.get_order_type_display</strong> - чтобы отображалось именно название чойса, а не цифры от 1 до 7
        return "{}, {}, цена: {}".format(self.name, self.get_order_type_display(), self.price)


# таблица опциональных ключей, тегов (Связи между услугами и заказами)
class Tag(models.Model):
    # связь с услугой
    # blank=True, null=True, не обязательное заполнение, поле может быть пустым, и разрешается null
    service = models.ForeignKey(Service, on_delete=models.CASCADE, blank=True, null=True)
    # связь с заказом
    order = models.ForeignKey(Order, on_delete=models.CASCADE, blank=True, null=True)
    # имя тега
    name = models.CharField(max_length=30)


# таблица определённого заказа
# (Связи между исполнителем и заказчиком + заказом и услугой)
class Ordering(models.Model):
    # связь с заказчиком
    customer = models.ForeignKey(Customer, on_delete=models.CASCADE)
    # связь с исполнителем
    executor = models.ForeignKey(Executor, on_delete=models.CASCADE)
    # связь с услугой
    service = models.ForeignKey(Service, on_delete=models.CASCADE, blank=True, null=True)
    # связь с заказом
    order = models.ForeignKey(Order, on_delete=models.CASCADE, blank=True, null=True)
    # дата время
    order_date = models.DateTimeField()
    # дедлайн
    deadline = models.DateTimeField()

    def __str__(self):
        return "{} - {}, Исполнитель: {}, Заказчик: {}".format(self.order_date, self.deadline,
                                                               self.customer, self.executor)


# модель сообщений
class Message(models.Model):
    # заказчик
    customer = models.ForeignKey(Customer, on_delete=models.CASCADE)
    # исполнитель
    executor = models.ForeignKey(Executor, on_delete=models.CASCADE)
    # дата сообщения
    msg_date = models.DateTimeField()
    # редактировалось ли сообщение
    is_edited = models.BooleanField(default=False)
    # текст сообщения
    desc = models.CharField(max_length=1000)


# тикеты (для общения с техподдержной сайта)
class Ticket(models.Model):
    # Чойсы на строгость, претензии
    SEVERITIES = [
        ('1', 'Низкая'),
        ('2', 'Средняя'),
        ('3', 'Высокая'),
    ]

    # заказчик (опционально)
    customer = models.ForeignKey(Customer, on_delete=models.CASCADE, blank=True, null=True)
    # исполнитель (опционально)
    executor = models.ForeignKey(Executor, on_delete=models.CASCADE, blank=True, null=True)
    # оценка, чойс
    severity = models.CharField(choices=SEVERITIES, default='1', max_length=1)
    # описание претензии
    desc = models.CharField(max_length=1000)
    # дата обращения, претензии
    ticket_date = models.DateTimeField()
    # статус обращения (решён / не решен)
    is_resolved = models.BooleanField(default=False)

    def __str__(self):
        return '{}, {} вопрос решён?{}'.format(self.get_severity_display(), self.ticket_date, self.is_resolved)


# таблица Ревью (рейтинг)
class Review(models.Model):
    # Чойсы рейтинга
    RATING_FILLED = [
        ('1', 1),
        ('2', 2),
        ('3', 3),
        ('4', 4),
        ('5', 5),
    ]

    # рейтинг
    rating = models.CharField(choices=RATING_FILLED, default='1', max_length=1)
    # комментарий
    desc = models.CharField(max_length=1000)


# таблица автора ревью
class Authoring(models.Model):
    # связь с ревью
    review = models.ForeignKey(Review, on_delete=models.CASCADE)
    # автор ревью
    author = models.ForeignKey(User, on_delete=models.CASCADE)
    # опционально заказчик
    customer = models.ForeignKey(Customer, on_delete=models.CASCADE, blank=True, null=True)
    # опционально исполнитель
    executor = models.ForeignKey(Executor, on_delete=models.CASCADE, blank=True, null=True)
    # дата оценки
    review_date = models.DateTimeField()

    def __str__(self):
        return "{}, {}".format(self.author, self.review_date)</pre>
					</li>
					<li>
						Регистрируем все модели в Админке
						<br>freelance/admin.py
						<pre>
from django.contrib import admin
from .models import *  # импорт всех моделей

# Регистрируем все модели
admin.site.register(Customer)
admin.site.register(Executor)
admin.site.register(Service)
admin.site.register(Order)
admin.site.register(Tag)
admin.site.register(Ordering)
admin.site.register(Message)
admin.site.register(Ticket)
admin.site.register(Review)
admin.site.register(Authoring)</pre>
					</li>
					<li>
						Создаю и применяю миграции
						<pre>
python manage.py makemigrations
python manage.py migrate</pre>
					</li>
					<li>
						Создаю суперпользователя
						<pre>
python manage.py createsuperuser

Имя пользователя: Mello
Адрес электронной почты: elproject220@yandex.ru
Password:blog1234
Password (again):blog1234
Superuser created successfully.  # пользователь создан</pre>
					</li>
					<li>
						Запускаю сервер, захожу в админку, проверяю модели
						<pre>http://127.0.0.1:8000/admin/</pre>
					</li>
					<li>
						Через админ панель, создам пользователя, создам исполнителя и проверю
					</li>
				</ol>

			</li>

&lt;



			<li>
				<hr><h1 class="title_text">3. DJANGO SERIALIZERS: ПЕРЕВОД ДАННЫХ В JSON (serializers, views, urls)</h1><hr>
				<ol>
					<li>
						Serializers, сериализатор - это вещь которая перегоняет данные из БД в JSON формат.
						<br>
						JSON формат - это тот формат с которым могут работать разные языки програмирования, будь то на ПК или Андройд IOS. В нашем случае мы перегоняем инфу в JSON - чтобы можно было обработать её уже на стороне клиента, на фронте (JavaScript, Vue.js)
						<br>API
					</li>
					<li>
						Создаю отдельный файл в каталоге приложения freelance
						<br>в django_backend/django_freelance/freelance - создаю serializers.py
					</li>
					<li>
						В serializers.py - импортирую сериалайзеры из DRF
						<pre>from rest_framework import serializers</pre>
					</li>
					<li>
						В serializers.py Пишу пример сериализатора, который похож просто на класс (этим пользоваться не будем, просто для примера)
						<pre>
# пример сериалайзера по типу моделей
class User(serializers.Serializer):
    # ниже поля которые будем передавать в JSON формате
    user = serializers.CharField()
    email = serializers.EmailField()</pre>
					</li>
					<li>
						Предудуший сериализатор комментирую и создаю другие
						<pre>
from .models import *  # импортирую все модели
from django.contrib.auth.models import User  # импорт стандартной модели User


# # пример сериалайзера по типу моделей
# class User(serializers.Serializer):
#     # ниже поля которые будем передавать в JSON формате
#     user = serializers.CharField()
#     email = serializers.EmailField()


# сериализатор пользователя, модель User
class UserSerializer(serializers.ModelSerializer):
    # класс мета, уточняем данные к модели
    class Meta:
        model = User  # привязываем модель к сериализатору
        # какие поля модели нужно сериализовать
        fields = ['username', 'email', 'first_name', 'last_name']


# сериализатор модели исполнителя - Executor
class ExecutorSerializer(serializers.ModelSerializer):
    # создаём переменную в которой будет храниться вся информация о пользователе, а не только id
    # т.е, переменная user = сериализатору UserSerializer
    user = UserSerializer()

    class Meta:  # уточняем данные
        model = Executor  # привязываемся к модели Executor
        fields = '__all__'  # все поля модели


# сериализатор модели заказчика - Customer
class CustomerSerializer(serializers.ModelSerializer):
    # создаём переменную в которой будет храниться вся информация о пользователе, а не только id
    # т.е, переменная user = сериализатору UserSerializer
    user = UserSerializer()

    class Meta:  # уточняем данные
        model = Customer  # привязываемся к модели Customer
        fields = '__all__'  # все поля модели


# Делаю отдельный сериализатор для исполнителя, где не будет инфы о User
# он нужен когда пользователь ещё не зарегистрирован, то есть при создании
class CreateExecutorSerializer(serializers.ModelSerializer):
    class Meta:
        model = Executor
        fields = '__all__'


# Делаю отдельный сериализатор для заказчика, где не будет инфы о User
# он нужен когда пользователь ещё не зарегистрирован, то есть при создании
class CreateCustomerSerializer(serializers.ModelSerializer):
    class Meta:
        model = Customer
        fields = '__all__'


# сериализатор для Услуги - модель Service
# Модель Услуги (связь с исполнителем)
class ServiceSerializer(serializers.ModelSerializer):
    # JSON данные об исполнителе
    executor = ExecutorSerializer()
    <strong class="text-danger"># ВАЖНО - для отображения чойса, а не просто номера чойса - сразу в JSON формате</strong>
    service_type = serializers.CharField(source='get_service_type_display')

    class Meta:
        model = Service
        fields = '__all__'


# сериализатор для Услуги - модель Service
# при создании/корректировании услуги
class CreateServiceSerializer(serializers.ModelSerializer):
    class Meta:
        model = Service
        fields = '__all__'


# сериализатор для Заказа - модель Order
# Модель Услуги (связь с исполнителем)
class OrderSerializer(serializers.ModelSerializer):
    # JSON данные о заказчике
    customer = CustomerSerializer()
    <strong class="text-danger"># ВАЖНО - для отображения чойса, а не просто номера чойса - сразу в JSON формате</strong>
    order_type = serializers.CharField(source='get_order_type_display')

    class Meta:
        model = Order
        fields = '__all__'


# сериализатор для Заказа - модель Order
# при создании/корректировании заказ
class CreateOrderSerializer(serializers.ModelSerializer):
    class Meta:
        model = Order
        fields = '__all__'


# сериализатор для тегов - модель Tag (связи услуги и заказа)
# Модель Услуги (связь с исполнителем)
class TagSerializer(serializers.ModelSerializer):
    # JSON данные об услуге и заказе
    service = ServiceSerializer()
    order = OrderSerializer()

    class Meta:
        model = Tag
        fields = '__all__'


# сериализатор для Tag - модель Tag
# при создании/корректировании Tag
class CreateTagSerializer(serializers.ModelSerializer):
    class Meta:
        model = Order
        fields = '__all__'


# Сериализатор для модели Ordering - (Связи между исполнителем и заказчиком + заказом и услугой)
# У модели 4 ForeignKey поля, 2 из них опциональные
class OrderingSerializer(serializers.ModelSerializer):
    # JSON данные об исполнителе и заказчике + услуге и заказе
    service = ServiceSerializer()
    order = OrderSerializer()
    customer = CustomerSerializer()
    executor = ExecutorSerializer()

    class Meta:
        model = Ordering
        fields = '__all__'


# Сериализатор для модели Ordering - (Связи между исполнителем и заказчиком + заказом и услугой)
# При создании и редактировании
class CreateOrderingSerializer(serializers.ModelSerializer):
    class Meta:
        model = Ordering
        fields = '__all__'


# Сериализатор для модели Message - (Сообщения)
class MessageSerializer(serializers.ModelSerializer):
    # JSON данные об исполнителе и заказчике
    customer = CustomerSerializer()
    executor = ExecutorSerializer()

    class Meta:
        model = Message
        fields = '__all__'


# Сериализатор для модели Message - (Сообщения)
# При создании и редактировании
class CreateMessageSerializer(serializers.ModelSerializer):
    class Meta:
        model = Message
        fields = '__all__'


# Сериализатор для модели Ticket - (для общения с техподдержной сайта)
class TicketSerializer(serializers.ModelSerializer):
    # JSON данные об исполнителе и заказчике
    customer = CustomerSerializer()
    executor = ExecutorSerializer()
    <strong class="text-danger"># ВАЖНО - для отображения чойса, а не просто номера чойса - сразу в JSON формате</strong>
    severity = serializers.CharField(source='get_severity_display')

    class Meta:
        model = Ticket
        fields = '__all__'


# Сериализатор для модели Ticket - (для общения с техподдержной сайта)
# При создании и редактировании
class CreateTicketSerializer(serializers.ModelSerializer):
    class Meta:
        model = Ticket
        fields = '__all__'


# Сериализатор для модели Review - (оценки)
class ReviewSerializer(serializers.ModelSerializer):
    class Meta:
        model = Review
        fields = '__all__'


# Сериализатор для модели Authoring - (автора ревью)
class AuthoringSerializer(serializers.ModelSerializer):
    # JSON данные об исполнителе и заказчике, о пользователе, об оценке
    customer = CustomerSerializer()
    executor = ExecutorSerializer()
    author = UserSerializer()
    review = ReviewSerializer()

    class Meta:
        model = Authoring
        fields = '__all__'


# Сериализатор для модели Authoring - (автора ревью)
# При создании и редактировании
class CreateAuthoringSerializer(serializers.ModelSerializer):
    class Meta:
        model = Authoring
        fields = '__all__'</pre>
						<strong class="text-danger">Сериализаторы делаются с похожими именами, такими как и классы представления и модели</strong>
						<br><strong class="text-danger">Обрати внимание на код - как сделать так чтобы отображились значение чойсов а не их номера</strong>
					</li>
					<li>
						Пишем простое представление, View - для проверки работы
						<br>freelance/views.py
						<pre>
# from django.shortcuts import render  # обычный render не используется в DRF

from rest_framework.response import Response  # для создания ответа
from rest_framework import generics

# импорт всех моделей и сериализаторов
from .models import *
from .serializers import *


# представление для тикетов
# ListAPIView - базовый клас представления DRF
class TicketListView(generics.ListAPIView):
    queryset = Ticket.objects.all()  # все объекты модели
    serializer_class = TicketSerializer  # сериализатор для модели</pre>
					</li>
					<li>
						В каталоге приложения freelance - создаю собственный urls.py
						<br>django_backend/django_freelance(source)/freelance - urls.py
						<br>в freelance/urls.py прописываем
						<pre>
from django.urls import path  # стандартно - маршруты
from django.urls import include  # для расширения маршрутов из других приложений
from .views import *  # все представления из приложения

# список маршрутов
urlpatterns = [
    # путь('url'/, класс_представления.as_view()/функция представления, name='имя_маршрута'),
    path('tickets/all', TicketListView.as_view()),
]</pre>
					</li>
					<li>
						В главны й urls.py - django_freelance(source)/django_freelance/urls.py - подключем urls.py приложения freelance
						<pre>
from django.contrib import admin
from django.urls import path
<strong class="text-danger">from django.urls import include</strong>

urlpatterns = [
    path('admin/', admin.site.urls),

    <strong class="text-danger"># маршруты приложения freelance
    path('api/', include('freelance.urls')),</strong>
]</pre>
					</li>
					<li>
						На всякий случай создам и применю миграции (делал корректировки)
						<pre>
cd (venv_freelance) PS C:\Хранилище\IT\IT Разное\Обучение\David Dobryakov\DRF3+Vue2\freelance\django_backend\django_freelance></pre>
						<pre>
python manage.py makemigrations
python manage.py migrate</pre>
					</li>
					<li>
						Запускаю сервер
						<pre>python manage.py runserver</pre>
						<br>Через админ панель, создаю исполнителя и создаю заказчика, после создаю тикет
					</li>
					<li>
						В браузере переходим по маршруту
						<pre>http://127.0.0.1:8000/api/tickets/all</pre>
						Всё отлично работает! Получаем полный JSON всех тикетов
						<pre>
HTTP 200 OK
Allow: GET, HEAD, OPTIONS
Content-Type: application/json
Vary: Accept

[
    {
        "id": 1,
        "customer": {
            "id": 2,
            "user": {
                "username": "Mello",
                "email": "elproject220@yandex.ru",
                "first_name": "",
                "last_name": ""
            },
            "phone": "89047777777"
        },
        "executor": {
            "id": 1,
            "user": {
                "username": "Кеша",
                "email": "",
                "first_name": "",
                "last_name": ""
            },
            "phone": "88007892132"
        },
        "severity": "Низкая",
        "desc": "Кеша слишком много пиздит",
        "ticket_date": "2023-03-04T17:03:02+03:00",
        "is_resolved": false
    }
]</pre>
					</li>
				</ol>

			</li>

&lt;




			<li>
				<hr><h1 class="title_text">4. DJANGO API VIEWS, GENERICS, FILTER (APIView, generics, гибкий filter)</h1><hr>
				<ol>
					<li>
						Представления на основе классов, бывают высокоуровневые (generics), и есть нихкоуровневые
						<br>Пример низкоуровневого представления API
						<br>views.py
						<pre>
from rest_framework.views import APIView

# пример низкоуровневого API view
class TicketListView(APIView):
    # самостоятельно указываем метод get
    def get(self, request):
        # самостоятельно указываем queryset (записи модели Ticket)
        queryset = Ticket.objects.all()
        # указываем сериализатор
        # serializer_class = Сериализатор(данные_из_бд, в_модели_много_записей_т.е_список)
        serializer_class = TicketSerializer(queryset, many=True)

        # вернуть Ответ (данные сериализатора)
        return Response({'tickers': serializer_class.data})</pre>
        				По итогу, всё тоже самое, в том случае что и generic из предыдушего урока.
        				<br>Здесь приходится расписывать APIView самостоятельно - и контролировать что происходит, Но высокоуровниевые API более предпочтительней, в плане скорости написания как минимум
        				<br><br>Для сравнение API представление с помощью generics - высокоуровневое
        				<pre>
# # представление для тикетов (высокоуровневое API)
# # ListAPIView - базовый клас представления DRF
class TicketListView(generics.ListAPIView):
    queryset = Ticket.objects.all()  # все объекты модели
    serializer_class = TicketSerializer  # сериализатор для модели</pre>
    					Результат тот же
					</li>
<hr>
<h3 class="text-danger">API views и API endponts(маршруты для JSON)</h3>
					<li>
						Пишу представление для исполнителя, получаем по pk
						<br>views.py
						<pre>
# API представление Исполнителя - получить по pk
class ExecutorRetrieveView(generics.RetrieveAPIView):
    queryset = Executor.objects.all()
    serializer_class = ExecutorSerializer</pre>
    					Пишу маршут для представления
    					<br>freelance(app) - uels.py
    					<pre>
<strong class="text-danger"># http://127.0.0.1:8000/api/executors/1  - получим исполнителя по pk/id = 1</strong>
path('executors/&lt;int:pk>', ExecutorRetrieveView.as_view()),  # Получаем исполнителя по pk</pre>
					</li>
					<li>
						Пишу API представления Исполнителя (получаем по pk), <strong class="text-danger">Обновление записи и добавление записи - в модель</strong>
						<br>views.py
						<pre>
# API представление Исполнителя для <strong class="text-danger">обновления данных</strong> (по pk)
class ExecutorUpdateView(generics.UpdateAPIView):
    queryset = Executor.objects.all()
    serializer_class = CreateExecutorSerializer


# API представление Исполнителя для <strong class="text-danger">создания записи</strong> (по pk)
class ExecutorCreateView(generics.CreateAPIView):
    queryset = Executor.objects.all()
    serializer_class = CreateExecutorSerializer</pre>
    					Пишу маршруты представлений обновление и создание записей исполнителей
    					<br>urls.py
    					<pre>
path('executors/update/&lt;int:pk>', ExecutorUpdateView.as_view()),  # Обновляем исполнителя по pk
path('executors/new', ExecutorCreateView.as_view()),  # Создаём исполнителя</pre>
					</li>
					<li>
						Пишу API представления Исполниетлей, т.е <strong class="text-danger">Получить весь список записей в модели</strong>
						<br>views.py
						<pre>
# API представление для списка Исполнителей
class ExecutorListView(generics.ListAPIView):
    queryset = Executor.objects.all()
    serializer_class = ExecutorSerializer</pre>
						Маршрут для списка Исполнителей urls.py
						<pre>path('executors/all', ExecutorListView.as_view()),  # Получаем список исполнителей</pre>
					</li>
					<li>
						<strong class="text-danger">Логика для всех эндпойнтов API, почти всех моделей будет идентичной вышеуказанным</strong>
						<br>
						<strong>
							<ol>
								<li>API - одной записи модели [RetrieveAPIView]</li>
								<li>API - изменения одной записи модели [UpdateAPIView]</li>
								<li>API - создания новой записи в модели [CreateAPIView]</li>
								<li>API - списка всех записей модели [ListAPIView]</li>
							</ol>
						</strong>
					</li>
					<li>
						Пишу аналогичные представления для модели заказчика (Customer)
						<pre>
# API представление Заказчика - получить по pk
class CustomerRetrieveView(generics.RetrieveAPIView):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer


# API представление Заказчика для обновления данных (по pk)
class CustomerUpdateView(generics.UpdateAPIView):
    queryset = Customer.objects.all()
    serializer_class = CreateCustomerSerializer


# API представление Заказчика для создания записи (по pk)
class CustomerCreateView(generics.CreateAPIView):
    queryset = Customer.objects.all()
    serializer_class = CreateCustomerSerializer


# API представление для списка Заказчиков
class CustomerListView(generics.ListAPIView):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer</pre>
					</li>
					<li>
						Пишу маршруты для всех представлений Заказчика (Customer)
						<pre>
path('customers/&lt;int:pk>/', CustomerRetrieveView.as_view()),  # Получаем заказчика по pk
path('customers/update/&lt;int:pk>/', CustomerUpdateView.as_view()),  # Обновляем заказчика по pk
path('customers/new/', CustomerCreateView.as_view()),  # Создаём заказчика
path('customers/all/', CustomerListView.as_view()),  # Получаем список заказчиков</pre>
					</li>
					<li>
						Пишу представления по такому же шаблону для остальных моделей
						<br>Order, Service, Tag, Ordering, Message, Ticket, Authoring
						<br>views.py

						<pre>
# API представление Заказа - получить по pk
class OrderRetrieveView(generics.RetrieveAPIView):
    queryset = Order.objects.all()
    serializer_class = OrderSerializer


# API представление Заказа для обновления данных (по pk)
class OrderUpdateView(generics.UpdateAPIView):
    queryset = Order.objects.all()
    serializer_class = CreateOrderSerializer


# API представление Заказа для создания записи (по pk)
class OrderCreateView(generics.CreateAPIView):
    queryset = Order.objects.all()
    serializer_class = CreateOrderSerializer


# API представление для списка Заказов
class OrderListView(generics.ListAPIView):
    queryset = Order.objects.all()
    serializer_class = OrderSerializer


# API представление Услуги - получить по pk
class ServiceRetrieveView(generics.RetrieveAPIView):
    queryset = Service.objects.all()
    serializer_class = ServiceSerializer


# API представление Услуги для обновления данных (по pk)
class ServiceUpdateView(generics.UpdateAPIView):
    queryset = Service.objects.all()
    serializer_class = CreateServiceSerializer


# API представление Услуги для создания записи (по pk)
class ServiceCreateView(generics.CreateAPIView):
    queryset = Service.objects.all()
    serializer_class = CreateServiceSerializer


# API представление для списка Услуг
class ServiceListView(generics.ListAPIView):
    queryset = Service.objects.all()
    serializer_class = ServiceSerializer


# API представление Тега - получить по pk
class TagRetrieveView(generics.RetrieveAPIView):
    queryset = Tag.objects.all()
    serializer_class = TagSerializer


# API представление Тега для обновления данных (по pk)
class TagUpdateView(generics.UpdateAPIView):
    queryset = Tag.objects.all()
    serializer_class = CreateTagSerializer


# API представление Тега для создания записи (по pk)
class TagCreateView(generics.CreateAPIView):
    queryset = Tag.objects.all()
    serializer_class = CreateTagSerializer


# API представление для списка Тегов
class TagListView(generics.ListAPIView):
    queryset = Tag.objects.all()
    serializer_class = TagSerializer


# API представление определённого заказа - получить по pk
class OrderingRetrieveView(generics.RetrieveAPIView):
    queryset = Ordering.objects.all()
    serializer_class = OrderingSerializer


# API представление определённого заказа для обновления данных (по pk)
class OrderingUpdateView(generics.UpdateAPIView):
    queryset = Ordering.objects.all()
    serializer_class = CreateOrderingSerializer


# API представление определённого заказа для создания записи (по pk)
class OrderingCreateView(generics.CreateAPIView):
    queryset = Ordering.objects.all()
    serializer_class = CreateOrderingSerializer


# API представление для списка определённого заказов
class OrderingListView(generics.ListAPIView):
    queryset = Ordering.objects.all()
    serializer_class = OrderingSerializer


# API представление Сообщения - получить по pk
class MessageRetrieveView(generics.RetrieveAPIView):
    queryset = Message.objects.all()
    serializer_class = MessageSerializer


# API представление Сообщения для обновления данных (по pk)
class MessageUpdateView(generics.UpdateAPIView):
    queryset = Message.objects.all()
    serializer_class = CreateMessageSerializer


# API представление Сообщения для создания записи (по pk)
class MessageCreateView(generics.CreateAPIView):
    queryset = Message.objects.all()
    serializer_class = CreateMessageSerializer


# API представление для списка Сообщений
class MessageListView(generics.ListAPIView):
    queryset = Message.objects.all()
    serializer_class = MessageSerializer


# API представление Тикета - получить по pk
class TicketRetrieveView(generics.RetrieveAPIView):
    queryset = Ticket.objects.all()
    serializer_class = TicketSerializer


# API представление Тикета для обновления данных (по pk)
class TicketUpdateView(generics.UpdateAPIView):
    queryset = Ticket.objects.all()
    serializer_class = CreateTicketSerializer


# API представление Тикета для создания записи (по pk)
class TicketCreateView(generics.CreateAPIView):
    queryset = Ticket.objects.all()
    serializer_class = CreateTicketSerializer


# API представление для списка Тикетов
class TicketListView(generics.ListAPIView):
    queryset = Ticket.objects.all()
    serializer_class = TicketSerializer


# API представление Автора_ревью - получить по pk
class AuthoringRetrieveView(generics.RetrieveAPIView):
    queryset = Authoring.objects.all()
    serializer_class = AuthoringSerializer


# API представление Автора_ревью для обновления данных (по pk)
class AuthoringUpdateView(generics.UpdateAPIView):
    queryset = Authoring.objects.all()
    serializer_class = CreateAuthoringSerializer


# API представление Автора_ревью для создания записи (по pk)
class AuthoringCreateView(generics.CreateAPIView):
    queryset = Authoring.objects.all()
    serializer_class = CreateAuthoringSerializer


# API представление для списка Авторов_ревью
class AuthoringListView(generics.ListAPIView):
    queryset = Authoring.objects.all()
    serializer_class = AuthoringSerializer</pre>
					</li>
					<li>
						Пишу маршруты по шаблону, для остальных представлений
						<br>Order, Service, Tag, Ordering, Message, Ticket, Authoring
						<br>views.py
						<pre>
path('orders/&lt;int:pk>/', OrderRetrieveView.as_view()),  # Получаем заказа по pk
path('orders/update/&lt;int:pk>/', OrderUpdateView.as_view()),  # Обновляем заказ по pk
path('orders/new/', OrderCreateView.as_view()),  # Создаём заказ
path('orders/all/', OrderListView.as_view()),  # Получаем список заказов

path('services/&lt;int:pk>/', ServiceRetrieveView.as_view()),  # Получаем услугу по pk
path('services/update/&lt;int:pk>/', ServiceUpdateView.as_view()),  # Обновляем услугу по pk
path('services/new/', ServiceCreateView.as_view()),  # Создаём услугу
path('services/all/', ServiceListView.as_view()),  # Получаем список услуг

path('tags/&lt;int:pk>/', TagRetrieveView.as_view()),  # Получаем тег по pk
path('tags/update/&lt;int:pk>/', TagUpdateView.as_view()),  # Обновляем тег по pk
path('tags/new/', TagCreateView.as_view()),  # Создаём тег
path('tags/all/', TagListView.as_view()),  # Получаем список тегов

path('orderings/&lt;int:pk>/', OrderingRetrieveView.as_view()),  # Получаем определённого заказа по pk
path('orderings/update/&lt;int:pk>/', OrderingUpdateView.as_view()),  # Обновляем определённого заказа по pk
path('orderings/new/', OrderingCreateView.as_view()),  # Создаём определённого заказа
path('orderings/all/', OrderingListView.as_view()),  # Получаем список определённых заказов

path('messages/&lt;int:pk>/', MessageRetrieveView.as_view()),  # Получаем Сообщение по pk
path('messages/update/&lt;int:pk>/', MessageUpdateView.as_view()),  # Обновляем Сообщение по pk
path('messages/new/', MessageCreateView.as_view()),  # Создаём Сообщение
path('messages/all/', MessageListView.as_view()),  # Получаем список Сообщений

path('tickets/&lt;int:pk>/', TicketRetrieveView.as_view()),  # Получаем Тикет по pk
path('tickets/update/&lt;int:pk>/', TicketUpdateView.as_view()),  # Обновляем Тикет по pk
path('tickets/new/', TicketCreateView.as_view()),  # Создаём Тикет
path('tickets/all/', TicketListView.as_view()),  # Получаем список Тикетов

path('authorings/&lt;int:pk>/', AuthoringRetrieveView.as_view()),  # Получаем Автора_ревью по pk
path('authorings/update/&lt;int:pk>/', AuthoringUpdateView.as_view()),  # Обновляем Автора_ревью по pk
path('authorings/new/', AuthoringCreateView.as_view()),  # Создаём Автора_ревью
path('authorings/all/', AuthoringListView.as_view()),  # Получаем список Авторов_ревью</pre>
					</li>
					<li>
						Представления для модели - Review - будет отличаться, у этой модели всего 1 сериализатор и будет 3 представления (получение и обновление будет совмещнено) - [generics.RetriveUpdateAPIView]
						<br>views.py
						<pre>
# API - Ревью, получение по pk + обновление
class ReviewRetrieveUpdateView(generics.RetrieveUpdateAPIView):
    queryset = Review.objects.all()
    serializer_class = ReviewSerializer
    
    
# API - Ревью, создание
class ReviewCreateView(generics.CreateAPIView):
    queryset = Review.objects.all()
    serializer_class = ReviewSerializer


# API - список Ревью
class ReviewListView(generics.ListAPIView):
    queryset = Review.objects.all()
    serializer_class = ReviewSerializer</pre>
						Тем не менне маршрута(api endpoint) сделаем 4, как у всех остальных
						<br><strong>Для получения и редактирования ревью, 2 разных эндпойнта но 1 общий класс представления</strong>
						<pre>
path('reviews/&lt;int:pk>/', ReviewRetrieveUpdateView.as_view()),  # Получаем Ревью по pk
path('reviews/update/&lt;int:pk>/', ReviewRetrieveUpdateView.as_view()),  # Обновляем Ревью по pk
path('reviews/new/', ReviewCreateView.as_view()),  # Создаём Ревью
path('reviews/all/', ReviewListView.as_view()),  # Получаем список Ревью</pre>
					</li>
					<li>
						В брайзере перейдём по url
						<pre>http://127.0.0.1:8000/api/</pre>
						Увидим все endpoints и маршурты, которые есть в списке urlpatterns
						<pre>
admin/
api/ executors/&lt;int:pk>/
api/ executors/update/&lt;int:pk>/
api/ executors/new/
api/ executors/all/
api/ customers/&lt;int:pk>/
api/ customers/update/&lt;int:pk>/
api/ customers/new/
api/ customers/all/
api/ orders/&lt;int:pk>/
api/ orders/update/&lt;int:pk>/
api/ orders/new/
api/ orders/all/
api/ services/&lt;int:pk>/
api/ services/update/&lt;int:pk>/
api/ services/new/
api/ services/all/
api/ tags/&lt;int:pk>/
api/ tags/update/&lt;int:pk>/
api/ tags/new/
api/ tags/all/
api/ orderings/&lt;int:pk>/
api/ orderings/update/&lt;int:pk>/
api/ orderings/new/
api/ orderings/all/
api/ messages/&lt;int:pk>/
api/ messages/update/&lt;int:pk>/
api/ messages/new/
api/ messages/all/
api/ tickets/&lt;int:pk>/
api/ tickets/update/&lt;int:pk>/
api/ tickets/new/
api/ tickets/all/
api/ authorings/&lt;int:pk>/
api/ authorings/update/&lt;int:pk>/
api/ authorings/new/
api/ authorings/all/
api/ reviews/&lt;int:pk>/
api/ reviews/update/&lt;int:pk>/
api/ reviews/new/
api/ reviews/all/</pre>
					</li>
<hr>
<h3 class="text-danger">Фильтры в API Views</h3>
					<li>
						Добавлю пару записей в таблику Service - через админку
					</li>
					<li>
						<strong class="text-danger">Пишу фильтры</strong> для услуг, представление ServiceListView.
						<br>views.py ищменяю представление ServiceListView
						<pre>
# API представление для списка Услуг
class ServiceListView(generics.ListAPIView):
    # queryset = Service.objects.all()
    serializer_class = ServiceSerializer

    # переопределяю queryset (фильтр)
    def get_queryset(self):
        # изначально беру все записи, будут выводить если фильтры не используются
        queryset = Service.objects.all()
        <strong class="text-danger"># params - своя переменная. В неё запишем все параметры, что получаем из request</strong>
        params = self.request.query_params

        """ Буду фильтровать по полям service_type, price, executor"""
        # к переменной service_type - присваиваем то, что написано в браузерной строке, то есть в гет запросе
        # т.е. если в адресной строке будет написано service(это ключи)=значение, если ничего присвоим просто None
        service_type = params.get('service', None)
        price = params.get('price', None)
        executor = params.get('executor', None)

        # проверяем, написано ли что-то в адресной строке, связанное с service_type
        if service_type:
            # если написано, фильтруем по полю service_type) - изменяем queryset, добавив фильтр
            <strong class="text-danger"># queryset.filter(поле_в_модели=переменная_в_текущем_представлении)</strong>
            queryset = queryset.filter(service_type=service_type)

        # фильтр по цене
        if price:
            # lte - это меньше или равно (<=)
            <strong class="text-danger">queryset = queryset.filter(price__lte=price)</strong>

        # фильтр по исполнителю
        if executor:
            # executor__id - это обращение к модели Executor к полю id, через текущую модель Service (ForeignKey)
            <strong class="text-danger">queryset = queryset.filter(executor__id=executor)</strong>

	        <strong class="text-danger"># обязательно возвращаем queryset</strong>
	        return queryset</pre>
	        			Для проверки фильтра в поле браузера пишем
	        			<pre>
# получаем <strong class="text-danger">весь список записей модели</strong>, без филтров
http://127.0.0.1:8000/api/services/all/

# получаем только <strong class="text-danger">записи исполнителя с pk/id = 2</strong>
http://127.0.0.1:8000/api/services/all/<strong class="text-danger">?executor=2</strong>

# записи <strong class="text-danger">исполнителя с id=2 + ценой услуги = 3000</strong>
http://127.0.0.1:8000/api/services/all/<strong class="text-danger">?executor=2&price=3000</strong>

# записи <strong class="text-danger">исполнителя с id=2 + ценой услуги = 3000 + вебразработка (чойс 1 в модели)</strong>
# service = это переменная в классе представления, добавляли сами
http://127.0.0.1:8000/api/services/all/<strong class="text-danger">?executor=2&price=3000&service=1</strong>
</pre>
					</li>
					<li>
						Аналогично пишем фильтры для модели Order (заказы), представление OrderListView
						<pre>
# API представление для списка Заказов
class OrderListView(generics.ListAPIView):
    serializer_class = OrderSerializer

    # переопределяю queryset (фильтр)
    def get_queryset(self):
        queryset = Order.objects.all()  # весь список
        params = self.request.query_params  # параметры request

        order_type = params.get('order', None)  # ?order=1
        price = params.get('price', None)  # ?price=3000
        customer = params.get('customer', None)  # ?customer=pk/id

        # проверяем в адресной строке '?order=...'
        if order_type:
            # если записи есть применяем фильтр
            # queryset.filter(поле_модели=вышеуказанная_переменная)
            queryset = queryset.filter(order_type=order_type)

        # фильтр по цене
        if price:
            # lte - это меньше или равно (<=)
            queryset = queryset.filter(price__lte=price)

        # фильтр по заказчику
        if customer:
            # executor__id - Service (ForeignKey) --> Customer ->pd/id
            queryset = queryset.filter(customer__id=customer)

        # обязательно возвращаем queryset
        return queryset</pre>
					</li>
					<li>
						Аналогично для модели Message
						<br>Фильтры в представлении MessageListView
						<pre>
# API представление для списка Сообщений
class MessageListView(generics.ListAPIView):
    serializer_class = MessageSerializer

    # переопределяю queryset (фильтр)
    def get_queryset(self):
        queryset = Message.objects.all()  # весь список

        params = self.request.query_params

        # None - это default=None
        executor = params.get('executor', None)  # фильтр по исполнителю
        customer = params.get('customer', None)  # фильтр по заказчику
        from_date = params.get('from_date', None)  # фильтр по дате сообщений (от)
        to_date = params.get('to_date', None)  # фильтр по дате сообщений (до)

        # применяем фильтры, если в адресной строке есть совпадения
        if executor:
            queryset = queryset.filter(executor__id=executor)

        if customer:
            queryset = queryset.filter(customer__id=customer)

        if from_date:
            # msg_date - поле модели Message
            # msg_date__gte - >=, т.е msg_date >= from_date (фильтр от даты)
            queryset = queryset.filter(msg_date__gte=from_date)

        if to_date:
            # msg_date__lte - <=, т.е msg_date >= to_date (фильтр до даты)
            queryset = queryset.filter(msg_gate__lte=to_date)

        return queryset</pre>
					</li>
<hr>
<h3 class="text-danger">Итог</h3>

					<li>
						Написал все endpoints и API views, для некоторых представлений добавлены фильтры
						<br>
						<br>
						Полный views.py
						<pre>
# from django.shortcuts import render  # обычный render не используется в DRF

from rest_framework.response import Response  # для создания ответа
from rest_framework import generics

# импорт всех моделей и сериализаторов
from .models import *
from .serializers import *

from rest_framework.views import APIView


#____________________________________________________________________________________________
# API представление Исполнителя - получить по pk
class ExecutorRetrieveView(generics.RetrieveAPIView):
    queryset = Executor.objects.all()
    serializer_class = ExecutorSerializer


# API представление Исполнителя для обновления данных (по pk)
class ExecutorUpdateView(generics.UpdateAPIView):
    queryset = Executor.objects.all()
    serializer_class = CreateExecutorSerializer


# API представление Исполнителя для создания записи (по pk)
class ExecutorCreateView(generics.CreateAPIView):
    queryset = Executor.objects.all()
    serializer_class = CreateExecutorSerializer


# API представление для списка Исполнителей
class ExecutorListView(generics.ListAPIView):
    queryset = Executor.objects.all()
    serializer_class = ExecutorSerializer
#____________________________________________________________________________________________


# API представление Заказчика - получить по pk
class CustomerRetrieveView(generics.RetrieveAPIView):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer


# API представление Заказчика для обновления данных (по pk)
class CustomerUpdateView(generics.UpdateAPIView):
    queryset = Customer.objects.all()
    serializer_class = CreateCustomerSerializer


# API представление Заказчика для создания записи (по pk)
class CustomerCreateView(generics.CreateAPIView):
    queryset = Customer.objects.all()
    serializer_class = CreateCustomerSerializer


# API представление для списка Заказчиков
class CustomerListView(generics.ListAPIView):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer


# API представление Заказа - получить по pk
class OrderRetrieveView(generics.RetrieveAPIView):
    queryset = Order.objects.all()
    serializer_class = OrderSerializer


# API представление Заказа для обновления данных (по pk)
class OrderUpdateView(generics.UpdateAPIView):
    queryset = Order.objects.all()
    serializer_class = CreateOrderSerializer


# API представление Заказа для создания записи (по pk)
class OrderCreateView(generics.CreateAPIView):
    queryset = Order.objects.all()
    serializer_class = CreateOrderSerializer


# API представление для списка Заказов
class OrderListView(generics.ListAPIView):
    serializer_class = OrderSerializer

    # переопределяю queryset (фильтр)
    def get_queryset(self):
        queryset = Order.objects.all()  # весь список
        params = self.request.query_params  # параметры request

        order_type = params.get('order', None)  # ?order=1
        price = params.get('price', None)  # ?price=3000
        customer = params.get('customer', None)  # ?customer=pk/id

        # проверяем в адресной строке '?order=...'
        if order_type:
            # если записи есть применяем фильтр
            # queryset.filter(поле_модели=вышеуказанная_переменная)
            queryset = queryset.filter(order_type=order_type)

        # фильтр по цене
        if price:
            # lte - это меньше или равно (<=)
            queryset = queryset.filter(price__lte=price)

        # фильтр по заказчику
        if customer:
            # executor__id - Service (ForeignKey) --> Customer ->pd/id
            queryset = queryset.filter(customer__id=customer)

        # обязательно возвращаем queryset
        return queryset


# API представление Услуги - получить по pk
class ServiceRetrieveView(generics.RetrieveAPIView):
    queryset = Service.objects.all()
    serializer_class = ServiceSerializer


# API представление Услуги для обновления данных (по pk)
class ServiceUpdateView(generics.UpdateAPIView):
    queryset = Service.objects.all()
    serializer_class = CreateServiceSerializer


# API представление Услуги для создания записи (по pk)
class ServiceCreateView(generics.CreateAPIView):
    queryset = Service.objects.all()
    serializer_class = CreateServiceSerializer


# API представление для списка Услуг
class ServiceListView(generics.ListAPIView):
    serializer_class = ServiceSerializer

    # переопределяю queryset (фильтр)
    def get_queryset(self):
        # изначально беру все записи, будут выводить если фильтры не используются
        queryset = Service.objects.all()
        # params - своя переменная. В неё запишем все параметры, что получаем из request
        params = self.request.query_params

        # """ Буду фильтровать по полям service_type, price, executor"""
        # Переменной service_type - присваиваем то, что написано в браузерной строке, то есть в гет запросе
        # т.е. если в адресной строке будет написано service(это ключи)=значение, если ничего присвоим просто None
        service_type = params.get('service', None)
        price = params.get('price', None)
        executor = params.get('executor', None)

        # проверяем, написано ли что-то в адресной строке, связанное с service_type
        if service_type:
            # если написано, фильтруем по полю service_type - изменяем queryset, добавив фильтр
            # queryset.filter(поле_в_модели=переменная_в_текущем_представлении)
            queryset = queryset.filter(service_type=service_type)

        # фильтр по цене
        if price:
            # lte - это меньше или равно (<=)
            queryset = queryset.filter(price__lte=price)

        # фильтр по исполнителю
        if executor:
            # executor__id - это обращение к модели Executor к полю id, через текущую модель Service (ForeignKey)
            queryset = queryset.filter(executor__id=executor)

        # обязательно возвращаем queryset
        return queryset


# API представление Тега - получить по pk
class TagRetrieveView(generics.RetrieveAPIView):
    queryset = Tag.objects.all()
    serializer_class = TagSerializer


# API представление Тега для обновления данных (по pk)
class TagUpdateView(generics.UpdateAPIView):
    queryset = Tag.objects.all()
    serializer_class = CreateTagSerializer


# API представление Тега для создания записи (по pk)
class TagCreateView(generics.CreateAPIView):
    queryset = Tag.objects.all()
    serializer_class = CreateTagSerializer


# API представление для списка Тегов
class TagListView(generics.ListAPIView):
    queryset = Tag.objects.all()
    serializer_class = TagSerializer


# API представление определённого заказа - получить по pk
class OrderingRetrieveView(generics.RetrieveAPIView):
    queryset = Ordering.objects.all()
    serializer_class = OrderingSerializer


# API представление определённого заказа для обновления данных (по pk)
class OrderingUpdateView(generics.UpdateAPIView):
    queryset = Ordering.objects.all()
    serializer_class = CreateOrderingSerializer


# API представление определённого заказа для создания записи (по pk)
class OrderingCreateView(generics.CreateAPIView):
    queryset = Ordering.objects.all()
    serializer_class = CreateOrderingSerializer


# API представление для списка определённого заказов
class OrderingListView(generics.ListAPIView):
    queryset = Ordering.objects.all()
    serializer_class = OrderingSerializer


# API представление Сообщения - получить по pk
class MessageRetrieveView(generics.RetrieveAPIView):
    queryset = Message.objects.all()
    serializer_class = MessageSerializer


# API представление Сообщения для обновления данных (по pk)
class MessageUpdateView(generics.UpdateAPIView):
    queryset = Message.objects.all()
    serializer_class = CreateMessageSerializer


# API представление Сообщения для создания записи (по pk)
class MessageCreateView(generics.CreateAPIView):
    queryset = Message.objects.all()
    serializer_class = CreateMessageSerializer


# API представление для списка Сообщений
class MessageListView(generics.ListAPIView):
    serializer_class = MessageSerializer

    # переопределяю queryset (фильтр)
    def get_queryset(self):
        queryset = Message.objects.all()  # весь список

        params = self.request.query_params

        # None - это default=None
        executor = params.get('executor', None)  # фильтр по исполнителю
        customer = params.get('customer', None)  # фильтр по заказчику
        from_date = params.get('from_date', None)  # фильтр по дате сообщений (от)
        to_date = params.get('to_date', None)  # фильтр по дате сообщений (до)

        # применяем фильтры, если в адресной строке есть совпадения
        if executor:
            queryset = queryset.filter(executor__id=executor)

        if customer:
            queryset = queryset.filter(customer__id=customer)

        if from_date:
            # msg_date - поле модели Message
            # msg_date__gte - >=, т.е msg_date >= from_date (фильтр от даты)
            queryset = queryset.filter(msg_date__gte=from_date)

        if to_date:
            # msg_date__lte - <=, т.е msg_date >= to_date (фильтр до даты)
            queryset = queryset.filter(msg_gate__lte=to_date)

        return queryset


# API представление Тикета - получить по pk
class TicketRetrieveView(generics.RetrieveAPIView):
    queryset = Ticket.objects.all()
    serializer_class = TicketSerializer


# API представление Тикета для обновления данных (по pk)
class TicketUpdateView(generics.UpdateAPIView):
    queryset = Ticket.objects.all()
    serializer_class = CreateTicketSerializer


# API представление Тикета для создания записи (по pk)
class TicketCreateView(generics.CreateAPIView):
    queryset = Ticket.objects.all()
    serializer_class = CreateTicketSerializer


# API представление для списка Тикетов
class TicketListView(generics.ListAPIView):
    queryset = Ticket.objects.all()
    serializer_class = TicketSerializer


# API представление Автора_ревью - получить по pk
class AuthoringRetrieveView(generics.RetrieveAPIView):
    queryset = Authoring.objects.all()
    serializer_class = AuthoringSerializer


# API представление Автора_ревью для обновления данных (по pk)
class AuthoringUpdateView(generics.UpdateAPIView):
    queryset = Authoring.objects.all()
    serializer_class = CreateAuthoringSerializer


# API представление Автора_ревью для создания записи (по pk)
class AuthoringCreateView(generics.CreateAPIView):
    queryset = Authoring.objects.all()
    serializer_class = CreateAuthoringSerializer


# API представление для списка Авторов_ревью
class AuthoringListView(generics.ListAPIView):
    queryset = Authoring.objects.all()
    serializer_class = AuthoringSerializer


# API - Ревью, получение по pk + обновление
class ReviewRetrieveUpdateView(generics.RetrieveUpdateAPIView):
    queryset = Review.objects.all()
    serializer_class = ReviewSerializer


# API - Ревью, создание
class ReviewCreateView(generics.CreateAPIView):
    queryset = Review.objects.all()
    serializer_class = ReviewSerializer


# API - список Ревью
class ReviewListView(generics.ListAPIView):
    queryset = Review.objects.all()
    serializer_class = ReviewSerializer</pre>
						Полный urls.py
						<pre>
from django.urls import path  # стандартно - маршруты
from django.urls import include  # для расширения маршрутов из других приложений
from .views import *  # все представления из приложения

# список маршрутов
urlpatterns = [
    # путь('url'/, класс_представления.as_view()/функция представления, name='имя_маршрута'),
    path('executors/&lt;int:pk>/', ExecutorRetrieveView.as_view()),  # Получаем исполнителя по pk
    path('executors/update/&lt;int:pk>/', ExecutorUpdateView.as_view()),  # Обновляем исполнителя по pk
    path('executors/new/', ExecutorCreateView.as_view()),  # Создаём исполнителя
    path('executors/all/', ExecutorListView.as_view()),  # Получаем список исполнителей

    path('customers/&lt;int:pk>/', CustomerRetrieveView.as_view()),  # Получаем заказчика по pk
    path('customers/update/&lt;int:pk>/', CustomerUpdateView.as_view()),  # Обновляем заказчика по pk
    path('customers/new/', CustomerCreateView.as_view()),  # Создаём заказчика
    path('customers/all/', CustomerListView.as_view()),  # Получаем список заказчиков

    path('orders/&lt;int:pk>/', OrderRetrieveView.as_view()),  # Получаем заказа по pk
    path('orders/update/&lt;int:pk>/', OrderUpdateView.as_view()),  # Обновляем заказ по pk
    path('orders/new/', OrderCreateView.as_view()),  # Создаём заказ
    path('orders/all/', OrderListView.as_view()),  # Получаем список заказов

    path('services/&lt;int:pk>/', ServiceRetrieveView.as_view()),  # Получаем услугу по pk
    path('services/update/&lt;int:pk>/', ServiceUpdateView.as_view()),  # Обновляем услугу по pk
    path('services/new/', ServiceCreateView.as_view()),  # Создаём услугу
    path('services/all/', ServiceListView.as_view()),  # Получаем список услуг

    path('tags/&lt;int:pk>/', TagRetrieveView.as_view()),  # Получаем тег по pk
    path('tags/update/&lt;int:pk>/', TagUpdateView.as_view()),  # Обновляем тег по pk
    path('tags/new/', TagCreateView.as_view()),  # Создаём тег
    path('tags/all/', TagListView.as_view()),  # Получаем список тегов

    path('orderings/&lt;int:pk>/', OrderingRetrieveView.as_view()),  # Получаем определённого заказа по pk
    path('orderings/update/&lt;int:pk>/', OrderingUpdateView.as_view()),  # Обновляем определённого заказа по pk
    path('orderings/new/', OrderingCreateView.as_view()),  # Создаём определённого заказа
    path('orderings/all/', OrderingListView.as_view()),  # Получаем список определённых заказов

    path('messages/&lt;int:pk>/', MessageRetrieveView.as_view()),  # Получаем Сообщение по pk
    path('messages/update/&lt;int:pk>/', MessageUpdateView.as_view()),  # Обновляем Сообщение по pk
    path('messages/new/', MessageCreateView.as_view()),  # Создаём Сообщение
    path('messages/all/', MessageListView.as_view()),  # Получаем список Сообщений

    path('tickets/&lt;int:pk>/', TicketRetrieveView.as_view()),  # Получаем Тикет по pk
    path('tickets/update/&lt;int:pk>/', TicketUpdateView.as_view()),  # Обновляем Тикет по pk
    path('tickets/new/', TicketCreateView.as_view()),  # Создаём Тикет
    path('tickets/all/', TicketListView.as_view()),  # Получаем список Тикетов

    path('authorings/&lt;int:pk>/', AuthoringRetrieveView.as_view()),  # Получаем Автора_ревью по pk
    path('authorings/update/&lt;int:pk>/', AuthoringUpdateView.as_view()),  # Обновляем Автора_ревью по pk
    path('authorings/new/', AuthoringCreateView.as_view()),  # Создаём Автора_ревью
    path('authorings/all/', AuthoringListView.as_view()),  # Получаем список Авторов_ревью

    path('reviews/&lt;int:pk>/', ReviewRetrieveUpdateView.as_view()),  # Получаем Ревью по pk
    path('reviews/update/&lt;int:pk>/', ReviewRetrieveUpdateView.as_view()),  # Обновляем Ревью по pk
    path('reviews/new/', ReviewCreateView.as_view()),  # Создаём Ревью
    path('reviews/all/', ReviewListView.as_view()),  # Получаем список Ревью
]
</pre>
					</li>
				</ol>

			</li>

&lt;




			<li>
				<hr><h1 class="title_text">5. DJANGO REST РЕГИСТРАЦИЯ + АВТОРИЗАЦИЯ / DJOSER, JWT (TOKENs, DRF, JWT)</h1><hr>
				<ol>
					<li>
						Авторизация пользователя. Можно сделать с помощью джанги, на бэке (например djoser), или на фронте, с помощью JWT (JSON Web Token)
					</li>
<hr>
<h3 class="text-danger">Авторизация Django + DRF + Djoser (на бекэнде)</h3>

					<li>
						В settings.py в INSTALLED_APPS - добавляю
						<pre>
INSTALLED_APPS = [
	...
    '...',  # DRF
    'rest_framework.authtoken',  # для auth - с помощью джанги
    '....',  # djoser
    '...',  # corsheaders
]</pre>
					</li>
					<li>
						В freelance(app)/urls.py - импортирую obtain_auth_token
						<pre>
from rest_framework.authtoken.views import obtain_auth_token  # для аутентификации</pre>
					</li>
					<li>
						В urlpatterns добавляю 2 маршрута
						<pre>
urlpatterns = [
    # маршруты для получения токенов аутентификации
    path('auth/', include('djoser.urls')),  # здесь urls джосера, для регистрации и авторизации
    path('auth/token', obtain_auth_token, name='token'),

    ...
    ...
]</pre>
						<strong>По факту по auth/token - будеи получать сам токен</strong>
					</li>
					<li>
						Во views.py - импортирую пермигены и статусы ответов
						<pre>
# проверка авторизованности
# статусы выполнения 200/404 и ид
from rest_framework import permissions, status  # проверка авторизованности</pre>

					</li>
					<li>
						Пишу представление для Logout. 
						<br>views.py
						<pre>
# представление Logout
class Logout(APIView):
    """ Будем получать пользователя, и из его данных удаляем токен, возвращаем статус 200"""
    def get(self, request, format=None):
        request.user.auth_token.delete()  # удаляем токен
        return Response(status=status.HTTP_200_OK)  # Отвечаем - 200 OK</pre>
        				Пишу представление для Logout - views.py
        				<pre>path('auth/logout', Logout.as_view()),  # выйти</pre>
					</li>
					<li>
						Во views.py - 'защитим' все представления, которые только для авторизованных пользователей.
						<br>Добавлю пермишены, для представлений (Update and Create) - кроме Create Executor and Customer - так как нелогично, запрещать создавать нового пользователя
						<pre>
# API представление Исполнителя для обновления данных (по pk)
class ExecutorUpdateView(generics.UpdateAPIView):
    queryset = Executor.objects.all()
    serializer_class = CreateExecutorSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>


# API представление Исполнителя для создания записи (по pk)
class ExecutorCreateView(generics.CreateAPIView):
    queryset = Executor.objects.all()
    serializer_class = CreateExecutorSerializer



# API представление Заказчика для обновления данных (по pk)
class CustomerUpdateView(generics.UpdateAPIView):
    queryset = Customer.objects.all()
    serializer_class = CreateCustomerSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>


# API представление Заказчика для создания записи (по pk)
class CustomerCreateView(generics.CreateAPIView):
    queryset = Customer.objects.all()
    serializer_class = CreateCustomerSerializer

    

# API представление Заказа для обновления данных (по pk)
class OrderUpdateView(generics.UpdateAPIView):
    queryset = Order.objects.all()
    serializer_class = CreateOrderSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>


# API представление Заказа для создания записи (по pk)
class OrderCreateView(generics.CreateAPIView):
    queryset = Order.objects.all()
    serializer_class = CreateOrderSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>



# API представление Услуги для обновления данных (по pk)
class ServiceUpdateView(generics.UpdateAPIView):
    queryset = Service.objects.all()
    serializer_class = CreateServiceSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>


# API представление Услуги для создания записи (по pk)
class ServiceCreateView(generics.CreateAPIView):
    queryset = Service.objects.all()
    serializer_class = CreateServiceSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>



# API представление Тега для обновления данных (по pk)
class TagUpdateView(generics.UpdateAPIView):
    queryset = Tag.objects.all()
    serializer_class = CreateTagSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>


# API представление Тега для создания записи (по pk)
class TagCreateView(generics.CreateAPIView):
    queryset = Tag.objects.all()
    serializer_class = CreateTagSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>



# API представление определённого заказа для обновления данных (по pk)
class OrderingUpdateView(generics.UpdateAPIView):
    queryset = Ordering.objects.all()
    serializer_class = CreateOrderingSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>


# API представление определённого заказа для создания записи (по pk)
class OrderingCreateView(generics.CreateAPIView):
    queryset = Ordering.objects.all()
    serializer_class = CreateOrderingSerializer
    # тип пользователя - авторизован или только для чтения
    
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>


# API представление Сообщения для обновления данных (по pk)
class MessageUpdateView(generics.UpdateAPIView):
    queryset = Message.objects.all()
    serializer_class = CreateMessageSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>

# API представление Сообщения для создания записи (по pk)
class MessageCreateView(generics.CreateAPIView):
    queryset = Message.objects.all()
    serializer_class = CreateMessageSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>



# API представление Тикета для обновления данных (по pk)
class TicketUpdateView(generics.UpdateAPIView):
    queryset = Ticket.objects.all()
    serializer_class = CreateTicketSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>


# API представление Тикета для создания записи (по pk)
class TicketCreateView(generics.CreateAPIView):
    queryset = Ticket.objects.all()
    serializer_class = CreateTicketSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>



# API представление Автора_ревью для обновления данных (по pk)
class AuthoringUpdateView(generics.UpdateAPIView):
    queryset = Authoring.objects.all()
    serializer_class = CreateAuthoringSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>


# API представление Автора_ревью для создания записи (по pk)
class AuthoringCreateView(generics.CreateAPIView):
    queryset = Authoring.objects.all()
    serializer_class = CreateAuthoringSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>


# API - Ревью, получение по pk + обновление
class ReviewRetrieveUpdateView(generics.RetrieveUpdateAPIView):
    queryset = Review.objects.all()
    serializer_class = ReviewSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>


# API - Ревью, создание
class ReviewCreateView(generics.CreateAPIView):
    queryset = Review.objects.all()
    serializer_class = ReviewSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>
					</li>
<hr>
<h3 class="text-danger">Проверка пермишенов в Postman</h3>
					<li>
						Создаю и применяю миграции
						<pre>
python manage.py makemigrations
python manage.py migrate</pre>
					</li>
					<li>
						Запускаю сервер
					</li>
					<li>
						В Postman - перехожу по урлу
						<pre>127.0.0.1:8000/api/auth/users/</pre>
						<ul>
							<li>POST - запрос</li>
							<li>Body</li>
							<li>form-data</li>
						</ul>
						Пишет что username and password - обязательные поля
						<br>По вышеуказанным параметрам (url body и тд) добавляю два поля (придумываю значения сам) 
						<br> <strong class="text-danger">Здесь мы регистрируем пользователя через Postman</strong>
						<ul>
							<li>Key - username; Value - alex</li>
							<li>Key - password; Value - aLEx1234aLEx</li>
						</ul>
						<br>
						<strong>И отправляю запрос в postman</strong>
						<br>
						postman я так понимаю создал пользователя
						<pre>
{
    "email": "",
    "username": "alex",
    "id": 7
}</pre>
					</li>
					<li>
						Пробую <strong class="text-danger">Залогинится через постман</strong>
						<br>Postman - новый запрос
						<ul>
							<li><pre>127.0.0.1:8000/api/auth/token</pre></li>
							<li>POST - запрос</li>
							<li>Body</li>
							<li>form-data</li>
							<li>Key - username; Value - alex</li>
							<li>Key - password; Value - aLEx1234aLEx</li>
						</ul>
						<br>Выполняю запрос - SEND
						<br>Postman отдаёт токен
						<pre>
{
    "token": "349dfb7dfe23889347ea551dbe68a6234b88f6d0"
}</pre>
						Этот токен будем использовать, для доступа к views - где писали permissions
					</li>
					<li>
						Пробую через браузер, получить доступ к permissons view
						<pre>http://127.0.0.1:8000/api/executors/update/1/</pre>
						Выдаст JSON
						<pre>
<strong class="text-danger">HTTP 405 Method Not Allowed</strong>
Allow: PUT, PATCH, OPTIONS
Content-Type: application/json
Vary: Accept

{
    "detail": "Метод \"GET\" не разрешен."
}</pre>
					HTTP 405 Method Not Allowed - означает что метод неразрешён, так как это представление тольно для залогиненных пользователей
					</li>
					<li>
						В Postman - пробую изменить данные пользователя.
						<ul>
							<li><pre>http://127.0.0.1:8000/api/executors/update/1/</pre></li>
							<li>PATCH - запрос</li>
							<li>Body</li>
							<li>form-data</li>
							<li>Key - phone; Value - 89999990000</li>
						</ul>
						Получаю запрет - т.к неавторизован
						<pre>
{
    "detail": "Учетные данные не были предоставлены."
}</pre>
					</li>
					<li>
						В Postman - изменяю данные, добавив токен
						<ol>
							<li><pre>http://127.0.0.1:8000/api/executors/update/1/</pre></li>
							<li>PATCH - запрос</li>
							<li>Headers: Key - Authorization; Value - Token 349dfb7dfe23889347ea551dbe68a6234b88f6d0</li>
							<li>Body</li>
							<li>form-data</li>
							<li>Key - phone; Value - 89999990000</li>
						</ol>
						<strong>Данные изменились!</strong>
						<br>Можно убедится в браузере
						<pre>http://127.0.0.1:8000/api/executors/all/</pre>
					</li>
<hr>
<h3 class="text-danger">Авторизация Djoser + JWT (на фронтэнде)</h3>
					<li>
						<strong class="text-danger">Устанавливаю библиотеку, который отвечает за модуль JWT - для django rest framework</strong>
						<pre>pip install djangorestframework_simplejwt</pre>
					</li>
					<li>
						В settings.py, в INSTALLED_APPS - комментирую,
						<pre># 'rest_framework.authtoken',  # для auth - с помощью джанги</pre>
					</li>
					<li>
						В settings.py - после CORL_ALLOW_METHODS - добавлю настройки, для того чтобы заработал JSON TOKEN (JWT)
						<pre>
REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
    "DEFAULT_PARSER_CLASSES": [
        "rest_framework.parsers.JSONParser",
    ],
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "rest_framework.authentication.SessionAuthentication",
        "rest_framework_simplejwt.authentication.JWTAuthentication",
        # "oauth2_provider.contrib.rest_framework.OAuth2Authentication",
        # "rest_framework_social_oauth2.authentication.SocialAuthentication",
    ],
}</pre>
					</li>
					<li>
						В urls.py (freelance app) - коментирую obtain_token, маршруты токена и Logout
						<pre>
# from rest_framework.authtoken.views import obtain_auth_token  # для аутентификации (django token)

# path('auth/token', obtain_auth_token, name='token'),  # django token
# path('auth/logout', Logout.as_view()),  # выйти</pre>
					</li>
					<li>
						В urls.py импортирую необходимые модули для JWT, пишу маршрут JWT токена
						<pre>
from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView  # JWT токен

# JWT токен
path('token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
path('token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),</pre>
					</li>
					<li>
						views.py - необходим импорт permissions (уже есть), импортируем exceptions.PermissionDenied
						<pre>
from rest_framework.exceptions import PermissionDenied  # для JWT</pre>
					</li>
					<li>
						Пишу пермишен для исполнители и заказчика
						<br><span>Permissions классы - желательно делать в отдельном файле</span>, но в рамках курса, пишем в views.py
						<pre>
# permission для Исполнителя
class IsExecutor(permissions.BasePermission):
    """ Проверяет есть ли у Исполнителя доступ """
    def has_object_permission(self, request, view, obj):
        return obj.user == request.user</pre>
        				Меняю permission - для ExecutorUpdateView, и так же переопрелеляю get_queryset
        				<pre>
# API представление Исполнителя для обновления данных (по pk)
class ExecutorUpdateView(generics.UpdateAPIView):
    queryset = Executor.objects.all()
    serializer_class = CreateExecutorSerializer
    <strong class="text-danger"># разрешено только исполнителю
    permission_classes = (IsExecutor,)</strong>

    # переопределяю queryset
    def get_queryset(self):
        # пользователь = текущий пользователь из request
        user = self.request.user

        # если пользователь авторизован
        if user.is_authenticated:
            # возвращаем инфу именно по авторизованному пользователю
            return Executor.objects.filter(user=user)
        # отработка исключения - "В доступе отказано"
        raise PermissionDenied()</pre>
					</li>
					<li>
						Пробую получить токен в postman
						<ol>
							<li>url <pre>http://127.0.0.1:8000/api/token/</pre></li>
							<li>Body</li>
							<li>raw</li>
							<li>JSON</li>
							<li><pre>{"username":"alex", "password":"aLEx1234aLEx"}</pre></li>
						</ol>
						<br>Получили ответ с refresh и access токенами:
						<pre>
{
    "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTY3ODYzNjA2MiwianRpIjoiNWJhYzc4ZjQxZTZhNGI0NGE0NGE1YjMwNmE4ZWE1Y2QiLCJ1c2VyX2lkIjo3fQ.39zwRwswVpLZ8uNMT6dLlrjG-Qwy9XKAQy3of71dJGE",
    "access": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNjc4NTQ5OTYyLCJqdGkiOiJhNWYwMDI5ZDUyMzY0MWQwOWViNTNhZDE2ZjAwNWI3ZiIsInVzZXJfaWQiOjd9.QAfyv94MJfmwyswXnpF876zIXe2_Y9CDMn4vW2rY6dw"
}</pre>

					</li>
					<li>
						Пробую изменить данные исполнителя через postman
						<ol>
							<li>url <pre>http://127.0.0.1:8000/api/executors/update/2/</pre></li>
							<li>PATCH</li>
							<li>Headers - KEY: Authorization, VALUE: (access токен)_</li>
							<li>Body</li>
							<li>raw</li>
							<li>JSON</li>
							<li><pre>{
    "phone": "80001112233"
}</pre>
							</li>
						</ol>
						Запрос будет отклонён, так как пользователь alex не является исполнителем в целом, и не является исполнителем с id = 3
					</li>
<hr>
<h3 class="text-danger">Получаю токен нужного исполнителя и меняю данные в postman</h3>
					<li>
						Получаю токен
						<ol>
							<li>url <pre>http://127.0.0.1:8000/api/token/</pre></li>
							<li>Body</li>
							<li>raw</li>
							<li>JSON</li>
							<li><pre>{"username":"Исполнитель2", "password":"blog1234"}</pre>
							Это executor с pk/id = 3
							</li>
						</ol>
					</li>
					<li>
						Копирую access token - которые получили в ответе postman
					</li>
					<li>
						Меняю данные
						<ol>
							<li>url <pre>http://127.0.0.1:8000/api/executors/update/2/</pre></li>
							<li>PATCH</li>
							<li>Headers - KEY: Authorization, VALUE: (access_токен_без кавычек)</li>
							<li>Body</li>
							<li>raw</li>
							<li>JSON</li>
							<li><pre>{
    "phone": "80008880088"
}</pre>
							</li>
						</ol>
						<strong>Данные успешно изменились!</strong>
						<br>Можно перепроверить в браузере, то что данные изменились
						<pre>http://127.0.0.1:8000/api/executors/3/</pre>
					</li>
<hr>
<h3 class="text-danger">Главное оличие использование стандартного токена django или JWT</h3>					
					<li>
						<ul>
							<li>При использованиее токена django - в VALUE используем заголовок<strong class="text-danger"> Token (токен_django)</strong>
							<pre>
Headers
KEY: Authorization
VALUE: Token 349dfb7dfe23889347ea551dbe68a6234b88f6d0</pre>
							</li>
							<li>При использованиее токена JWT (access) - в VALUE используем заголовок<strong class="text-danger"> Bearer (токен_JWT_access)</strong>
							<pre>
Headers
KEY: Authorization
VALUE: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNjc4NTUxNjI0LCJqdGkiOiJkOTJlMzhiNWVhN2I0ZWM1OWQ1NTA1ZjZlMTEyYjA4ZiIsInVzZXJfaWQiOjR9.uCx7XraMZbm8g8Q__bm9U4hEl7j4R6bJ-3RM--kMKRE</pre>
							</li>
						</ul>
					</li>
				</ol>
			</li>

&lt;




			<li>
				<hr><h1 class="title_text">6. DJANGO OAUTH2, АВТОРИЗАЦИЯ ЧЕРЕЗ СОЦ. СЕТИ (DRF, Social auth, VK)</h1><hr>
				<ol>
					<li>
						В vk.com - создам приложение.
						<pre>https://vk.com/editapp?act=create</pre>
						<ol>
							<li>vk.com</li>
							<li>Разработчикам</li>
							<li>Создать приложение</li>
							<li>Название: vk auth freelance</li>
							<li>Платформа: сайт</li>
							<li>Адрес сайта: http://127.0.0.1:8000/</li>
							<li>Базовый домен: http://127.0.0.1:8000/</li>
						</ol>
						Далее в настройках, сохрани данные - будут необходимы в settings
						<pre>
ID приложения	51578596
Oa1Y28B9MVGhh7Wik5z8</pre>
					</li>
					<li>
						Далее в настройках приложения vk - копируем id и защищённый ключ
					</li>
<hr>
<h3>Инструкция Social_oauth - для django 4 - другая, откатил проект до предыдущего урока, всё что ниже, не актуально на данный момент, сделай самомстоятельно, с помощью официальной документации pypi.org</h3>					
					<li>
						В вируатльне окружение устанавливаю - social-oauth2
						<pre>pip install drf_social_oauth2</pre>
					</li>
					<li>
						Настраиваю settings.py
						<br>Первым делом добавляю несолько приложений в INSTALLED_APPS
						<pre>
# соц сети
'oauth2_provider',
'social_django',
'drf_social_oauth2',</pre>
				</li>
					<li>
						В settings.py меняю настройки REST_FRAMEWORK
						<pre>
REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
    "DEFAULT_PARSER_CLASSES": [
        "rest_framework.parsers.JSONParser",
    ],
    "DEFAULT_AUTHENTICATION_CLASSES": [
    	# JWT токены
        <span class="text-danger"># "rest_framework.authentication.SessionAuthentication",
        # "rest_framework_simplejwt.authentication.JWTAuthentication",</span>

        # аутентификация social_auth2 - vk
        <span class="text-primary">"oauth2_provider.contrib.rest_framework.OAuth2Authentication",
        "rest_framework_social_oauth2.authentication.SocialAuthentication",</span>
    ],</pre>
    					С JWT - аутентификации, пока что настроить не получилось, при работе со встроенным джанго токеном, проблем нет
					</li>
					<li>
						Продолжаю настройку settings.py
						<br>Ниже добавляю - инфу конктетно для VK
						<pre>
# Для аутентификации через VK. social_auth2
AUTHENTICATION_BACKENDS = [
    'social_core.backends.vk.VKOAuth2',
    'rest_framework_social_oauth2.backends.DjangoOAuth2',
    'django.contrib.auth.backends.ModelBackend',
]

# ID приложения VK, Ниже сервисный ключ доступа
SOCIAL_AUTH_VK_OAUTH2_KEY = '51578596'
SOCIAL_AUTH_VK_OAUTH2_SECRET = 'Oa1Y28B9MVGhh7Wik5z8'</pre>
					</li>
					<li>
						в urls.py (app) Добавляю 1 маршрут (просто инклюдим маршруты social_oauth2)
						<pre>
							
						</pre>
					</li>
					<li>
						Создам и сделаю миграции
						<br><strong class="text-danger">Когда что то добавляю в INSTALLEN_APPS - делай миграции</strong>, т.к у проиложений есть свои таблицы/модели, и иех необходимо добавить в базу данных.
						<pre>
python manage.py makemigrations							
python manage.py migrate</pre>
					</li>

				</ol>

			</li>

&lt;



			<li>
				<hr><h1 class="title_text">7. ДИЗАЙН МАКЕТА В FIGMA (Figma, Bootstrap, Прототипирование)</h1><hr>
				<ol>
					<li>

						<a href="https://www.youtube.com/redirect?event=video_description&redir_token=QUFFLUhqbW9QOUtPU3lFdE9pNWIyRjVFLTNYOGFBRFZtd3xBQ3Jtc0ttZWVoTGhRd2RqZUR1djA4NkpsNGxvang2Sm55ZFl4YlB1VEdiOEtxMWpWQWh5MTI2MWRGMThzeGRkQ3oxNHI1YUxPSW5FNC1QTlN4OTJmNjRXUldxNDVDVnY1Y0FURG5tSnV4cEF1bGtNX2VZanZiUQ&q=https%3A%2F%2Fwww.figma.com%2Ffile%2Fa8YM4L49zJdTWSFjEH5DgJ%2FBootstrap-v4-uikit-Copy%3Fnode-id%3D0%253A1&v=_lN3fGnkmms">Figma Bootstrap UI Kit</a>
					</li>

					<li>
						<strong>По ссылке - перехожу 'get desktop app'</strong>
					</li>

					<li>
						Делаю дизайн/верстаю странички html css на основе bootstrap - в Figma
						<br>
						В этом уроке - делаю макет
					</li>

					<li>
						В приложении, в поиске ищу Bootstrap 5, с сетками навбарами и тд, сохраняю себе
						<pre>
Bootstrap 5 - 2021.11 (Community)</pre>
					</li>
					<li>
						Создаю новый дизайн
					</li>
					<li>
						Чтобы добавить рамку- frame, в новом окне жму F, создаю рамку desktop 1440 x 1024
					</li>
					<li>
						Чтобы копировать группу или элемент, просто зажимать ALT и перетаскивать (получится клон)
					</li>
					<li>
						По итогу сверстал 5 макетов страниц
						<ol>
							<li>index</li>
							<li>search</li>
							<li>auth</li>
							<li>register</li>
							<li>chat</li>
						</ol>
						Сохранил файлы в формате figma и pdf
					</li>
				</ol>

			</li>

&lt;




			<li>
				<hr><h1 class="title_text">8. ДЕТАЛИЗАЦИЯ МАКЕТА В FIGMA (Figma, Bootstrap, Unsplash)</h1><hr>
				<ol>
					<li>
						Делаю макет для личного кабинета и профиля
					</li>
					<li>
						Создаю новый лист (с макатами) - Detail - в него копирую все страницы из макетов
					</li>
					<li>
						<p><a href="https://unsplash.com/">https://unsplash.com/ - картинки для сайтов</a></p>
					</li>
					<li>
						Иожно перетаскивать картинуку просто мышью в нужную рамку
					</li>
				</ol>

			</li>

&lt;




			<li>
				<hr><h1 class="title_text">9. ДЕТАЛИЗАЦИЯ МАКЕТА В FIGMA (Figma, Bootstrap)</h1><hr>
				<ol>
					
					<li>
						Завершил детальные макеты всех страниц
						<ol>
							<li>index</li>
							<li>search</li>
							<li>auth</li>
							<li>register</li>
							<li>chat</li>
							<li>lk</li>
							<li>profile</li>
						</ol>
					</li>
				</ol>

			</li>

&lt;




			<li>
				<hr><h1 class="title_text">10. РЕГИСТРАЦИЯ И АВТОРИЗАЦИЯ НА ФРОНТЕНДЕ, BOOTSTRAP, AXIOS, VUE ROUTER</h1><hr>
				<ol>
					<li>
						<p>
							<a href="https://te.legra.ph/Svoya-frilans-birzha-10-Registraciya-avtorizaciya-Vue-Bootstrap-Axios-09-17">
								Статья по уроку
							</a>
						</p>
					</li>
					<li>
						<p>
							<a href="https://www.youtube.com/watch?v=vAqcdFrbPhY">
								С 39 минуты - простое приложение на Vue - с нуля, с объяснениями роутинга и так далее
							</a>
						</p>
					</li>
					<li>
						Плагин Bootstrap Vue - плагин, который позволяет пользоваться Bootstrap внутри Vue, не подулючая его через CDN, не используя стандартные JS скрипты из Bootstrap - а прописывать их самомтоятельно
					</li>
					<li>
						<p>
							<a href="https://bootstrap-vue.org/docs">
								Bootstrap Vue
							</a>
							<br>Здесь Bootstrap v4! и Vue.js v 2.6+
						</p>
						<p>
							<a href="https://bootstrap-vue.org/docs/components">
								Комомненты Bootstrap vue
							</a>
						</p>
					</li>

					<li>
						axios - это дополнительный плагин, который позволяет получать и отправлять api, фронт->бек, бек -> фронт
						<br>Официальный git axios
						<p>
							<a href="https://github.com/imcvampire/vue-axios#usage">https://github.com/imcvampire/vue-axios#usage</a>
						</p>
					</li>

					<li>
						<h3 class="text-danger">Пробую поднять Vue заново (удалил всё старое, устанавливаю заново)</h3>
					</li>
					<li>
						Работаю по инстуркии с 40 минуты
						<p>
							<a href="https://www.youtube.com/watch?v=vAqcdFrbPhY">
								Пишем простое приложение на Vue и Vuetify
							</a>
						</p>
					</li>
					<li>
						<pre>
vue create vue-freelance

? Please pick a preset:
<strong class="text-danger">> Manually select features</strong>

? Check the features needed for your project: (Press &lt;space> to select, &lt;a> to toggle all, &lt;i> to invert
selection, and &lt;enter> to proceed)
><strong class="text-danger">(*) Babel</strong>
 ( ) TypeScript
 ( ) Progressive Web App (PWA) Support
 <strong class="text-danger">(*) Router</strong>
 ( ) Vuex
 ( ) CSS Pre-processors
 <strong class="text-danger">(*) Linter / Formatter</strong>
 ( ) Unit Testing
 ( ) E2E Testing

? Choose a version of Vue.js that you want to start the project with
> 2.x

? Use history mode for router? (Requires proper server setup for index fallback in production) (Y/n) <strong class="text-danger">Yes</strong>

? Pick a linter / formatter config:
<strong class="text-danger">> ESLint + Airbnb</strong> (Можно Стандарт - Там нет помощи новичкамсв )

? Pick additional lint features: (Press &lt;space> to select, &lt;a> to toggle all, &lt;i> to invert selection, and
&lt;enter> to proceed)
<strong class="text-danger">>(*) Lint on save</strong>

? Where do you prefer placing config for Babel, ESLint, etc.? (Use arrow keys)
<strong class="text-danger">> In dedicated config files</strong>

? Save this as a preset for future projects? (y/N)
<strong class="text-danger">N</strong></pre>
					</li>
					<li>
						Установка завершена, переходим в каталог, запускаем сервер
						<pre>
 $ cd vue-freelance
 $ npm run serve</pre>
 						Проверяю в браузере http://localhost:8080/
					</li>
					<li>
						Чаще всего добавляют Vuetify(я не ставлю), axios, BootstrapVue
					</li>
					<li>
						Устанавливаю axios во фронт окружение
						<br>Лучше использовать инструкцию из оф git
						<p><a href="https://github.com/imcvampire/vue-axios#usage">официальный github axios-vue</a></p>
						<pre>
npm install --save axios vue-axios</pre>
					</li>




					<br>
					<br>
					<br>
					<br>
					<br>	
					<span class="text-black-50">
					<hr>



					<li>
						При ELSINT STANDART - Ошибки
						<pre>
Fix the upstream dependency conflict, or retry.

npm ERR! this command with --force or --legacy-peer-deps.

npm ERR! to accept an incorrect (and potentially broken) dependency resolution.


Исправьте конфликт зависимостей в восходящем потоке или повторите попытку.

npm err! эта команда с помощью --force или --legacy-peer-deps.

npm err! чтобы принять неправильное (и потенциально нарушенное) разрешение зависимостей.
</pre>
						пробую обновить vue cli
						<pre>
npm update -g @vue/cli</pre>
						пробую команду (установка + исправление конфликта зависимостей)
						<pre>npm install --save axios vue-axios <storng class='text-danger'>--force</storng></pre>
						Этой командой он вроде как игнорирует несостыковки, в некоторых случаях можно попробывать команду с '--legacy-peer-deps', кто т о говорит что установить vue прект в другую папку поможет, кто то говорит переустановить npm или vue cli, или понизить версии
						<br>По итогу, были ошибки warning, но сервер зппускается
					</li>


					<hr>
					<br>
					<br>
					<br>
					<br>
					<br>	
					</span>





					<li>
						Устанавливаю axios заново во фронт окружение (Elsint+ Arnbnb) - после полностью переустановленного vue create vue-freelance
						<br>Лучше использовать инструкцию из оф git
						<p><a href="https://github.com/imcvampire/vue-axios#usage">axios github</a></p>
						<pre>
npm install --save axios vue-axios</pre>
					</li>

					<li>
						в src/main.js - добавляю импорты axios - по инстуркии с гита
						<br>полный main.js после установки axios - Всё работает! 
						<pre>
import Vue from 'vue';
<storng class='text-danger'>// axios
import axios from 'axios';
import VueAxios from 'vue-axios';</storng>

import App from './App.vue';
import router from './router';

Vue.config.productionTip = false;

<storng class='text-danger'>// axios
Vue.use(VueAxios, axios);</storng>

new Vue({
  router,
  render: (h) => h(App),
  <storng class='text-danger'>axios,</storng>
}).$mount('#app');</pre>
						<strong>Vue Arnbnb - ругается на мелочи, лишняя пустая строка, не правильный комментарий, отсутствие запятой!</strong>, при этом веб сервер не запускается, будь внимательней читай коды ошибок и исправляй, если сильно надоест, переустанови на ELSINT + STANDERT
					</li>
					<li>
						Устанавливаю BootstrapVue, в консоле в папке с фронтом проекта (vue-freelance)
						<pre>npm install vue bootstrap bootstrap-vue</pre>
					</li>
					<li>
						В main.js - Добавляю модуль Bootstrap.
						<br>Показан полный файл настроек, main.js
						<br><strong class="text-danger">Важен порядок импортов: сначала Vue, потом axios и bootstrap, и уже после App и router</strong>
						<pre>
import Vue from 'vue';

/* регистрирую все модули и плагины */
<storng class='text-danger'>// axios
import axios from 'axios';
import VueAxios from 'vue-axios';</storng>
<storng class='text-primary'>// BootstrapVue
import { BootstrapVue, IconsPlugin } from 'bootstrap-vue';
import 'bootstrap/dist/css/bootstrap.css';
import 'bootstrap-vue/dist/bootstrap-vue.css';</storng>

/* плагины установленные в начале vue create vue-freelance */
import App from './App.vue';
import router from './router';

Vue.config.productionTip = false;
/* модули и плагины доступные для всего проекта */
<storng class='text-danger'>// axios
Vue.use(VueAxios, axios);</storng>
<storng class='text-primary'>// BootstrapVue
Vue.use(BootstrapVue);
Vue.use(IconsPlugin);</storng>

new Vue({
  router,
  render: (h) => h(App),
  <storng class='text-danger'>axios,</storng>
}).$mount('#app');
</pre>
					</li>
					<li>
						В App.vue - пишем главную компоненту
						<br>По сути в ней ниизменяемый навбар, неизменяемый футер, и по середин основной контент, здес будет роутер
						<pre>
&lt;template>

  &lt;div id="app">
    &lt;header class="bg-dark"> &lt;!--    Навбар    -->
      &lt;b-navbar class="w-75 mx-auto" type="dark" variant="dark">
        &lt;b-navbar-brand>Freelance Stock&lt;/b-navbar-brand>
        &lt;b-navbar-nav>
          &lt;b-nav-item href="#">Главная&lt;/b-nav-item>
          &lt;b-nav-item href="#">Заказы&lt;/b-nav-item>
          &lt;b-nav-item href="#">Услуги&lt;/b-nav-item>
          &lt;b-nav-item href="#">О нас&lt;/b-nav-item>
        &lt;/b-navbar-nav>
      &lt;/b-navbar>
    &lt;/header> &lt;!--    /Навбар    -->
    &lt;div class="w-75 ms-auto"> &lt;!--   контент(роутер)    -->
      &lt;router-view/>
      &lt;p>Бла бла бла&lt;/p>
      &lt;p>Чёртов аксиос&lt;/p>
    &lt;/div> &lt;!--    /контент    -->
    &lt;footer>
      &lt;b-jumbotron bg-variant="dark" text-variant="white">
        &lt;div class="w-75 mx-auto">
          &lt;div class="row">
            &lt;div class="col-4 text-left">© Freelance Stock, 2023&lt;/div>
            &lt;div class="col-4 text-center">Контакты&lt;/div>
            &lt;div class="col-4 text-right">О нас&lt;/div>
          &lt;/div>
        &lt;/div>
      &lt;/b-jumbotron>
    &lt;/footer>
  &lt;/div> &lt;!--    /id='app'    -->

&lt;/template>

&lt;script>
export default {
  name: 'App',
};
&lt;/script>

&lt;style>

.navbar, .navbar-brand {
  font-size: 16pt;
}

footer {
  font-size: 20pt;
}

&lt;/style></pre>
					</li>
					<li>
						продолжаю обущение Vue.js
						<br>В папке src - есть папка views - это представления, изначально там есть HomeView.vue.  В этом файле шаблон главной страгицы
						<br>Немного подкорректирую его, закомментирую всё лишнее, для понимания работы
						<pre>
&lt;template>
  &lt;div class="home">
    &lt;img alt="Vue logo" src="../assets/logo.png">
    <span class="text-primary">&lt;p>Дописал текст сам - для понимания&lt;/p></span>

    <span class="text-primary">// сообщение внутри компонента components - HelloWorld.vue</span>
    <span class="text-danger">&lt;!-- &lt;HelloWorld msg="Welcome to Your Vue.js App"/> --></span>

  &lt;/div>
&lt;/template>

&lt;script>
// @ is an alias to /src
<span class="text-primary">// Импорт комонетна src/components/HelloWorld.vue</span>	
<span class="text-danger">// import HelloWorld from '@/components/HelloWorld.vue';</span>

export default {
  name: 'HomeView',
  <span class="text-primary">// добавляем импортируемые компоненты</span>
  <span class="text-danger">/* components: {
    HelloWorld,
  }, */</span>

};
&lt;/script></pre>
					</li>
					<li>
						Сам компопонент src/components/HelloWorld.vue - могу удалить
					</li>
<br><br>					
<br><br>					
<br><br>
<hr>
<h3 class="text-danger">Создаю первый компонент, первое представление и первый роутер - эксперементирую</h3>					
					<li>
						В src/components - создаю подкаталог first
						<br> В src/components/first - создаю свой первый компонент - FirstComponent.vue
						<br>Внутри FirstComponent.vue - пишу шаблон, логику и стиль компонента
						<pre>
&lt;template>
  &lt;div class="first_component">
    &lt;h3>Мой первый компоент - components/firts/FirstComponent.vue&lt;/h3>
    <strong class="text-danger">&lt;!-- Если в представлении, при выхове компонента будет msg='какойто_текст, он появится 3 раза -->
    &lt;h1>{{ msg }}<&lt;h1>
    &lt;h1>{{ msg }}<&lt;h1>
    &lt;h1>{{ msg }}<&lt;h1></strong>
  &lt;/div>
&lt;/template>

&lt;script>
<strong class="text-danger">// разрешаю экспорт текущего компонента src/components/first/FirstComponent.vue</strong>
export default {
  <strong class="text-danger">// это имя компонента чтобы вызавть &lt;FirstComponent />
  name: 'FirstComponent',</strong>
  <strong class="text-primary">// пропс это конструктор переменной msg, которая будет текстом</strong>
  props: {
    msg: String,
  },
};
&lt;/script>

&lt;!-- Add "scoped" attribute to limit CSS to this component only -->
<strong class="text-danger">&lt;!-- Написал стиль для текущего компонента FirstComponent.vue --></strong>
&lt;style scoped>
.first_component {
  background-color: #ffc4c4;
}
&lt;/style></pre>
					</li>
					<li>
						Создаю предсавление в которое вставлю вышеуказанный компонент
						<br>В src/views - создаю файл (представление) FirstComponentView.vue - внутри шаблон, скрипт и стиль
						<pre>
&lt;template>
  &lt;div class="first_view">
    &lt;h1>Розовый-компонент, голубой-представление, синий-main.js(общий компонент)&lt;/h1>
    &lt;hr>&lt;br>&lt;br>&lt;br>
    <strong class="text-primary">&lt;!-- Использую компонент first/FirstComponent.vue (смотри скрипт этого файла) -->
    &lt;FirstComponent msg="пробное (см props компонента)" /></strong>

    <strong class="text-primary">&lt;!-- вызываю компонент 4 раза -->
    &lt;FirstComponent />
    &lt;FirstComponent />
    &lt;FirstComponent />
    &lt;FirstComponent /></strong>
    &lt;img alt="Vue logo" src="../assets/logo.png">
    &lt;h1>Моё первое представление FirstComponentView - src/views/FirstComponentView.vue&lt;/h1>
    <strong class="text-success">&lt;h2>{{ viewDataMsg }}&lt;/h2></strong>
  &lt;/div>
&lt;/template>

&lt;script>
// @ is an alias to /src
// импортирую компоненты components/first/FirstComponent.vue
import FirstComponent from '@/components/first/FirstComponent.vue';

export default {
  <strong class="text-danger">// имя шаблона
  name: 'FirstComponentView',</strong>
  <strong class="text-primary">// добавляю компоненты
  components: {
    FirstComponent,
  },</strong>
  <strong class="text-success">// создаю свой конструктор, сообщения для вызова {{ viewDataMsg }}
  data() {
    return {
      viewDataMsg: 'Это {{ viewDataMsg }} в FirstComponentView.vue',
    };
  },</strong>
};
&lt;/script>

&lt;!-- Написал стиль для текущего компонента -->
&lt;style scoped>
.first_view {
  background-color: #8ef9ff;
}
&lt;/style></pre>
					</li>
					<li>
						Для представления необходимо написать роутер(url, имя маршрута, и подвязаться к представлению)
						<br>в src/router/index.js - импортирую FirstComponentView.vue и пишу роутер для него
						<br><span class="text-danger">router = path + name + component</span>
						<pre>
import Vue from 'vue';
import VueRouter from 'vue-router';
import HomeView from '../views/HomeView.vue';
<strong class="text-danger">// импорт представление /views/FirstComponentView.vue
import FirstComponentView from '../views/FirstComponentView.vue';</strong>

Vue.use(VueRouter);

const routes = [
  {
    path: '/',
    name: 'home',
    component: HomeView,
  },
  {
    path: '/about',
    name: 'about',
    // route level code-splitting
    // this generates a separate chunk (about.[hash].js) for this route
    // which is lazy-loaded when the route is visited.
    component: () => import(/* webpackChunkName: "about" */ '../views/AboutView.vue'),
  },
  <strong class="text-danger">// мой первый компонент
  {
    path: '/first',
    name: 'first',
    component: FirstComponentView,
  },</strong>
];

const router = new VueRouter({
  mode: 'history',
  base: process.env.BASE_URL,
  routes,
});

export default router;</pre>
					</li>
					<li>
						<h3 class="text-danger">Когда возникают ошибки 'potentially fixable with the `--fix` option' - Можно остановить сервер и прописать автофикс</h3>
						<pre>npm run lint -- --fix</pre>
					</li>
					<li>
						Проверяю в бразузере
						<pre>http://localhost:8080/first</pre>
					</li>
					<li>
						По итогу всё очень похоже на старое доброе django
						<hr>
						<br><h3>Порядок создания компонента, представления и маршрута:</h3>
						<strong>
							<ol>
								<li>Создаю и пишу компонент (часть кода html+js+css) в src/components</li>
								<li>Создаю и пишу представление в src/views и вставляю туда компонент
									<br>Так же в представление можно делать свой htm+js+css</li>
								<li>Импортирую представление и пишу роутер в src/router/index.js,<br> роутер это маршрут, имя маршрута и привязка к представлению</li>
							</ol>
						</strong>
						<strong class="text-danger">Представление создаётя опционально!</strong>, можно обойтись без него, в роутер отправлять компонент, представление обычно создаётся, тогда когда в нём много разных компонентов.
						<br>В целом это как вложенные представления
					</li>
<hr>
<br><br>					
<br><br>					
<br><br>
					<li>
						В src/components - создаю дирректорию auth - внутри неё создаю 2 комаонента SignIn.vue and SignUp.vue
					</li>
					<li>
						Пишу роутеры для компонентов SignIn and SignUp
						<br>
						Полный файл src/router/index.js
						<pre>
import Vue from 'vue';
import VueRouter from 'vue-router';

<strong class="text-danger">/* Импорт компонентов */
// импорт компонента /components/auth/SignIn.vue and SignUp.vue
import SignIn from '@/components/auth/SignIn.vue';
import SignUp from '@/components/auth/SignUp.vue';</strong>

/* Импорт представлений */
import HomeView from '../views/HomeView.vue';
// импорт представления /views/FirstComponentView.vue
import FirstComponentView from '../views/FirstComponentView.vue';

Vue.use(VueRouter);

const routes = [
  {
    path: '/',
    name: 'home',
    component: HomeView,
  },
  {
    path: '/about',
    name: 'about',
    // route level code-splitting
    // this generates a separate chunk (about.[hash].js) for this route
    // which is lazy-loaded when the route is visited.
    component: () => import(/* webpackChunkName: "about" */ '../views/AboutView.vue'),
  },
  // мой первый компонент
  {
    path: '/first',
    name: 'first',
    component: FirstComponentView,
  },
  <strong class="text-danger">// мои роутеры для компонентов SignIn и SignUp
  {
    path: '/auth/signin',
    name: 'SignIn',
    component: SignIn,
  },
  {
    path: '/auth/signup',
    name: 'SignUp',
    component: SignUp,
  },</strong>
];

const router = new VueRouter({
  <strong class="text-danger">// обязательно histori (стандартно)
  mode: 'history',</strong>
  base: process.env.BASE_URL,
  routes,
});

export default router;</pre>
						После этого пункта, добавилось 2 url мршрута - И они рабочие.
						<pre>
http://localhost:8080/auth/signin
http://localhost:8080/auth/signup</pre>
					</li>
					<li>
						Пишу компонент SignIn.vue
						<pre>
&lt;!-- eslint-disable vuejs-accessibility/label-has-for -->
&lt;template>
  &lt;div class="w-50 mx-auto border p-2 m-3 rounded">
    &lt;b-form @submit="login">
      &lt;div class="form-group p-2">&lt;!-- логин поле и лейбл -->
        &lt;label for="username">Логин:&lt;/label>
        &lt;b-input v-model="username" type="text" id="username" placeholder="Логин..">&lt;/b-input>
      &lt;/div>
      &lt;div class="form-group p-2">&lt;!-- пароль поли и лейбл -->
        &lt;label for="password">Пароль:&lt;/label>
        &lt;b-input v-model="password" type="password" id="password" placeholder="Пароль..">&lt;/b-input>
      &lt;/div>
      &lt;b-button variant="primary" type="submit" class="mx-2">Войти&lt;/b-button>
      &lt;p class="mt-3">
        Ещё не зарегестрированы?
        &lt;router-link to="/">Регистрация&lt;/router-link>
      &lt;/p>
    &lt;/b-form>
  &lt;/div>
&lt;/template>

&lt;script>
/* разрешаю экспорт этого компонента {
  имя_компонента,
  данные_компонента() {
    возврашаем {
      логин: изначально пустой,
      пароль: изначально пустой,
    };
  },
  методы: {
    событие_логин(эвент) {
      обработчик события= останавливаю событие;
      логика авторизации
    },
    событие_вход(токен) {
      токен, в консоле
    },
  },
} */


export default {
  name: 'signIn',
  data() {
    return {
      username: '',
      password: '',
    };
  },
  methods: {
    login(event) {
      event.preventDefault();

      // логика авторизации
    },
    setLogined(token) {
      // сохраняю токен
      console.log(token);
    },
  },
};
&lt;/style>
</pre>
					</li>
					<li>
						Пишу компонент components/auth/SignUp.vue
						<pre>
&lt;!-- eslint-disable vuejs-accessibility/label-has-for -->
&lt;template>
  &lt;div class="w-50 border rounded p-3 mx-auto">
    &lt;b-form @submit="register">
      &lt;div class="form-group p-2">
        &lt;label for="username">Логин:&lt;/label>
        &lt;b-input v-model="username" type="text" id="username" placeholder="Логин..">&lt;/b-input>
      &lt;/div>
      &lt;div class="form-group p-2">
        &lt;label for="phone">Номер телефона:&lt;/label>
        &lt;b-input v-model="phone" type="text" id="phone" placeholder="+7 (921) 123 45 67">&lt;/b-input>
      &lt;/div>
      &lt;div class="form-group p-2">
        &lt;label for="customerOrExecutor">Вы заказчик или исполнитель?&lt;/label>
        &lt;b-select
          v-model="customerOrExecutor"
          :options="customerOrExecutorOptions"
          type="customerOrExecutor"
          id="customerOrExecutor"
        >&lt;/b-select>
      &lt;/div>
      &lt;div class="form-group p-2">
        &lt;label for="password">Пароль:&lt;/label>
        &lt;b-input v-model="password" type="password" id="password" placeholder="Пароль..">&lt;/b-input>
      &lt;/div>
      &lt;div class="form-group p-2">
        &lt;label for="repeatPassword">Повторите пароль:&lt;/label>
        &lt;b-input
          v-model="repeatPassword"
          type="password"
          id="repeatPassword"
          placeholder="Повторите пароль.."
        >&lt;/b-input>
      &lt;/div>
      &lt;b-button variant="primary" type="submit" class="m-2">Регистрация&lt;/b-button>
      &lt;p class="mt-3">
        Уже есть аккаунт?
        &lt;router-link to="/auth/signin">Вход&lt;/router-link>
      &lt;/p>
    &lt;/b-form>
  &lt;/div>
&lt;/template>

&lt;script>

описание скрипта
/* разрешаю экспортировать текущий компонент {
  имя компонента: 'SignUp',
  данные компонента() - пользуюсь ими в тегах html {
    вернуть (возвращает сразу) {
      username: изначально пусто,
      пароль: изначально пусто,
      повторить пароль: изначально пусто,
      телефон: изначально пусто,
      исполнитель или заказчик: изначально пусто,
      чойсы: [выберете../заказчик/исполнитель],
    };
  },
  методы: {
    регистрация(событие) {
      обработчик события, регистрации
      // логика ругистрации
    }
  }
} */


export default {
  name: 'SignUp',
  data() {
    return {
      username: '',
      password: '',
      repeatPassword: '',
      customerOrExecutor: '',
      customerOrExecutorOptions: [
        {
          text: 'Выберите...',
          value: '',
          disabled: true,
          selected: true,
        },
        { text: 'Заказчик', value: 'customer' },
        { text: 'Исполнитель', value: 'executor' },
      ],
    };
  },
  methods: {
    register(event) {
      event.preventDefault();

      // логика регистрации
    },
  },
};
&lt;/script>

&lt;!-- Add "scoped" attribute to limit CSS to this component only -->
&lt;style scoped>&lt;/style></pre>
						<strong class="text-danger">Что здесь важно</strong>
						- v-model - для того чтобы можно было вытаксивать информацию через v-model (а не через id - по стандарту)
						<br> for - в label - Для того чтобы, можно было нажать на лейбл и нас автоматически отправит в нежное поле для заполнения
					</li>
<br>
<br>
<br>
<hr>
<h3 class="text-danger">Получаю токен django (не JWT) - с фронта. <br>Авторизация с фронта на бекэнде!</h3>
					<li>
						Проверяю src/main.js - чтобы был подключен модуль axios (сделано в начале)
						<br>main.js - подключение axios
						<pre>
...
/* регистрирую все модули и плагины */
// axios
import axios from 'axios';
import VueAxios from 'vue-axios';
...

...
/* модули и плагины доступные для всего проекта */
// axios
Vue.use(VueAxios, axios);
...

// общий экземпляр vue - для всего проекта
new Vue({
....
  axios,
}).$mount...;
</pre>
					</li>
					<li>
						На данный момент, на бэке используется JWT Токен, но мы будем брать токен из Django
						<br>
						Для этого, возвращаем настройки, для полуения токена из джанги а не JWT (JWT комментируем, джанго токен наоборот)
						<br>
						settings.py
						<pre>
INSTALLED_APPS = [
	...
    '...',  # DRF
    'rest_framework.authtoken',  # для auth - с помощью джанги - РАСКОММЕНТИРОВАЛ
    '...',  # djoser
    '....',  # corsheaders
]</pre>
					 freelance/urls.py - urlpatterns
					 <pre>
<span class="text-primary">from rest_framework.authtoken.views import obtain_auth_token  # для аутентификации (django token) - РАСКОМЕНТИРОВАЛ

токены django (backend) - РАСКОМЕНТИРОВАЛ
path('auth/token', obtain_auth_token, name='token'),  # django token
path('auth/logout', Logout.as_view()),  # выйти</span>

<span class="text-danger"># JWT токен - ЗАКОМЕНТИРОВАЛ
# path('token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
# path('token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),</span></pre>
						По идеи всё, если нужно, пересмотри первую часть урока по auth - Django + DRF + Djoser
					</li>
					<li>
						<strong class="text-danger">Пишу логику для авторизации через axios</strong>
						<br>src/components/auth/SignIn  --> script.export_default.SignIn.methods.login(event) { _ }
						<pre>

&lt;script>						
/* разрешаю экспорт этого компонента {
  имя_компонента,
  данные_компонента() {
    возврашаем {
      логин: изначально пустой,
      пароль: изначально пустой,
    };
  },
  методы: {
    событие_логин(эвент) {
      обработчик события= останавливаю событие;
      <span class="text-danger">логика авторизации через api axios - описана внутри</span>
    },
    событие_вход(токен) {
      токен, в консоле
    },
  },
} */
export default {
  name: 'signIn',
  data() {
    return {
      username: '',
      password: '',
    };
  },
  methods: {
    login(event) {
      event.preventDefault();

      <span class="text-danger">// логика авторизации
      // пост запрос, на сервер джанги по api - получения токена
      this.axios
        // отправляю post запрос на сервер джанго, передаю туда values полей username и password
        // данные из полей на сервере фронтенда
        // eslint-disable-next-line quote-props
        .post('http://localhost:8000/api/auth/token', { username: this.username, password: this.password })
        // получаю ответ отправленный с сервера джанги, получаю токен и пердаю в метод setLogined
        .then((response) => { this.setLogined(response.data.token); })
        // отработка ошибок?
        .catch((err) => { console.error(err); });
    },
    setLogined(token) {
      // отправляю токен в консоль (временно)
      console.log(token);
      // сохраняю токен - его можно будет использовать уже в пермишен api
      localStorage.setItem('token', token);
    },</span>
  },
};
&lt;/script></pre>
						<span class="text-danger">Что здесь важно</span>
						<ul>
							<li>Сравнивай axios запрос с официального гита</li>
							<li>http://localhost:8000/api/auth/token - БЕЗ! / в конце</li>
							<li>then((response) .. - скобки на респосн</li>
							<li>'username': this.username.. - работает и с кавычками и без</li>
						</ul>
						<br>
						Так же, если что то не работает, проверяй в postman - и уже потом проверяй с сервера фронта
					</li>
					<li>
						Проверяю авторизацию:
						<ol>
							<li>Запускаю тестовый сервер Django - python manage.py runserver</li>
							<li>Запускаю тестовый сервер Vue.js - npm run serve</li>
							<li>Перехожу - http://localhost:8080/auth/signin</li>
							<li>Заполняю, логин и пароль (настоящий имеющийся)</li>
							<li>Жму войти и смотрю токен в консоле</li>
						</ol>
						Всё работает на данном этапе, токен проходит в консоль браузера.
					</li>
<hr>
<br>					
<br>					
<br>
<br>
<br>
<br>
<hr>
<h3 class="text-danger">Регистрация с фронта на бекэнде! из Vue.js - в БД Django REST</h3>					
					<li>
						Пишу логику регистрации в components/auth/SignUp.vue
						<pre>
&lt;script>
/* разрешаю экспортировать текущий компонент {
  имя компонента: 'SignUp',
  данные компонента() - пользуюсь ими в тегах html {
    вернуть (возвращает сразу) {
      username: изначально пусто,
      пароль: изначально пусто,
      повторить пароль: изначально пусто,
      телефон: изначально пусто,
      исполнитель или заказчик: изначально пусто,
      чойсы: [выберете../заказчик/исполнитель],
    };
  },
  методы: {
    регистрация(событие) {
      обработчик события, регистрации
      <span class="text-danger">// логика ругистрации - подробно внутри</span>
    }
  }
} */
export default {
  name: 'SignUp',
  data() {
    return {
      username: '',
      password: '',
      repeatPassword: '',
      customerOrExecutor: '',
      customerOrExecutorOptions: [
        {
          text: 'Выберите...',
          value: '',
          disabled: true,
          selected: true,
        },
        { text: 'Заказчик', value: 'customer' },
        { text: 'Исполнитель', value: 'executor' },
      ],
    };
  },
  <span class="text-danger">methods: {
    register(event) {
      event.preventDefault();

      // логика регистрации
      // отправляю api пост запрос на сервер django
      // пока работает только имя и пароль (чойсы, телефон не катит)
      this.axios.post('http://localhost:8000/api/auth/users/', {
        username: this.username, password: this.password,
        // после успешной регистрации, параметры респонса в консоль и перекидывает на маршрут войти
      }).then((response) => { console.log(response); this.$router.push('/auth/signin'); })
        .catch((err) => { console.error(err); });
    },
  },</span>
};
&lt;/script></pre>
					</li>
					<li>
						Пробую зарегестрировать пользователя с Vue приложения в браузере
						<br>На данный момент, достоточно ввести только логи и только пароль, остальные поля не отправляются на сервер, мы их не прописали
						<ol>
							<li>Запускаю django сервер - python manage.py runserver</li>
							<li>Запускаю vue сервер - npm run serve</li>
							<li>В браузере - http://localhost:8080/auth/signup</li>
							<li>Ввожу логин и пароль</li>
							<li>При успешной рагистрации отправит на страницу авторизации, и в админке в пользователях появится новый пользователь!</li>
						</ol>
					</li>

<hr>
<br>					
<br>					
<br>					
<br>					


					<br><br>
					<li>
						<hr>
						<h3>Что понял после этого урока (порядок компонетной работы с Vue.js):</h3>
						<br>
						<ol>
							<li>Инициализируем каталог для фронтенда npm create имя_проекта</li>
							<li>Устанавливаю нужные фичи (babel, router, eslint+airnbnb)</li>
							<li>устанавливаю дополнительные плагины, например (axios, BootstrapVue, Vietify)</li>
							<li>Настраиваю src/main.js (импорт всех доп плагинов)</li>
							<li>Пишу общий компонетн src/App.vue (там обычно навбар, футер)</li>
							<li>Создаю отдельные компоненты, которые разные для разных страниц (signIn, signUp, about, home, profile и тд)</li>
							<li>Опчионально, можно создавать полноценное представление, и импортировать в них множество более мелких комнонентов. Каталог src/views</li>
							<li>После создания компонентов, лучше сразу написать роутер для них, чтобы можно было проверять сразу в браузере</li>
							<li>Далее уже верстаем компонент, html css - в файлик components/компонент.vue</li>
							<li>В скрипте компонента, пишем логику если нужно, добавляем переменные, добавляем работу с api и тд, на сколько я понимаю, обязательно должен быть только export default and name: 'Имя компонента'</li>
							<li>После работаем с axios - api отправляем и получаем между фронтом и бэком, при проверке должны работать два сервера и бэк и фронт</li>
						</ol>
						<hr>
					</li>
				</ol>

			</li>

&lt;





			<li>
				<hr><h1 class="title_text">11. ВАЛИДАЦИЯ ФОРМ. VUELIDATE. IMASK. COMPUTED. МАСКИ ВВОДА. ДИРЕКТИВЫ</h1><hr>
				<ol>
					<li>

					</li>
					<li>

					</li>
					<li>

					</li>
				</ol>

			</li>

&lt;




			<li>
				<hr><h1 class="title_text">12. Готовим компоненты правильно (рефакторинг)</h1><hr>
				<ol>
					<li>

					</li>
					<li>

					</li>
					<li>

					</li>
				</ol>

			</li>

&lt;






		</ul> <!-- ОБЩИЙ -->
	</div> <!-- container-md all ОБЩИЙ -->







<!-- JS Bootstrap 5 -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-gtEjrD/SeCtmISkJkNUaaKMoLD0//ElJ19smozuHV6z3Iehds+3Ulb9Bn9Plx0x4" crossorigin="anonymous"></script>

</body>
</html>