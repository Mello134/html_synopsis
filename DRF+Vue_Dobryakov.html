<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- css bootstrap 5 -->
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x" crossorigin="anonymous">

	<title>Django REST + VUE</title>

	<style type="text/css">
		pre{
			color: white;
			background: #2c4352;
			padding-right: 35px;
			padding-left: 5px;
			padding-bottom: 7px;
			padding-top: 10px;
		}
		
		.all{
			background: #e5fdff;


		}

		
		body{
			background: #2c4352;

		}
		
		.spec {
			font-size: 16px;
			letter-spacing: .2em;
			font-weight: 500;
/*			text-transform: uppercase;*/
			color: #f70000;
			margin-top: 15px;
			margin-bottom: 2px;
		}

		.title_text {
			letter-spacing: .1em;
			font-weight: 500;
			color: #ce0000;
			font-size: 25px;

		}

		li{
			margin-bottom: 10px;

		}
	</style>
&lt; &lt; &lt;


</head>
<body>

	Patch - запрос что это
	<br>
	access и refresh в JWT  - что это

	<p><a href="https://www.youtube.com/playlist?list=PLAhg4XYCffEk-Sa5xxvpcpWpQFlckLIMy">YT курс Django REST + VUE</a></p>
	

	<div class="container-md all"><!-- container-md all ОБЩИЙ -->

		<br>
		<h1 class="title_text border text-center">Django REST + VUE<br>David Dobryakov<br>Фриланс Биржа</h1><br>
		<!-- <img src="images\avtoblog\host.jpg" class="img-fluid"><br> -->


		<ul> <!-- ОБЩИЙ -->

&lt;

			<li>
				<hr><h1 class="title_text">1. DJANGO REST + VUE, НАСТРОЙКА ОКРУЖЕНИЯ (Django REST, PostgreSQL, Vue, Make)</h1><hr>
				<ol>
					<li>
						Устанавливаю новый проект через PyCharm
						<br>Сам проект
						<pre>C:\Хранилище\IT\IT Разное\Обучение\David Dobryakov\DRF3+Vue2\freelance</pre>
						<br>Новое собственное окружения
						<pre>C:\Хранилище\IT\IT Разное\Обучение\David Dobryakov\DRF3+Vue2\freelance\venv_freelance</pre>
						Никаких других галочек нет
						<br>
						<br>
						Получился каталог freelance - внутри файлы папка idea и папка venv_freelance
					</li>
					<li>
						Создаю новую папку для Бэка - в папке freelance
						<pre>C:\Хранилище\IT\IT Разное\Обучение\David Dobryakov\DRF3+Vue2\freelance\django_backend</pre>
					</li>
					<li>В терминале - 
						сd DRF3+Vue2\freelance\django_backend
						<br>Устанавливаю Django
						<pre> pip install django</pre>
						<br>Обновляю pip
						<pre>python.exe -m pip install --upgrade pippip</pre>
						<br>Устанавливаю Django REST
						<pre>pip install django-rest-framework</pre>
						<br><strong class="text-danger">Устанавливаю djoser - для авторизации и регистрации (для DRF)</strong>
						<pre>pip install djoser</pre>
						<br><strong class="text-danger">Устанавливаю django-cors-headers - это фитча для фронтенда в джанге</strong>
						<br>django-cors-headers - это определённые заголовки сервера, благодоря которым, мы можем получить данные с сервера и какието данные ему отдать.
						<br>Без этой настройки не получится пообщатся с сервером никаким образом, то есть не будет доступен REST API - ни для кого
						<pre>pip install django-cors-headers</pre>
					</li>
					<li>
						Стартуем проект <br>
						В (venv_freelance) PS C:\Хранилище\IT\IT Разное\Обучение\David Dobryakov\DRF3+Vue2\freelance\django_backend>
						<pre>django-admin startproject django_freelance</pre>
						Название проекта в джанге, лучше делать либо слитно, либо через нижнее подчёркивание, т.к джанга не любит дефисов и пробелов
					</li>
					<li>
						(venv_freelance) PS C:\Хранилище\IT\IT Разное\Обучение\David Dobryakov\DRF3+Vue2\freelance\django_backend\django_freelance> 
						<br>
						(В папке django_freelance - manage.py + вложенная папка django_freelance)
						<br>Создаём приложение freelance
						<pre>
(venv_freelance) PS C:\Хранилище\IT\IT Разное\Обучение\David Dobryakov\DRF3+Vue2\freelance\django_backend\django_freelance>

python manage.py startapp freelance</pre>
					</li>
					<li>
						cd DRF3+Vue2\freelance\django_backend\django_freelance\freelance>
						<br>freelance - это папка приложения, внутри admin.py, apps.py, __init__.py, tests.py, views.py
					</li>
					<li>
						Делаем настроку проекта
						<br>DRF3+Vue2\freelance\django_backend\django_freelance\settings.py
						<br>В INSTALLED_APPS - добавляем приложения
						<pre>
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    <strong class="text-danger">'freelance.apps.FreelanceConfig',  # наше приложение freelance
    'rest_framework',  # DRF
    'djoser',  # djoser
    'corsheaders',  # corsheaders</strong>
]</pre>
						<strong>Необходимо добавить corsheaders - в MIDDLEWARE</strong>
						<br>Так же в settings.py - добавляем, инфу берём из официального гита
						<pre>
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    <strong class="text-danger">"corsheaders.middleware.CorsMiddleware",  # corsheaders
    "django.middleware.common.CommonMiddleware",  # corsheaders</strong>
]</pre>
						Для corsheaders - нужен лист с хостами, <strong class="text-danger">на деплое измени!</strong>
						<br>В settings.py - выше языка и времени
						<pre>
# Для corsheaders - разрешённые хосты
CORS_ALLOWED_ORIGINS = [
    # "https://example.com", # измени на деплое
    # "https://sub.example.com", # измени на деплое
    "http://localhost:8080",  # тестовый web сервер джанги
    # "http://127.0.0.1:9000",  # можно ужалить
]</pre>
						Для corsheaders - нужен лист разрешёнными методами
						<br>settings.py - ниже
						<pre>
# Для corsheaders - список разрешённых методов обращения к серверу
CORS_ALLOW_METHODS = [
    "DELETE",
    "GET",
    "OPTIONS",
    "PATCH",
    "POST",
    "PUT",
]</pre>
					</li>
					<li>
						В виртуальное окружение устанавливаем psycopg2 (для PostrgeSQL)
						<pre>pip install psyco
pg2</pre>
					</li>
					<li>
						Сразу создаю базу данных в SQL Shell(psql)
						<pre>
Server [localhost]:
Database [postgres]:
Port [5432]:
Username [postgres]:
Пароль пользователя postgres:blog1234

psql \! chcp 1251  # для отображении кириллицы
\l смортрим список всех DB
CREATE DATABASE freelance;  # создали базу данных - freelance
-->CREATE DATABASE
\l - смотрим DB создана</pre>
						<br>
						В settings.py - привязываем к проекту базу данных и PostrgeSQL
						<pre>
DATABASES = {
    'default': {
        # 'ENGINE': 'django.db.backends.sqlite3',  # стандартная БД
        # 'NAME': BASE_DIR / 'db.sqlite3',  # стандартная БД
        'ENGINE': 'django.db.backends.postgresql',  # БД PostrgeSQL
        'NAME': 'freelance',  # Имя нашей БД
        'USER': 'postgres',  # пользователь postgres - который создал БД
        'PASSWORD': 'blog1234',  # пароль в PostgreSQL, для пользователя postgres
        'HOST': '127.0.0.1',  # либо просто - 'localhost'
        'PORT': '5432',  # стандартный порт
    }
}</pre>
					</li>
					<li>
						Меняю язык в settings.py на русский
						<pre>
# LANGUAGE_CODE = 'en-En'  # англ. в admin
# TIME_ZONE = 'UTC'  # стандарт
LANGUAGE_CODE = 'ru-Ru'  # русский язык в admin

TIME_ZONE = 'Europe/Moscow'  # время по МСК</pre>
						<strong class="text-danger">Ctrl + Alt + L = автоформат в PyCharm</strong>
					</li>
					<li>
						В папке C:\Хранилище\IT\IT Разное\Обучение\David Dobryakov\DRF3+Vue2\freelance
						<br>Внутри .idea, django_backend, venv_freelance
						<br>Добавляю .gitignore
						<br>Тут же будет git init
						<br>Обязательно проверь что бы в .gitignore было
						<pre>
.idea/
.venv_freelance/
venv_freelance/</pre>
						Полный gitignore
						<pre>
.idea/
.venv_freelance/
venv_freelance/

# Created by https://www.toptal.com/developers/gitignore/api/django
# Edit at https://www.toptal.com/developers/gitignore?templates=django

### Django ###
*.log
*.pot
*.pyc
__pycache__/
local_settings.py
db.sqlite3
db.sqlite3-journal
media
/media
/static

# If your build process includes running collectstatic, then you probably don't need or want to include staticfiles/
# in your Git repository. Update and uncomment the following line accordingly.
# &lt;django-project-name>/staticfiles/

### Django.Python Stack ###
# Byte-compiled / optimized / DLL files
*.py[cod]
*$py.class

# C extensions
*.so

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo

# Django stuff:

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#pdm.lock
#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
#   in version control.
#   https://pdm.fming.dev/#use-with-ide
.pdm.toml

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
env/
venv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
.idea/  #РАСКОММЕНТИРУЙ

# End of https://www.toptal.com/developers/gitignore/api/django





# для Vue

.DS_Store
node_modules/
/dist/
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Editor directories and files
.idea
.vscode
*.suo
*.ntvs*
*.njsproj
*.sln

# для idea
# Default ignored files
/shelf/
/workspace.xml</pre>
					</li>
					<li>
						Необходимо создать и применить миграции
						<br>Чувак изменил команды python manage.py makemigrations && mygrate
						<br>python manage.py runserver && run
						<br>
						<br>Создаём и и применяем миграции
						<pre>
python manage.py makemigrations  # создаём миграции (первый раз не обязательно)
python manage.py migrate (Применяем миграции_)</pre>
						После применения, можно проверить создались ли таблицы в базе данных - в pgAdmin
					</li>
<hr>
					<li>
						Установим сразу vue
						<br>В командной строке cd C:\Хранилище\IT\IT Разное\Обучение\David Dobryakov\DRF3+Vue2\freelance 
						<br>И устанавливем сам Vue в проект
						<pre>
<strong class="text-danger">vue init webpack vue-freelance</strong>

? Project name <strong class="text-danger">vue-freelance</strong>
? Project description <strong class="text-danger">freelance frontend</strong>
? Author <strong class="text-danger">Mello134 &lt;elproject220@yandex.ru></strong>
? Vue build standalone
? Install vue-router? <strong class="text-danger">Yes</strong>
? Use ESLint to lint your code? <strong class="text-danger">Yes</strong>
? Pick an ESLint preset (Use arrow keys)
> Standard (https://github.com/standard/standard)
  <strong class="text-danger">Airbnb (https://github.com/airbnb/javascript)</strong>
  none (configure it yourself)
? Set up unit tests <strong class="text-danger">No</strong>
? Setup e2e tests with Nightwatch? <strong class="text-danger">No</strong>
? Should we run `npm install` for you after the project has been created? (recommended) (Use arrow keys)
> <strong class="text-danger">Yes, use NPM</strong>
  Yes, use Yarn
  No, I will handle that myself
</pre>
						Далее можно проверить что Vue работает
						<pre>
cd vue-freelance  # переходим в папку установленного Vue
npm start  # webpack - собирает все модули
npm run dev # старт сервера Node? не обязательно npm start?</pre>
						Проверяем в браузере по маршруту
						<pre>http://localhost:8080</pre>
						<br>Для остановки в консоле Ctrl + C
					</li>
					<li>
						<strong class="text-danger">Устанавливаем модули для фронтенда заранее</strong>
						<br>C:\Хранилище\IT\IT Разное\Обучение\David Dobryakov\DRF3+Vue2\freelance\vue-freelance
						<br>Устанавливаем axios и vue-axios
						<pre>
npm i axios vue-axios -D</pre>
					</li>
<hr>
					<li>
						Создаю репозиторий на github
						<pre>https://github.com/Mello134/freelance_project</pre>
						<br>
						Подсказки для данного репозитория с гита
						<pre>
…or create a new repository on the command line
echo "# freelance_project" >> README.md
git init
git add README.md
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/Mello134/freelance_project.git
git push -u origin main


…or push an existing repository from the command line
git remote add origin https://github.com/Mello134/freelance_project.git
git branch -M main
git push -u origin main</pre>
					</li>
					<li>
						Инициализируем git в C:\Хранилище\IT\IT Разное\Обучение\David Dobryakov\DRF3+Vue2\freelance
						<pre>
git –v  # посмотреть версию git
git init  # инициализируем git репозиторикй- папку на pc
git status  # смотрим какие файлы не отслеживаются на данный момент
git add .  # добавляем все файлы
git status  # смотрим что теперь всё отслеживается
git commit -m "имя коммита(что сделали/стадия)"  # создаём коммит
git remote add origin  - https://github.com/Mello134/репозиторий.git  # туда будем загружать
git branch -M main
git push -u origin main  # отправили на github - в репозитор</pre>
					</li>
				</ol>

			</li>


&lt;


			<li>
				<hr><h1 class="title_text">2. ПРОЕКТИРОВАНИЕ БД, DJANGO ORM, АДМИНКА (Django ORM, models, admin)</h1><hr>
				<ol>
					<li>
						Каталог django_freelance (папка с manage.py) - пометил как Source Root
					</li>
					<li>
						Центральные фигуры, Исполнитель -> Юзер <- Заказчик
						<br>Услуга -> Тэг <- Заказ
						<br>Ordering - таблица для соединения заказчика и исполнителя, услуги и сервиса
						<br>Сообщение (исполнитель, заказчик, дата, время, из эдитебл)
						<br>Тикеты, для безопасности заказчика, если исполнитель получил предоплату и слился, либо наоборот.
						<br>Ревью - рейтинг и комментарий
						<br>Авторство ревью -> Юзер
					</li>
					<li>
						Пишем модели
						<br>freelance/models.py
						<pre>
from django.db import models
from django.contrib.auth.models import User


# Модель Исполнителя
class Executor(models.Model):
    # Связь со встроенной моделью User,
    # CASCADE - при удалении пользователя, из таблицы Executor, удалятся все записи с его участием
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    # телефон, максимально 11 символов
    phone = models.CharField(max_length=11)

    # краткое отображения, для отдельной записи таблицы Executor
    def __str__(self):
        return "Пользователь(исп) {}, телефон: {}".format(self.user, self.phone)


# модель Заказчика - все поля аналогичны модели исполнителя
class Customer(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    phone = models.CharField(max_length=11)

    def __str__(self):
        return "Пользователь(зак) {}, телефон: {}".format(self.user, self.phone)


# Модель Услуги (связь с исполнителем)
class Service(models.Model):
    # ЧОЙСЫ УСЛУГ (типы услуг)
    SERVICE_TYPES = [
        ('1', 'Веб разработка'),
        ('2', 'Маркетинг'),
        ('3', 'Копирайтинг'),
        ('4', 'Рерайтинг'),
        ('5', 'Переводы'),
        ('6', 'Видеомонтаж'),
        ('7', 'Фотография'),
    ]

    # Услуга связана с исполнителем (модель Executor) / Удалился исполнитель, удалится и его услуги
    executor = models.ForeignKey(Executor, on_delete=models.CASCADE)
    # Имя услуги
    name = models.CharField(max_length=250)
    # Описание услуги
    desc = models.CharField(max_length=1000)
    # цена услуги
    price = models.IntegerField()
    # Тип услуги, стандартно 1, макс длина 1
    service_type = models.CharField(choices=SERVICE_TYPES, default='1', max_length=1)

    def __str__(self):
        # ВАЖНО <strong class="text-danger">self.get_service_type_display</strong> - чтобы отображалось именно название чойса, а не цифры от 1 до 7
        return "{}, {}, цена: {}".format(self.name, self.get_service_type_display(), self.price)


# Модель Заказ (связь с заказчиком)
class Order(models.Model):
    # ЧОЙСЫ УСЛУГ (типы услуг)
    ORDER_TYPES = [
        ('1', 'Веб разработка'),
        ('2', 'Маркетинг'),
        ('3', 'Копирайтинг'),
        ('4', 'Рерайтинг'),
        ('5', 'Переводы'),
        ('6', 'Видеомонтаж'),
        ('7', 'Фотография'),
    ]

    customer = models.ForeignKey(Customer, on_delete=models.CASCADE)
    name = models.CharField(max_length=250)
    desc = models.CharField(max_length=1000)
    price = models.IntegerField()
    order_type = models.CharField(choices=ORDER_TYPES, default='1', max_length=1)

    def __str__(self):
        <strong class="text-danger"># ВАЖНО self.get_order_type_display</strong> - чтобы отображалось именно название чойса, а не цифры от 1 до 7
        return "{}, {}, цена: {}".format(self.name, self.get_order_type_display(), self.price)


# таблица опциональных ключей, тегов (Связи между услугами и заказами)
class Tag(models.Model):
    # связь с услугой
    # blank=True, null=True, не обязательное заполнение, поле может быть пустым, и разрешается null
    service = models.ForeignKey(Service, on_delete=models.CASCADE, blank=True, null=True)
    # связь с заказом
    order = models.ForeignKey(Order, on_delete=models.CASCADE, blank=True, null=True)
    # имя тега
    name = models.CharField(max_length=30)


# таблица определённого заказа
# (Связи между исполнителем и заказчиком + заказом и услугой)
class Ordering(models.Model):
    # связь с заказчиком
    customer = models.ForeignKey(Customer, on_delete=models.CASCADE)
    # связь с исполнителем
    executor = models.ForeignKey(Executor, on_delete=models.CASCADE)
    # связь с услугой
    service = models.ForeignKey(Service, on_delete=models.CASCADE, blank=True, null=True)
    # связь с заказом
    order = models.ForeignKey(Order, on_delete=models.CASCADE, blank=True, null=True)
    # дата время
    order_date = models.DateTimeField()
    # дедлайн
    deadline = models.DateTimeField()

    def __str__(self):
        return "{} - {}, Исполнитель: {}, Заказчик: {}".format(self.order_date, self.deadline,
                                                               self.customer, self.executor)


# модель сообщений
class Message(models.Model):
    # заказчик
    customer = models.ForeignKey(Customer, on_delete=models.CASCADE)
    # исполнитель
    executor = models.ForeignKey(Executor, on_delete=models.CASCADE)
    # дата сообщения
    msg_date = models.DateTimeField()
    # редактировалось ли сообщение
    is_edited = models.BooleanField(default=False)
    # текст сообщения
    desc = models.CharField(max_length=1000)


# тикеты (для общения с техподдержной сайта)
class Ticket(models.Model):
    # Чойсы на строгость, претензии
    SEVERITIES = [
        ('1', 'Низкая'),
        ('2', 'Средняя'),
        ('3', 'Высокая'),
    ]

    # заказчик (опционально)
    customer = models.ForeignKey(Customer, on_delete=models.CASCADE, blank=True, null=True)
    # исполнитель (опционально)
    executor = models.ForeignKey(Executor, on_delete=models.CASCADE, blank=True, null=True)
    # оценка, чойс
    severity = models.CharField(choices=SEVERITIES, default='1', max_length=1)
    # описание претензии
    desc = models.CharField(max_length=1000)
    # дата обращения, претензии
    ticket_date = models.DateTimeField()
    # статус обращения (решён / не решен)
    is_resolved = models.BooleanField(default=False)

    def __str__(self):
        return '{}, {} вопрос решён?{}'.format(self.get_severity_display(), self.ticket_date, self.is_resolved)


# таблица Ревью (рейтинг)
class Review(models.Model):
    # Чойсы рейтинга
    RATING_FILLED = [
        ('1', 1),
        ('2', 2),
        ('3', 3),
        ('4', 4),
        ('5', 5),
    ]

    # рейтинг
    rating = models.CharField(choices=RATING_FILLED, default='1', max_length=1)
    # комментарий
    desc = models.CharField(max_length=1000)


# таблица автора ревью
class Authoring(models.Model):
    # связь с ревью
    review = models.ForeignKey(Review, on_delete=models.CASCADE)
    # автор ревью
    author = models.ForeignKey(User, on_delete=models.CASCADE)
    # опционально заказчик
    customer = models.ForeignKey(Customer, on_delete=models.CASCADE, blank=True, null=True)
    # опционально исполнитель
    executor = models.ForeignKey(Executor, on_delete=models.CASCADE, blank=True, null=True)
    # дата оценки
    review_date = models.DateTimeField()

    def __str__(self):
        return "{}, {}".format(self.author, self.review_date)</pre>
					</li>
					<li>
						Регистрируем все модели в Админке
						<br>freelance/admin.py
						<pre>
from django.contrib import admin
from .models import *  # импорт всех моделей

# Регистрируем все модели
admin.site.register(Customer)
admin.site.register(Executor)
admin.site.register(Service)
admin.site.register(Order)
admin.site.register(Tag)
admin.site.register(Ordering)
admin.site.register(Message)
admin.site.register(Ticket)
admin.site.register(Review)
admin.site.register(Authoring)</pre>
					</li>
					<li>
						Создаю и применяю миграции
						<pre>
python manage.py makemigrations
python manage.py migrate</pre>
					</li>
					<li>
						Создаю суперпользователя
						<pre>
python manage.py createsuperuser

Имя пользователя: Mello
Адрес электронной почты: elproject220@yandex.ru
Password:blog1234
Password (again):blog1234
Superuser created successfully.  # пользователь создан</pre>
					</li>
					<li>
						Запускаю сервер, захожу в админку, проверяю модели
						<pre>http://127.0.0.1:8000/admin/</pre>
					</li>
					<li>
						Через админ панель, создам пользователя, создам исполнителя и проверю
					</li>
				</ol>

			</li>

&lt;



			<li>
				<hr><h1 class="title_text">3. DJANGO SERIALIZERS: ПЕРЕВОД ДАННЫХ В JSON (serializers, views, urls)</h1><hr>
				<ol>
					<li>
						Serializers, сериализатор - это вещь которая перегоняет данные из БД в JSON формат.
						<br>
						JSON формат - это тот формат с которым могут работать разные языки програмирования, будь то на ПК или Андройд IOS. В нашем случае мы перегоняем инфу в JSON - чтобы можно было обработать её уже на стороне клиента, на фронте (JavaScript, Vue.js)
						<br>API
					</li>
					<li>
						Создаю отдельный файл в каталоге приложения freelance
						<br>в django_backend/django_freelance/freelance - создаю serializers.py
					</li>
					<li>
						В serializers.py - импортирую сериалайзеры из DRF
						<pre>from rest_framework import serializers</pre>
					</li>
					<li>
						В serializers.py Пишу пример сериализатора, который похож просто на класс (этим пользоваться не будем, просто для примера)
						<pre>
# пример сериалайзера по типу моделей
class User(serializers.Serializer):
    # ниже поля которые будем передавать в JSON формате
    user = serializers.CharField()
    email = serializers.EmailField()</pre>
					</li>
					<li>
						Предудуший сериализатор комментирую и создаю другие
						<pre>
from .models import *  # импортирую все модели
from django.contrib.auth.models import User  # импорт стандартной модели User


# # пример сериалайзера по типу моделей
# class User(serializers.Serializer):
#     # ниже поля которые будем передавать в JSON формате
#     user = serializers.CharField()
#     email = serializers.EmailField()


# сериализатор пользователя, модель User
class UserSerializer(serializers.ModelSerializer):
    # класс мета, уточняем данные к модели
    class Meta:
        model = User  # привязываем модель к сериализатору
        # какие поля модели нужно сериализовать
        fields = ['username', 'email', 'first_name', 'last_name']


# сериализатор модели исполнителя - Executor
class ExecutorSerializer(serializers.ModelSerializer):
    # создаём переменную в которой будет храниться вся информация о пользователе, а не только id
    # т.е, переменная user = сериализатору UserSerializer
    user = UserSerializer()

    class Meta:  # уточняем данные
        model = Executor  # привязываемся к модели Executor
        fields = '__all__'  # все поля модели


# сериализатор модели заказчика - Customer
class CustomerSerializer(serializers.ModelSerializer):
    # создаём переменную в которой будет храниться вся информация о пользователе, а не только id
    # т.е, переменная user = сериализатору UserSerializer
    user = UserSerializer()

    class Meta:  # уточняем данные
        model = Customer  # привязываемся к модели Customer
        fields = '__all__'  # все поля модели


# Делаю отдельный сериализатор для исполнителя, где не будет инфы о User
# он нужен когда пользователь ещё не зарегистрирован, то есть при создании
class CreateExecutorSerializer(serializers.ModelSerializer):
    class Meta:
        model = Executor
        fields = '__all__'


# Делаю отдельный сериализатор для заказчика, где не будет инфы о User
# он нужен когда пользователь ещё не зарегистрирован, то есть при создании
class CreateCustomerSerializer(serializers.ModelSerializer):
    class Meta:
        model = Customer
        fields = '__all__'


# сериализатор для Услуги - модель Service
# Модель Услуги (связь с исполнителем)
class ServiceSerializer(serializers.ModelSerializer):
    # JSON данные об исполнителе
    executor = ExecutorSerializer()
    <strong class="text-danger"># ВАЖНО - для отображения чойса, а не просто номера чойса - сразу в JSON формате</strong>
    service_type = serializers.CharField(source='get_service_type_display')

    class Meta:
        model = Service
        fields = '__all__'


# сериализатор для Услуги - модель Service
# при создании/корректировании услуги
class CreateServiceSerializer(serializers.ModelSerializer):
    class Meta:
        model = Service
        fields = '__all__'


# сериализатор для Заказа - модель Order
# Модель Услуги (связь с исполнителем)
class OrderSerializer(serializers.ModelSerializer):
    # JSON данные о заказчике
    customer = CustomerSerializer()
    <strong class="text-danger"># ВАЖНО - для отображения чойса, а не просто номера чойса - сразу в JSON формате</strong>
    order_type = serializers.CharField(source='get_order_type_display')

    class Meta:
        model = Order
        fields = '__all__'


# сериализатор для Заказа - модель Order
# при создании/корректировании заказ
class CreateOrderSerializer(serializers.ModelSerializer):
    class Meta:
        model = Order
        fields = '__all__'


# сериализатор для тегов - модель Tag (связи услуги и заказа)
# Модель Услуги (связь с исполнителем)
class TagSerializer(serializers.ModelSerializer):
    # JSON данные об услуге и заказе
    service = ServiceSerializer()
    order = OrderSerializer()

    class Meta:
        model = Tag
        fields = '__all__'


# сериализатор для Tag - модель Tag
# при создании/корректировании Tag
class CreateTagSerializer(serializers.ModelSerializer):
    class Meta:
        model = Order
        fields = '__all__'


# Сериализатор для модели Ordering - (Связи между исполнителем и заказчиком + заказом и услугой)
# У модели 4 ForeignKey поля, 2 из них опциональные
class OrderingSerializer(serializers.ModelSerializer):
    # JSON данные об исполнителе и заказчике + услуге и заказе
    service = ServiceSerializer()
    order = OrderSerializer()
    customer = CustomerSerializer()
    executor = ExecutorSerializer()

    class Meta:
        model = Ordering
        fields = '__all__'


# Сериализатор для модели Ordering - (Связи между исполнителем и заказчиком + заказом и услугой)
# При создании и редактировании
class CreateOrderingSerializer(serializers.ModelSerializer):
    class Meta:
        model = Ordering
        fields = '__all__'


# Сериализатор для модели Message - (Сообщения)
class MessageSerializer(serializers.ModelSerializer):
    # JSON данные об исполнителе и заказчике
    customer = CustomerSerializer()
    executor = ExecutorSerializer()

    class Meta:
        model = Message
        fields = '__all__'


# Сериализатор для модели Message - (Сообщения)
# При создании и редактировании
class CreateMessageSerializer(serializers.ModelSerializer):
    class Meta:
        model = Message
        fields = '__all__'


# Сериализатор для модели Ticket - (для общения с техподдержной сайта)
class TicketSerializer(serializers.ModelSerializer):
    # JSON данные об исполнителе и заказчике
    customer = CustomerSerializer()
    executor = ExecutorSerializer()
    <strong class="text-danger"># ВАЖНО - для отображения чойса, а не просто номера чойса - сразу в JSON формате</strong>
    severity = serializers.CharField(source='get_severity_display')

    class Meta:
        model = Ticket
        fields = '__all__'


# Сериализатор для модели Ticket - (для общения с техподдержной сайта)
# При создании и редактировании
class CreateTicketSerializer(serializers.ModelSerializer):
    class Meta:
        model = Ticket
        fields = '__all__'


# Сериализатор для модели Review - (оценки)
class ReviewSerializer(serializers.ModelSerializer):
    class Meta:
        model = Review
        fields = '__all__'


# Сериализатор для модели Authoring - (автора ревью)
class AuthoringSerializer(serializers.ModelSerializer):
    # JSON данные об исполнителе и заказчике, о пользователе, об оценке
    customer = CustomerSerializer()
    executor = ExecutorSerializer()
    author = UserSerializer()
    review = ReviewSerializer()

    class Meta:
        model = Authoring
        fields = '__all__'


# Сериализатор для модели Authoring - (автора ревью)
# При создании и редактировании
class CreateAuthoringSerializer(serializers.ModelSerializer):
    class Meta:
        model = Authoring
        fields = '__all__'</pre>
						<strong class="text-danger">Сериализаторы делаются с похожими именами, такими как и классы представления и модели</strong>
						<br><strong class="text-danger">Обрати внимание на код - как сделать так чтобы отображились значение чойсов а не их номера</strong>
					</li>
					<li>
						Пишем простое представление, View - для проверки работы
						<br>freelance/views.py
						<pre>
# from django.shortcuts import render  # обычный render не используется в DRF

from rest_framework.response import Response  # для создания ответа
from rest_framework import generics

# импорт всех моделей и сериализаторов
from .models import *
from .serializers import *


# представление для тикетов
# ListAPIView - базовый клас представления DRF
class TicketListView(generics.ListAPIView):
    queryset = Ticket.objects.all()  # все объекты модели
    serializer_class = TicketSerializer  # сериализатор для модели</pre>
					</li>
					<li>
						В каталоге приложения freelance - создаю собственный urls.py
						<br>django_backend/django_freelance(source)/freelance - urls.py
						<br>в freelance/urls.py прописываем
						<pre>
from django.urls import path  # стандартно - маршруты
from django.urls import include  # для расширения маршрутов из других приложений
from .views import *  # все представления из приложения

# список маршрутов
urlpatterns = [
    # путь('url'/, класс_представления.as_view()/функция представления, name='имя_маршрута'),
    path('tickets/all', TicketListView.as_view()),
]</pre>
					</li>
					<li>
						В главны й urls.py - django_freelance(source)/django_freelance/urls.py - подключем urls.py приложения freelance
						<pre>
from django.contrib import admin
from django.urls import path
<strong class="text-danger">from django.urls import include</strong>

urlpatterns = [
    path('admin/', admin.site.urls),

    <strong class="text-danger"># маршруты приложения freelance
    path('api/', include('freelance.urls')),</strong>
]</pre>
					</li>
					<li>
						На всякий случай создам и применю миграции (делал корректировки)
						<pre>
cd (venv_freelance) PS C:\Хранилище\IT\IT Разное\Обучение\David Dobryakov\DRF3+Vue2\freelance\django_backend\django_freelance></pre>
						<pre>
python manage.py makemigrations
python manage.py migrate</pre>
					</li>
					<li>
						Запускаю сервер
						<pre>python manage.py runserver</pre>
						<br>Через админ панель, создаю исполнителя и создаю заказчика, после создаю тикет
					</li>
					<li>
						В браузере переходим по маршруту
						<pre>http://127.0.0.1:8000/api/tickets/all</pre>
						Всё отлично работает! Получаем полный JSON всех тикетов
						<pre>
HTTP 200 OK
Allow: GET, HEAD, OPTIONS
Content-Type: application/json
Vary: Accept

[
    {
        "id": 1,
        "customer": {
            "id": 2,
            "user": {
                "username": "Mello",
                "email": "elproject220@yandex.ru",
                "first_name": "",
                "last_name": ""
            },
            "phone": "89047777777"
        },
        "executor": {
            "id": 1,
            "user": {
                "username": "Кеша",
                "email": "",
                "first_name": "",
                "last_name": ""
            },
            "phone": "88007892132"
        },
        "severity": "Низкая",
        "desc": "Кеша слишком много пиздит",
        "ticket_date": "2023-03-04T17:03:02+03:00",
        "is_resolved": false
    }
]</pre>
					</li>
				</ol>

			</li>

&lt;




			<li>
				<hr><h1 class="title_text">4. DJANGO API VIEWS, GENERICS, FILTER (APIView, generics, гибкий filter)</h1><hr>
				<ol>
					<li>
						Представления на основе классов, бывают высокоуровневые (generics), и есть нихкоуровневые
						<br>Пример низкоуровневого представления API
						<br>views.py
						<pre>
from rest_framework.views import APIView

# пример низкоуровневого API view
class TicketListView(APIView):
    # самостоятельно указываем метод get
    def get(self, request):
        # самостоятельно указываем queryset (записи модели Ticket)
        queryset = Ticket.objects.all()
        # указываем сериализатор
        # serializer_class = Сериализатор(данные_из_бд, в_модели_много_записей_т.е_список)
        serializer_class = TicketSerializer(queryset, many=True)

        # вернуть Ответ (данные сериализатора)
        return Response({'tickers': serializer_class.data})</pre>
        				По итогу, всё тоже самое, в том случае что и generic из предыдушего урока.
        				<br>Здесь приходится расписывать APIView самостоятельно - и контролировать что происходит, Но высокоуровниевые API более предпочтительней, в плане скорости написания как минимум
        				<br><br>Для сравнение API представление с помощью generics - высокоуровневое
        				<pre>
# # представление для тикетов (высокоуровневое API)
# # ListAPIView - базовый клас представления DRF
class TicketListView(generics.ListAPIView):
    queryset = Ticket.objects.all()  # все объекты модели
    serializer_class = TicketSerializer  # сериализатор для модели</pre>
    					Результат тот же
					</li>
<hr>
<h3 class="text-danger">API views и API endponts(маршруты для JSON)</h3>
					<li>
						Пишу представление для исполнителя, получаем по pk
						<br>views.py
						<pre>
# API представление Исполнителя - получить по pk
class ExecutorRetrieveView(generics.RetrieveAPIView):
    queryset = Executor.objects.all()
    serializer_class = ExecutorSerializer</pre>
    					Пишу маршут для представления
    					<br>freelance(app) - uels.py
    					<pre>
<strong class="text-danger"># http://127.0.0.1:8000/api/executors/1  - получим исполнителя по pk/id = 1</strong>
path('executors/&lt;int:pk>', ExecutorRetrieveView.as_view()),  # Получаем исполнителя по pk</pre>
					</li>
					<li>
						Пишу API представления Исполнителя (получаем по pk), <strong class="text-danger">Обновление записи и добавление записи - в модель</strong>
						<br>views.py
						<pre>
# API представление Исполнителя для <strong class="text-danger">обновления данных</strong> (по pk)
class ExecutorUpdateView(generics.UpdateAPIView):
    queryset = Executor.objects.all()
    serializer_class = CreateExecutorSerializer


# API представление Исполнителя для <strong class="text-danger">создания записи</strong> (по pk)
class ExecutorCreateView(generics.CreateAPIView):
    queryset = Executor.objects.all()
    serializer_class = CreateExecutorSerializer</pre>
    					Пишу маршруты представлений обновление и создание записей исполнителей
    					<br>urls.py
    					<pre>
path('executors/update/&lt;int:pk>', ExecutorUpdateView.as_view()),  # Обновляем исполнителя по pk
path('executors/new', ExecutorCreateView.as_view()),  # Создаём исполнителя</pre>
					</li>
					<li>
						Пишу API представления Исполниетлей, т.е <strong class="text-danger">Получить весь список записей в модели</strong>
						<br>views.py
						<pre>
# API представление для списка Исполнителей
class ExecutorListView(generics.ListAPIView):
    queryset = Executor.objects.all()
    serializer_class = ExecutorSerializer</pre>
						Маршрут для списка Исполнителей urls.py
						<pre>path('executors/all', ExecutorListView.as_view()),  # Получаем список исполнителей</pre>
					</li>
					<li>
						<strong class="text-danger">Логика для всех эндпойнтов API, почти всех моделей будет идентичной вышеуказанным</strong>
						<br>
						<strong>
							<ol>
								<li>API - одной записи модели [RetrieveAPIView]</li>
								<li>API - изменения одной записи модели [UpdateAPIView]</li>
								<li>API - создания новой записи в модели [CreateAPIView]</li>
								<li>API - списка всех записей модели [ListAPIView]</li>
							</ol>
						</strong>
					</li>
					<li>
						Пишу аналогичные представления для модели заказчика (Customer)
						<pre>
# API представление Заказчика - получить по pk
class CustomerRetrieveView(generics.RetrieveAPIView):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer


# API представление Заказчика для обновления данных (по pk)
class CustomerUpdateView(generics.UpdateAPIView):
    queryset = Customer.objects.all()
    serializer_class = CreateCustomerSerializer


# API представление Заказчика для создания записи (по pk)
class CustomerCreateView(generics.CreateAPIView):
    queryset = Customer.objects.all()
    serializer_class = CreateCustomerSerializer


# API представление для списка Заказчиков
class CustomerListView(generics.ListAPIView):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer</pre>
					</li>
					<li>
						Пишу маршруты для всех представлений Заказчика (Customer)
						<pre>
path('customers/&lt;int:pk>/', CustomerRetrieveView.as_view()),  # Получаем заказчика по pk
path('customers/update/&lt;int:pk>/', CustomerUpdateView.as_view()),  # Обновляем заказчика по pk
path('customers/new/', CustomerCreateView.as_view()),  # Создаём заказчика
path('customers/all/', CustomerListView.as_view()),  # Получаем список заказчиков</pre>
					</li>
					<li>
						Пишу представления по такому же шаблону для остальных моделей
						<br>Order, Service, Tag, Ordering, Message, Ticket, Authoring
						<br>views.py

						<pre>
# API представление Заказа - получить по pk
class OrderRetrieveView(generics.RetrieveAPIView):
    queryset = Order.objects.all()
    serializer_class = OrderSerializer


# API представление Заказа для обновления данных (по pk)
class OrderUpdateView(generics.UpdateAPIView):
    queryset = Order.objects.all()
    serializer_class = CreateOrderSerializer


# API представление Заказа для создания записи (по pk)
class OrderCreateView(generics.CreateAPIView):
    queryset = Order.objects.all()
    serializer_class = CreateOrderSerializer


# API представление для списка Заказов
class OrderListView(generics.ListAPIView):
    queryset = Order.objects.all()
    serializer_class = OrderSerializer


# API представление Услуги - получить по pk
class ServiceRetrieveView(generics.RetrieveAPIView):
    queryset = Service.objects.all()
    serializer_class = ServiceSerializer


# API представление Услуги для обновления данных (по pk)
class ServiceUpdateView(generics.UpdateAPIView):
    queryset = Service.objects.all()
    serializer_class = CreateServiceSerializer


# API представление Услуги для создания записи (по pk)
class ServiceCreateView(generics.CreateAPIView):
    queryset = Service.objects.all()
    serializer_class = CreateServiceSerializer


# API представление для списка Услуг
class ServiceListView(generics.ListAPIView):
    queryset = Service.objects.all()
    serializer_class = ServiceSerializer


# API представление Тега - получить по pk
class TagRetrieveView(generics.RetrieveAPIView):
    queryset = Tag.objects.all()
    serializer_class = TagSerializer


# API представление Тега для обновления данных (по pk)
class TagUpdateView(generics.UpdateAPIView):
    queryset = Tag.objects.all()
    serializer_class = CreateTagSerializer


# API представление Тега для создания записи (по pk)
class TagCreateView(generics.CreateAPIView):
    queryset = Tag.objects.all()
    serializer_class = CreateTagSerializer


# API представление для списка Тегов
class TagListView(generics.ListAPIView):
    queryset = Tag.objects.all()
    serializer_class = TagSerializer


# API представление определённого заказа - получить по pk
class OrderingRetrieveView(generics.RetrieveAPIView):
    queryset = Ordering.objects.all()
    serializer_class = OrderingSerializer


# API представление определённого заказа для обновления данных (по pk)
class OrderingUpdateView(generics.UpdateAPIView):
    queryset = Ordering.objects.all()
    serializer_class = CreateOrderingSerializer


# API представление определённого заказа для создания записи (по pk)
class OrderingCreateView(generics.CreateAPIView):
    queryset = Ordering.objects.all()
    serializer_class = CreateOrderingSerializer


# API представление для списка определённого заказов
class OrderingListView(generics.ListAPIView):
    queryset = Ordering.objects.all()
    serializer_class = OrderingSerializer


# API представление Сообщения - получить по pk
class MessageRetrieveView(generics.RetrieveAPIView):
    queryset = Message.objects.all()
    serializer_class = MessageSerializer


# API представление Сообщения для обновления данных (по pk)
class MessageUpdateView(generics.UpdateAPIView):
    queryset = Message.objects.all()
    serializer_class = CreateMessageSerializer


# API представление Сообщения для создания записи (по pk)
class MessageCreateView(generics.CreateAPIView):
    queryset = Message.objects.all()
    serializer_class = CreateMessageSerializer


# API представление для списка Сообщений
class MessageListView(generics.ListAPIView):
    queryset = Message.objects.all()
    serializer_class = MessageSerializer


# API представление Тикета - получить по pk
class TicketRetrieveView(generics.RetrieveAPIView):
    queryset = Ticket.objects.all()
    serializer_class = TicketSerializer


# API представление Тикета для обновления данных (по pk)
class TicketUpdateView(generics.UpdateAPIView):
    queryset = Ticket.objects.all()
    serializer_class = CreateTicketSerializer


# API представление Тикета для создания записи (по pk)
class TicketCreateView(generics.CreateAPIView):
    queryset = Ticket.objects.all()
    serializer_class = CreateTicketSerializer


# API представление для списка Тикетов
class TicketListView(generics.ListAPIView):
    queryset = Ticket.objects.all()
    serializer_class = TicketSerializer


# API представление Автора_ревью - получить по pk
class AuthoringRetrieveView(generics.RetrieveAPIView):
    queryset = Authoring.objects.all()
    serializer_class = AuthoringSerializer


# API представление Автора_ревью для обновления данных (по pk)
class AuthoringUpdateView(generics.UpdateAPIView):
    queryset = Authoring.objects.all()
    serializer_class = CreateAuthoringSerializer


# API представление Автора_ревью для создания записи (по pk)
class AuthoringCreateView(generics.CreateAPIView):
    queryset = Authoring.objects.all()
    serializer_class = CreateAuthoringSerializer


# API представление для списка Авторов_ревью
class AuthoringListView(generics.ListAPIView):
    queryset = Authoring.objects.all()
    serializer_class = AuthoringSerializer</pre>
					</li>
					<li>
						Пишу маршруты по шаблону, для остальных представлений
						<br>Order, Service, Tag, Ordering, Message, Ticket, Authoring
						<br>views.py
						<pre>
path('orders/&lt;int:pk>/', OrderRetrieveView.as_view()),  # Получаем заказа по pk
path('orders/update/&lt;int:pk>/', OrderUpdateView.as_view()),  # Обновляем заказ по pk
path('orders/new/', OrderCreateView.as_view()),  # Создаём заказ
path('orders/all/', OrderListView.as_view()),  # Получаем список заказов

path('services/&lt;int:pk>/', ServiceRetrieveView.as_view()),  # Получаем услугу по pk
path('services/update/&lt;int:pk>/', ServiceUpdateView.as_view()),  # Обновляем услугу по pk
path('services/new/', ServiceCreateView.as_view()),  # Создаём услугу
path('services/all/', ServiceListView.as_view()),  # Получаем список услуг

path('tags/&lt;int:pk>/', TagRetrieveView.as_view()),  # Получаем тег по pk
path('tags/update/&lt;int:pk>/', TagUpdateView.as_view()),  # Обновляем тег по pk
path('tags/new/', TagCreateView.as_view()),  # Создаём тег
path('tags/all/', TagListView.as_view()),  # Получаем список тегов

path('orderings/&lt;int:pk>/', OrderingRetrieveView.as_view()),  # Получаем определённого заказа по pk
path('orderings/update/&lt;int:pk>/', OrderingUpdateView.as_view()),  # Обновляем определённого заказа по pk
path('orderings/new/', OrderingCreateView.as_view()),  # Создаём определённого заказа
path('orderings/all/', OrderingListView.as_view()),  # Получаем список определённых заказов

path('messages/&lt;int:pk>/', MessageRetrieveView.as_view()),  # Получаем Сообщение по pk
path('messages/update/&lt;int:pk>/', MessageUpdateView.as_view()),  # Обновляем Сообщение по pk
path('messages/new/', MessageCreateView.as_view()),  # Создаём Сообщение
path('messages/all/', MessageListView.as_view()),  # Получаем список Сообщений

path('tickets/&lt;int:pk>/', TicketRetrieveView.as_view()),  # Получаем Тикет по pk
path('tickets/update/&lt;int:pk>/', TicketUpdateView.as_view()),  # Обновляем Тикет по pk
path('tickets/new/', TicketCreateView.as_view()),  # Создаём Тикет
path('tickets/all/', TicketListView.as_view()),  # Получаем список Тикетов

path('authorings/&lt;int:pk>/', AuthoringRetrieveView.as_view()),  # Получаем Автора_ревью по pk
path('authorings/update/&lt;int:pk>/', AuthoringUpdateView.as_view()),  # Обновляем Автора_ревью по pk
path('authorings/new/', AuthoringCreateView.as_view()),  # Создаём Автора_ревью
path('authorings/all/', AuthoringListView.as_view()),  # Получаем список Авторов_ревью</pre>
					</li>
					<li>
						Представления для модели - Review - будет отличаться, у этой модели всего 1 сериализатор и будет 3 представления (получение и обновление будет совмещнено) - [generics.RetriveUpdateAPIView]
						<br>views.py
						<pre>
# API - Ревью, получение по pk + обновление
class ReviewRetrieveUpdateView(generics.RetrieveUpdateAPIView):
    queryset = Review.objects.all()
    serializer_class = ReviewSerializer
    
    
# API - Ревью, создание
class ReviewCreateView(generics.CreateAPIView):
    queryset = Review.objects.all()
    serializer_class = ReviewSerializer


# API - список Ревью
class ReviewListView(generics.ListAPIView):
    queryset = Review.objects.all()
    serializer_class = ReviewSerializer</pre>
						Тем не менне маршрута(api endpoint) сделаем 4, как у всех остальных
						<br><strong>Для получения и редактирования ревью, 2 разных эндпойнта но 1 общий класс представления</strong>
						<pre>
path('reviews/&lt;int:pk>/', ReviewRetrieveUpdateView.as_view()),  # Получаем Ревью по pk
path('reviews/update/&lt;int:pk>/', ReviewRetrieveUpdateView.as_view()),  # Обновляем Ревью по pk
path('reviews/new/', ReviewCreateView.as_view()),  # Создаём Ревью
path('reviews/all/', ReviewListView.as_view()),  # Получаем список Ревью</pre>
					</li>
					<li>
						В брайзере перейдём по url
						<pre>http://127.0.0.1:8000/api/</pre>
						Увидим все endpoints и маршурты, которые есть в списке urlpatterns
						<pre>
admin/
api/ executors/&lt;int:pk>/
api/ executors/update/&lt;int:pk>/
api/ executors/new/
api/ executors/all/
api/ customers/&lt;int:pk>/
api/ customers/update/&lt;int:pk>/
api/ customers/new/
api/ customers/all/
api/ orders/&lt;int:pk>/
api/ orders/update/&lt;int:pk>/
api/ orders/new/
api/ orders/all/
api/ services/&lt;int:pk>/
api/ services/update/&lt;int:pk>/
api/ services/new/
api/ services/all/
api/ tags/&lt;int:pk>/
api/ tags/update/&lt;int:pk>/
api/ tags/new/
api/ tags/all/
api/ orderings/&lt;int:pk>/
api/ orderings/update/&lt;int:pk>/
api/ orderings/new/
api/ orderings/all/
api/ messages/&lt;int:pk>/
api/ messages/update/&lt;int:pk>/
api/ messages/new/
api/ messages/all/
api/ tickets/&lt;int:pk>/
api/ tickets/update/&lt;int:pk>/
api/ tickets/new/
api/ tickets/all/
api/ authorings/&lt;int:pk>/
api/ authorings/update/&lt;int:pk>/
api/ authorings/new/
api/ authorings/all/
api/ reviews/&lt;int:pk>/
api/ reviews/update/&lt;int:pk>/
api/ reviews/new/
api/ reviews/all/</pre>
					</li>
<hr>
<h3 class="text-danger">Фильтры в API Views</h3>
					<li>
						Добавлю пару записей в таблику Service - через админку
					</li>
					<li>
						<strong class="text-danger">Пишу фильтры</strong> для услуг, представление ServiceListView.
						<br>views.py ищменяю представление ServiceListView
						<pre>
# API представление для списка Услуг
class ServiceListView(generics.ListAPIView):
    # queryset = Service.objects.all()
    serializer_class = ServiceSerializer

    # переопределяю queryset (фильтр)
    def get_queryset(self):
        # изначально беру все записи, будут выводить если фильтры не используются
        queryset = Service.objects.all()
        <strong class="text-danger"># params - своя переменная. В неё запишем все параметры, что получаем из request</strong>
        params = self.request.query_params

        """ Буду фильтровать по полям service_type, price, executor"""
        # к переменной service_type - присваиваем то, что написано в браузерной строке, то есть в гет запросе
        # т.е. если в адресной строке будет написано service(это ключи)=значение, если ничего присвоим просто None
        service_type = params.get('service', None)
        price = params.get('price', None)
        executor = params.get('executor', None)

        # проверяем, написано ли что-то в адресной строке, связанное с service_type
        if service_type:
            # если написано, фильтруем по полю service_type) - изменяем queryset, добавив фильтр
            <strong class="text-danger"># queryset.filter(поле_в_модели=переменная_в_текущем_представлении)</strong>
            queryset = queryset.filter(service_type=service_type)

        # фильтр по цене
        if price:
            # lte - это меньше или равно (<=)
            <strong class="text-danger">queryset = queryset.filter(price__lte=price)</strong>

        # фильтр по исполнителю
        if executor:
            # executor__id - это обращение к модели Executor к полю id, через текущую модель Service (ForeignKey)
            <strong class="text-danger">queryset = queryset.filter(executor__id=executor)</strong>

	        <strong class="text-danger"># обязательно возвращаем queryset</strong>
	        return queryset</pre>
	        			Для проверки фильтра в поле браузера пишем
	        			<pre>
# получаем <strong class="text-danger">весь список записей модели</strong>, без филтров
http://127.0.0.1:8000/api/services/all/

# получаем только <strong class="text-danger">записи исполнителя с pk/id = 2</strong>
http://127.0.0.1:8000/api/services/all/<strong class="text-danger">?executor=2</strong>

# записи <strong class="text-danger">исполнителя с id=2 + ценой услуги = 3000</strong>
http://127.0.0.1:8000/api/services/all/<strong class="text-danger">?executor=2&price=3000</strong>

# записи <strong class="text-danger">исполнителя с id=2 + ценой услуги = 3000 + вебразработка (чойс 1 в модели)</strong>
# service = это переменная в классе представления, добавляли сами
http://127.0.0.1:8000/api/services/all/<strong class="text-danger">?executor=2&price=3000&service=1</strong>
</pre>
					</li>
					<li>
						Аналогично пишем фильтры для модели Order (заказы), представление OrderListView
						<pre>
# API представление для списка Заказов
class OrderListView(generics.ListAPIView):
    serializer_class = OrderSerializer

    # переопределяю queryset (фильтр)
    def get_queryset(self):
        queryset = Order.objects.all()  # весь список
        params = self.request.query_params  # параметры request

        order_type = params.get('order', None)  # ?order=1
        price = params.get('price', None)  # ?price=3000
        customer = params.get('customer', None)  # ?customer=pk/id

        # проверяем в адресной строке '?order=...'
        if order_type:
            # если записи есть применяем фильтр
            # queryset.filter(поле_модели=вышеуказанная_переменная)
            queryset = queryset.filter(order_type=order_type)

        # фильтр по цене
        if price:
            # lte - это меньше или равно (<=)
            queryset = queryset.filter(price__lte=price)

        # фильтр по заказчику
        if customer:
            # executor__id - Service (ForeignKey) --> Customer ->pd/id
            queryset = queryset.filter(customer__id=customer)

        # обязательно возвращаем queryset
        return queryset</pre>
					</li>
					<li>
						Аналогично для модели Message
						<br>Фильтры в представлении MessageListView
						<pre>
# API представление для списка Сообщений
class MessageListView(generics.ListAPIView):
    serializer_class = MessageSerializer

    # переопределяю queryset (фильтр)
    def get_queryset(self):
        queryset = Message.objects.all()  # весь список

        params = self.request.query_params

        # None - это default=None
        executor = params.get('executor', None)  # фильтр по исполнителю
        customer = params.get('customer', None)  # фильтр по заказчику
        from_date = params.get('from_date', None)  # фильтр по дате сообщений (от)
        to_date = params.get('to_date', None)  # фильтр по дате сообщений (до)

        # применяем фильтры, если в адресной строке есть совпадения
        if executor:
            queryset = queryset.filter(executor__id=executor)

        if customer:
            queryset = queryset.filter(customer__id=customer)

        if from_date:
            # msg_date - поле модели Message
            # msg_date__gte - >=, т.е msg_date >= from_date (фильтр от даты)
            queryset = queryset.filter(msg_date__gte=from_date)

        if to_date:
            # msg_date__lte - <=, т.е msg_date >= to_date (фильтр до даты)
            queryset = queryset.filter(msg_gate__lte=to_date)

        return queryset</pre>
					</li>
<hr>
<h3 class="text-danger">Итог</h3>

					<li>
						Написал все endpoints и API views, для некоторых представлений добавлены фильтры
						<br>
						<br>
						Полный views.py
						<pre>
# from django.shortcuts import render  # обычный render не используется в DRF

from rest_framework.response import Response  # для создания ответа
from rest_framework import generics

# импорт всех моделей и сериализаторов
from .models import *
from .serializers import *

from rest_framework.views import APIView


#____________________________________________________________________________________________
# API представление Исполнителя - получить по pk
class ExecutorRetrieveView(generics.RetrieveAPIView):
    queryset = Executor.objects.all()
    serializer_class = ExecutorSerializer


# API представление Исполнителя для обновления данных (по pk)
class ExecutorUpdateView(generics.UpdateAPIView):
    queryset = Executor.objects.all()
    serializer_class = CreateExecutorSerializer


# API представление Исполнителя для создания записи (по pk)
class ExecutorCreateView(generics.CreateAPIView):
    queryset = Executor.objects.all()
    serializer_class = CreateExecutorSerializer


# API представление для списка Исполнителей
class ExecutorListView(generics.ListAPIView):
    queryset = Executor.objects.all()
    serializer_class = ExecutorSerializer
#____________________________________________________________________________________________


# API представление Заказчика - получить по pk
class CustomerRetrieveView(generics.RetrieveAPIView):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer


# API представление Заказчика для обновления данных (по pk)
class CustomerUpdateView(generics.UpdateAPIView):
    queryset = Customer.objects.all()
    serializer_class = CreateCustomerSerializer


# API представление Заказчика для создания записи (по pk)
class CustomerCreateView(generics.CreateAPIView):
    queryset = Customer.objects.all()
    serializer_class = CreateCustomerSerializer


# API представление для списка Заказчиков
class CustomerListView(generics.ListAPIView):
    queryset = Customer.objects.all()
    serializer_class = CustomerSerializer


# API представление Заказа - получить по pk
class OrderRetrieveView(generics.RetrieveAPIView):
    queryset = Order.objects.all()
    serializer_class = OrderSerializer


# API представление Заказа для обновления данных (по pk)
class OrderUpdateView(generics.UpdateAPIView):
    queryset = Order.objects.all()
    serializer_class = CreateOrderSerializer


# API представление Заказа для создания записи (по pk)
class OrderCreateView(generics.CreateAPIView):
    queryset = Order.objects.all()
    serializer_class = CreateOrderSerializer


# API представление для списка Заказов
class OrderListView(generics.ListAPIView):
    serializer_class = OrderSerializer

    # переопределяю queryset (фильтр)
    def get_queryset(self):
        queryset = Order.objects.all()  # весь список
        params = self.request.query_params  # параметры request

        order_type = params.get('order', None)  # ?order=1
        price = params.get('price', None)  # ?price=3000
        customer = params.get('customer', None)  # ?customer=pk/id

        # проверяем в адресной строке '?order=...'
        if order_type:
            # если записи есть применяем фильтр
            # queryset.filter(поле_модели=вышеуказанная_переменная)
            queryset = queryset.filter(order_type=order_type)

        # фильтр по цене
        if price:
            # lte - это меньше или равно (<=)
            queryset = queryset.filter(price__lte=price)

        # фильтр по заказчику
        if customer:
            # executor__id - Service (ForeignKey) --> Customer ->pd/id
            queryset = queryset.filter(customer__id=customer)

        # обязательно возвращаем queryset
        return queryset


# API представление Услуги - получить по pk
class ServiceRetrieveView(generics.RetrieveAPIView):
    queryset = Service.objects.all()
    serializer_class = ServiceSerializer


# API представление Услуги для обновления данных (по pk)
class ServiceUpdateView(generics.UpdateAPIView):
    queryset = Service.objects.all()
    serializer_class = CreateServiceSerializer


# API представление Услуги для создания записи (по pk)
class ServiceCreateView(generics.CreateAPIView):
    queryset = Service.objects.all()
    serializer_class = CreateServiceSerializer


# API представление для списка Услуг
class ServiceListView(generics.ListAPIView):
    serializer_class = ServiceSerializer

    # переопределяю queryset (фильтр)
    def get_queryset(self):
        # изначально беру все записи, будут выводить если фильтры не используются
        queryset = Service.objects.all()
        # params - своя переменная. В неё запишем все параметры, что получаем из request
        params = self.request.query_params

        # """ Буду фильтровать по полям service_type, price, executor"""
        # Переменной service_type - присваиваем то, что написано в браузерной строке, то есть в гет запросе
        # т.е. если в адресной строке будет написано service(это ключи)=значение, если ничего присвоим просто None
        service_type = params.get('service', None)
        price = params.get('price', None)
        executor = params.get('executor', None)

        # проверяем, написано ли что-то в адресной строке, связанное с service_type
        if service_type:
            # если написано, фильтруем по полю service_type - изменяем queryset, добавив фильтр
            # queryset.filter(поле_в_модели=переменная_в_текущем_представлении)
            queryset = queryset.filter(service_type=service_type)

        # фильтр по цене
        if price:
            # lte - это меньше или равно (<=)
            queryset = queryset.filter(price__lte=price)

        # фильтр по исполнителю
        if executor:
            # executor__id - это обращение к модели Executor к полю id, через текущую модель Service (ForeignKey)
            queryset = queryset.filter(executor__id=executor)

        # обязательно возвращаем queryset
        return queryset


# API представление Тега - получить по pk
class TagRetrieveView(generics.RetrieveAPIView):
    queryset = Tag.objects.all()
    serializer_class = TagSerializer


# API представление Тега для обновления данных (по pk)
class TagUpdateView(generics.UpdateAPIView):
    queryset = Tag.objects.all()
    serializer_class = CreateTagSerializer


# API представление Тега для создания записи (по pk)
class TagCreateView(generics.CreateAPIView):
    queryset = Tag.objects.all()
    serializer_class = CreateTagSerializer


# API представление для списка Тегов
class TagListView(generics.ListAPIView):
    queryset = Tag.objects.all()
    serializer_class = TagSerializer


# API представление определённого заказа - получить по pk
class OrderingRetrieveView(generics.RetrieveAPIView):
    queryset = Ordering.objects.all()
    serializer_class = OrderingSerializer


# API представление определённого заказа для обновления данных (по pk)
class OrderingUpdateView(generics.UpdateAPIView):
    queryset = Ordering.objects.all()
    serializer_class = CreateOrderingSerializer


# API представление определённого заказа для создания записи (по pk)
class OrderingCreateView(generics.CreateAPIView):
    queryset = Ordering.objects.all()
    serializer_class = CreateOrderingSerializer


# API представление для списка определённого заказов
class OrderingListView(generics.ListAPIView):
    queryset = Ordering.objects.all()
    serializer_class = OrderingSerializer


# API представление Сообщения - получить по pk
class MessageRetrieveView(generics.RetrieveAPIView):
    queryset = Message.objects.all()
    serializer_class = MessageSerializer


# API представление Сообщения для обновления данных (по pk)
class MessageUpdateView(generics.UpdateAPIView):
    queryset = Message.objects.all()
    serializer_class = CreateMessageSerializer


# API представление Сообщения для создания записи (по pk)
class MessageCreateView(generics.CreateAPIView):
    queryset = Message.objects.all()
    serializer_class = CreateMessageSerializer


# API представление для списка Сообщений
class MessageListView(generics.ListAPIView):
    serializer_class = MessageSerializer

    # переопределяю queryset (фильтр)
    def get_queryset(self):
        queryset = Message.objects.all()  # весь список

        params = self.request.query_params

        # None - это default=None
        executor = params.get('executor', None)  # фильтр по исполнителю
        customer = params.get('customer', None)  # фильтр по заказчику
        from_date = params.get('from_date', None)  # фильтр по дате сообщений (от)
        to_date = params.get('to_date', None)  # фильтр по дате сообщений (до)

        # применяем фильтры, если в адресной строке есть совпадения
        if executor:
            queryset = queryset.filter(executor__id=executor)

        if customer:
            queryset = queryset.filter(customer__id=customer)

        if from_date:
            # msg_date - поле модели Message
            # msg_date__gte - >=, т.е msg_date >= from_date (фильтр от даты)
            queryset = queryset.filter(msg_date__gte=from_date)

        if to_date:
            # msg_date__lte - <=, т.е msg_date >= to_date (фильтр до даты)
            queryset = queryset.filter(msg_gate__lte=to_date)

        return queryset


# API представление Тикета - получить по pk
class TicketRetrieveView(generics.RetrieveAPIView):
    queryset = Ticket.objects.all()
    serializer_class = TicketSerializer


# API представление Тикета для обновления данных (по pk)
class TicketUpdateView(generics.UpdateAPIView):
    queryset = Ticket.objects.all()
    serializer_class = CreateTicketSerializer


# API представление Тикета для создания записи (по pk)
class TicketCreateView(generics.CreateAPIView):
    queryset = Ticket.objects.all()
    serializer_class = CreateTicketSerializer


# API представление для списка Тикетов
class TicketListView(generics.ListAPIView):
    queryset = Ticket.objects.all()
    serializer_class = TicketSerializer


# API представление Автора_ревью - получить по pk
class AuthoringRetrieveView(generics.RetrieveAPIView):
    queryset = Authoring.objects.all()
    serializer_class = AuthoringSerializer


# API представление Автора_ревью для обновления данных (по pk)
class AuthoringUpdateView(generics.UpdateAPIView):
    queryset = Authoring.objects.all()
    serializer_class = CreateAuthoringSerializer


# API представление Автора_ревью для создания записи (по pk)
class AuthoringCreateView(generics.CreateAPIView):
    queryset = Authoring.objects.all()
    serializer_class = CreateAuthoringSerializer


# API представление для списка Авторов_ревью
class AuthoringListView(generics.ListAPIView):
    queryset = Authoring.objects.all()
    serializer_class = AuthoringSerializer


# API - Ревью, получение по pk + обновление
class ReviewRetrieveUpdateView(generics.RetrieveUpdateAPIView):
    queryset = Review.objects.all()
    serializer_class = ReviewSerializer


# API - Ревью, создание
class ReviewCreateView(generics.CreateAPIView):
    queryset = Review.objects.all()
    serializer_class = ReviewSerializer


# API - список Ревью
class ReviewListView(generics.ListAPIView):
    queryset = Review.objects.all()
    serializer_class = ReviewSerializer</pre>
						Полный urls.py
						<pre>
from django.urls import path  # стандартно - маршруты
from django.urls import include  # для расширения маршрутов из других приложений
from .views import *  # все представления из приложения

# список маршрутов
urlpatterns = [
    # путь('url'/, класс_представления.as_view()/функция представления, name='имя_маршрута'),
    path('executors/&lt;int:pk>/', ExecutorRetrieveView.as_view()),  # Получаем исполнителя по pk
    path('executors/update/&lt;int:pk>/', ExecutorUpdateView.as_view()),  # Обновляем исполнителя по pk
    path('executors/new/', ExecutorCreateView.as_view()),  # Создаём исполнителя
    path('executors/all/', ExecutorListView.as_view()),  # Получаем список исполнителей

    path('customers/&lt;int:pk>/', CustomerRetrieveView.as_view()),  # Получаем заказчика по pk
    path('customers/update/&lt;int:pk>/', CustomerUpdateView.as_view()),  # Обновляем заказчика по pk
    path('customers/new/', CustomerCreateView.as_view()),  # Создаём заказчика
    path('customers/all/', CustomerListView.as_view()),  # Получаем список заказчиков

    path('orders/&lt;int:pk>/', OrderRetrieveView.as_view()),  # Получаем заказа по pk
    path('orders/update/&lt;int:pk>/', OrderUpdateView.as_view()),  # Обновляем заказ по pk
    path('orders/new/', OrderCreateView.as_view()),  # Создаём заказ
    path('orders/all/', OrderListView.as_view()),  # Получаем список заказов

    path('services/&lt;int:pk>/', ServiceRetrieveView.as_view()),  # Получаем услугу по pk
    path('services/update/&lt;int:pk>/', ServiceUpdateView.as_view()),  # Обновляем услугу по pk
    path('services/new/', ServiceCreateView.as_view()),  # Создаём услугу
    path('services/all/', ServiceListView.as_view()),  # Получаем список услуг

    path('tags/&lt;int:pk>/', TagRetrieveView.as_view()),  # Получаем тег по pk
    path('tags/update/&lt;int:pk>/', TagUpdateView.as_view()),  # Обновляем тег по pk
    path('tags/new/', TagCreateView.as_view()),  # Создаём тег
    path('tags/all/', TagListView.as_view()),  # Получаем список тегов

    path('orderings/&lt;int:pk>/', OrderingRetrieveView.as_view()),  # Получаем определённого заказа по pk
    path('orderings/update/&lt;int:pk>/', OrderingUpdateView.as_view()),  # Обновляем определённого заказа по pk
    path('orderings/new/', OrderingCreateView.as_view()),  # Создаём определённого заказа
    path('orderings/all/', OrderingListView.as_view()),  # Получаем список определённых заказов

    path('messages/&lt;int:pk>/', MessageRetrieveView.as_view()),  # Получаем Сообщение по pk
    path('messages/update/&lt;int:pk>/', MessageUpdateView.as_view()),  # Обновляем Сообщение по pk
    path('messages/new/', MessageCreateView.as_view()),  # Создаём Сообщение
    path('messages/all/', MessageListView.as_view()),  # Получаем список Сообщений

    path('tickets/&lt;int:pk>/', TicketRetrieveView.as_view()),  # Получаем Тикет по pk
    path('tickets/update/&lt;int:pk>/', TicketUpdateView.as_view()),  # Обновляем Тикет по pk
    path('tickets/new/', TicketCreateView.as_view()),  # Создаём Тикет
    path('tickets/all/', TicketListView.as_view()),  # Получаем список Тикетов

    path('authorings/&lt;int:pk>/', AuthoringRetrieveView.as_view()),  # Получаем Автора_ревью по pk
    path('authorings/update/&lt;int:pk>/', AuthoringUpdateView.as_view()),  # Обновляем Автора_ревью по pk
    path('authorings/new/', AuthoringCreateView.as_view()),  # Создаём Автора_ревью
    path('authorings/all/', AuthoringListView.as_view()),  # Получаем список Авторов_ревью

    path('reviews/&lt;int:pk>/', ReviewRetrieveUpdateView.as_view()),  # Получаем Ревью по pk
    path('reviews/update/&lt;int:pk>/', ReviewRetrieveUpdateView.as_view()),  # Обновляем Ревью по pk
    path('reviews/new/', ReviewCreateView.as_view()),  # Создаём Ревью
    path('reviews/all/', ReviewListView.as_view()),  # Получаем список Ревью
]
</pre>
					</li>
				</ol>

			</li>

&lt;




			<li>
				<hr><h1 class="title_text">5. DJANGO REST РЕГИСТРАЦИЯ + АВТОРИЗАЦИЯ / DJOSER, JWT (TOKENs, DRF, JWT)</h1><hr>
				<ol>
					<li>
						Авторизация пользователя. Можно сделать с помощью джанги, на бэке (например djoser), или на фронте, с помощью JWT (JSON Web Token)
					</li>
<hr>
<h3 class="text-danger">Авторизация Django + DRF + Djoser (на бекэнде)</h3>

					<li>
						В settings.py в INSTALLED_APPS - добавляю
						<pre>
INSTALLED_APPS = [
	...
    '...',  # DRF
    'rest_framework.authtoken',  # для auth - с помощью джанги
    '....',  # djoser
    '...',  # corsheaders
]</pre>
					</li>
					<li>
						В freelance(app)/urls.py - импортирую obtain_auth_token
						<pre>
from rest_framework.authtoken.views import obtain_auth_token  # для аутентификации</pre>
					</li>
					<li>
						В urlpatterns добавляю 2 маршрута
						<pre>
urlpatterns = [
    # маршруты для получения токенов аутентификации
    path('auth/', include('djoser.urls')),  # здесь urls джосера, для регистрации и авторизации
    path('auth/token', obtain_auth_token, name='token'),

    ...
    ...
]</pre>
						<strong>По факту по auth/token - будеи получать сам токен</strong>
					</li>
					<li>
						Во views.py - импортирую пермигены и статусы ответов
						<pre>
# проверка авторизованности
# статусы выполнения 200/404 и ид
from rest_framework import permissions, status  # проверка авторизованности</pre>

					</li>
					<li>
						Пишу представление для Logout. 
						<br>views.py
						<pre>
# представление Logout
class Logout(APIView):
    """ Будем получать пользователя, и из его данных удаляем токен, возвращаем статус 200"""
    def get(self, request, format=None):
        request.user.auth_token.delete()  # удаляем токен
        return Response(status=status.HTTP_200_OK)  # Отвечаем - 200 OK</pre>
        				Пишу представление для Logout - views.py
        				<pre>path('auth/logout', Logout.as_view()),  # выйти</pre>
					</li>
					<li>
						Во views.py - 'защитим' все представления, которые только для авторизованных пользователей.
						<br>Добавлю пермишены, для представлений (Update and Create) - кроме Create Executor and Customer - так как нелогично, запрещать создавать нового пользователя
						<pre>
# API представление Исполнителя для обновления данных (по pk)
class ExecutorUpdateView(generics.UpdateAPIView):
    queryset = Executor.objects.all()
    serializer_class = CreateExecutorSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>


# API представление Исполнителя для создания записи (по pk)
class ExecutorCreateView(generics.CreateAPIView):
    queryset = Executor.objects.all()
    serializer_class = CreateExecutorSerializer



# API представление Заказчика для обновления данных (по pk)
class CustomerUpdateView(generics.UpdateAPIView):
    queryset = Customer.objects.all()
    serializer_class = CreateCustomerSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>


# API представление Заказчика для создания записи (по pk)
class CustomerCreateView(generics.CreateAPIView):
    queryset = Customer.objects.all()
    serializer_class = CreateCustomerSerializer

    

# API представление Заказа для обновления данных (по pk)
class OrderUpdateView(generics.UpdateAPIView):
    queryset = Order.objects.all()
    serializer_class = CreateOrderSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>


# API представление Заказа для создания записи (по pk)
class OrderCreateView(generics.CreateAPIView):
    queryset = Order.objects.all()
    serializer_class = CreateOrderSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>



# API представление Услуги для обновления данных (по pk)
class ServiceUpdateView(generics.UpdateAPIView):
    queryset = Service.objects.all()
    serializer_class = CreateServiceSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>


# API представление Услуги для создания записи (по pk)
class ServiceCreateView(generics.CreateAPIView):
    queryset = Service.objects.all()
    serializer_class = CreateServiceSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>



# API представление Тега для обновления данных (по pk)
class TagUpdateView(generics.UpdateAPIView):
    queryset = Tag.objects.all()
    serializer_class = CreateTagSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>


# API представление Тега для создания записи (по pk)
class TagCreateView(generics.CreateAPIView):
    queryset = Tag.objects.all()
    serializer_class = CreateTagSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>



# API представление определённого заказа для обновления данных (по pk)
class OrderingUpdateView(generics.UpdateAPIView):
    queryset = Ordering.objects.all()
    serializer_class = CreateOrderingSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>


# API представление определённого заказа для создания записи (по pk)
class OrderingCreateView(generics.CreateAPIView):
    queryset = Ordering.objects.all()
    serializer_class = CreateOrderingSerializer
    # тип пользователя - авторизован или только для чтения
    
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>


# API представление Сообщения для обновления данных (по pk)
class MessageUpdateView(generics.UpdateAPIView):
    queryset = Message.objects.all()
    serializer_class = CreateMessageSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>

# API представление Сообщения для создания записи (по pk)
class MessageCreateView(generics.CreateAPIView):
    queryset = Message.objects.all()
    serializer_class = CreateMessageSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>



# API представление Тикета для обновления данных (по pk)
class TicketUpdateView(generics.UpdateAPIView):
    queryset = Ticket.objects.all()
    serializer_class = CreateTicketSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>


# API представление Тикета для создания записи (по pk)
class TicketCreateView(generics.CreateAPIView):
    queryset = Ticket.objects.all()
    serializer_class = CreateTicketSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>



# API представление Автора_ревью для обновления данных (по pk)
class AuthoringUpdateView(generics.UpdateAPIView):
    queryset = Authoring.objects.all()
    serializer_class = CreateAuthoringSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>


# API представление Автора_ревью для создания записи (по pk)
class AuthoringCreateView(generics.CreateAPIView):
    queryset = Authoring.objects.all()
    serializer_class = CreateAuthoringSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>


# API - Ревью, получение по pk + обновление
class ReviewRetrieveUpdateView(generics.RetrieveUpdateAPIView):
    queryset = Review.objects.all()
    serializer_class = ReviewSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>


# API - Ревью, создание
class ReviewCreateView(generics.CreateAPIView):
    queryset = Review.objects.all()
    serializer_class = ReviewSerializer
    # тип пользователя - авторизован или только для чтения
    <span class='text-danger'>permission_class = permissions.IsAuthenticatedOrReadOnly</span>
					</li>
<hr>
<h3 class="text-danger">Проверка пермишенов в Postman</h3>
					<li>
						Создаю и применяю миграции
						<pre>
python manage.py makemigrations
python manage.py migrate</pre>
					</li>
					<li>
						Запускаю сервер
					</li>
					<li>
						В Postman - перехожу по урлу
						<pre>127.0.0.1:8000/api/auth/users/</pre>
						<ul>
							<li>POST - запрос</li>
							<li>Body</li>
							<li>form-data</li>
						</ul>
						Пишет что username and password - обязательные поля
						<br>По вышеуказанным параметрам (url body и тд) добавляю два поля (придумываю значения сам) 
						<br> <strong class="text-danger">Здесь мы регистрируем пользователя через Postman</strong>
						<ul>
							<li>Key - username; Value - alex</li>
							<li>Key - password; Value - aLEx1234aLEx</li>
						</ul>
						<br>
						<strong>И отправляю запрос в postman</strong>
						<br>
						postman я так понимаю создал пользователя
						<pre>
{
    "email": "",
    "username": "alex",
    "id": 7
}</pre>
					</li>
					<li>
						Пробую <strong class="text-danger">Залогинится через постман</strong>
						<br>Postman - новый запрос
						<ul>
							<li><pre>127.0.0.1:8000/api/auth/token</pre></li>
							<li>POST - запрос</li>
							<li>Body</li>
							<li>form-data</li>
							<li>Key - username; Value - alex</li>
							<li>Key - password; Value - aLEx1234aLEx</li>
						</ul>
						<br>Выполняю запрос - SEND
						<br>Postman отдаёт токен
						<pre>
{
    "token": "349dfb7dfe23889347ea551dbe68a6234b88f6d0"
}</pre>
						Этот токен будем использовать, для доступа к views - где писали permissions
					</li>
					<li>
						Пробую через браузер, получить доступ к permissons view
						<pre>http://127.0.0.1:8000/api/executors/update/1/</pre>
						Выдаст JSON
						<pre>
<strong class="text-danger">HTTP 405 Method Not Allowed</strong>
Allow: PUT, PATCH, OPTIONS
Content-Type: application/json
Vary: Accept

{
    "detail": "Метод \"GET\" не разрешен."
}</pre>
					HTTP 405 Method Not Allowed - означает что метод неразрешён, так как это представление тольно для залогиненных пользователей
					</li>
					<li>
						В Postman - пробую изменить данные пользователя.
						<ul>
							<li><pre>http://127.0.0.1:8000/api/executors/update/1/</pre></li>
							<li>PATCH - запрос</li>
							<li>Body</li>
							<li>form-data</li>
							<li>Key - phone; Value - 89999990000</li>
						</ul>
						Получаю запрет - т.к неавторизован
						<pre>
{
    "detail": "Учетные данные не были предоставлены."
}</pre>
					</li>
					<li>
						В Postman - изменяю данные, добавив токен
						<ol>
							<li><pre>http://127.0.0.1:8000/api/executors/update/1/</pre></li>
							<li>PATCH - запрос</li>
							<li>Headers: Key - Authorization; Value - Token 349dfb7dfe23889347ea551dbe68a6234b88f6d0</li>
							<li>Body</li>
							<li>form-data</li>
							<li>Key - phone; Value - 89999990000</li>
						</ol>
						<strong>Данные изменились!</strong>
						<br>Можно убедится в браузере
						<pre>http://127.0.0.1:8000/api/executors/all/</pre>
					</li>
<hr>
<h3 class="text-danger">Авторизация Djoser + JWT (на фронтэнде)</h3>
					<li>
						<strong class="text-danger">Устанавливаю библиотеку, который отвечает за модуль JWT - для django rest framework</strong>
						<pre>pip install djangorestframework_simplejwt</pre>
					</li>
					<li>
						В settings.py, в INSTALLED_APPS - комментирую,
						<pre># 'rest_framework.authtoken',  # для auth - с помощью джанги</pre>
					</li>
					<li>
						В settings.py - после CORL_ALLOW_METHODS - добавлю настройки, для того чтобы заработал JSON TOKEN (JWT)
						<pre>
REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
    "DEFAULT_PARSER_CLASSES": [
        "rest_framework.parsers.JSONParser",
    ],
    "DEFAULT_AUTHENTICATION_CLASSES": [
        "rest_framework.authentication.SessionAuthentication",
        "rest_framework_simplejwt.authentication.JWTAuthentication",
        # "oauth2_provider.contrib.rest_framework.OAuth2Authentication",
        # "rest_framework_social_oauth2.authentication.SocialAuthentication",
    ],
}</pre>
					</li>
					<li>
						В urls.py (freelance app) - коментирую obtain_token, маршруты токена и Logout
						<pre>
# from rest_framework.authtoken.views import obtain_auth_token  # для аутентификации (django token)

# path('auth/token', obtain_auth_token, name='token'),  # django token
# path('auth/logout', Logout.as_view()),  # выйти</pre>
					</li>
					<li>
						В urls.py импортирую необходимые модули для JWT, пишу маршрут JWT токена
						<pre>
from rest_framework_simplejwt.views import TokenObtainPairView, TokenRefreshView  # JWT токен

# JWT токен
path('token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
path('token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),</pre>
					</li>
					<li>
						views.py - необходим импорт permissions (уже есть), импортируем exceptions.PermissionDenied
						<pre>
from rest_framework.exceptions import PermissionDenied  # для JWT</pre>
					</li>
					<li>
						Пишу пермишен для исполнители и заказчика
						<br><span>Permissions классы - желательно делать в отдельном файле</span>, но в рамках курса, пишем в views.py
						<pre>
# permission для Исполнителя
class IsExecutor(permissions.BasePermission):
    """ Проверяет есть ли у Исполнителя доступ """
    def has_object_permission(self, request, view, obj):
        return obj.user == request.user</pre>
        				Меняю permission - для ExecutorUpdateView, и так же переопрелеляю get_queryset
        				<pre>
# API представление Исполнителя для обновления данных (по pk)
class ExecutorUpdateView(generics.UpdateAPIView):
    queryset = Executor.objects.all()
    serializer_class = CreateExecutorSerializer
    <strong class="text-danger"># разрешено только исполнителю
    permission_classes = (IsExecutor,)</strong>

    # переопределяю queryset
    def get_queryset(self):
        # пользователь = текущий пользователь из request
        user = self.request.user

        # если пользователь авторизован
        if user.is_authenticated:
            # возвращаем инфу именно по авторизованному пользователю
            return Executor.objects.filter(user=user)
        # отработка исключения - "В доступе отказано"
        raise PermissionDenied()</pre>
					</li>
					<li>
						Пробую получить токен в postman
						<ol>
							<li>url <pre>http://127.0.0.1:8000/api/token/</pre></li>
							<li>Body</li>
							<li>raw</li>
							<li>JSON</li>
							<li><pre>{"username":"alex", "password":"aLEx1234aLEx"}</pre></li>
						</ol>
						<br>Получили ответ с refresh и access токенами:
						<pre>
{
    "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTY3ODYzNjA2MiwianRpIjoiNWJhYzc4ZjQxZTZhNGI0NGE0NGE1YjMwNmE4ZWE1Y2QiLCJ1c2VyX2lkIjo3fQ.39zwRwswVpLZ8uNMT6dLlrjG-Qwy9XKAQy3of71dJGE",
    "access": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNjc4NTQ5OTYyLCJqdGkiOiJhNWYwMDI5ZDUyMzY0MWQwOWViNTNhZDE2ZjAwNWI3ZiIsInVzZXJfaWQiOjd9.QAfyv94MJfmwyswXnpF876zIXe2_Y9CDMn4vW2rY6dw"
}</pre>

					</li>
					<li>
						Пробую изменить данные исполнителя через postman
						<ol>
							<li>url <pre>http://127.0.0.1:8000/api/executors/update/2/</pre></li>
							<li>PATCH</li>
							<li>Headers - KEY: Authorization, VALUE: (access токен)_</li>
							<li>Body</li>
							<li>raw</li>
							<li>JSON</li>
							<li><pre>{
    "phone": "80001112233"
}</pre>
							</li>
						</ol>
						Запрос будет отклонён, так как пользователь alex не является исполнителем в целом, и не является исполнителем с id = 3
					</li>
<hr>
<h3 class="text-danger">Получаю токен нужного исполнителя и меняю данные в postman</h3>
					<li>
						Получаю токен
						<ol>
							<li>url <pre>http://127.0.0.1:8000/api/token/</pre></li>
							<li>Body</li>
							<li>raw</li>
							<li>JSON</li>
							<li><pre>{"username":"Исполнитель2", "password":"blog1234"}</pre>
							Это executor с pk/id = 3
							</li>
						</ol>
					</li>
					<li>
						Копирую access token - которые получили в ответе postman
					</li>
					<li>
						Меняю данные
						<ol>
							<li>url <pre>http://127.0.0.1:8000/api/executors/update/2/</pre></li>
							<li>PATCH</li>
							<li>Headers - KEY: Authorization, VALUE: (access_токен_без кавычек)</li>
							<li>Body</li>
							<li>raw</li>
							<li>JSON</li>
							<li><pre>{
    "phone": "80008880088"
}</pre>
							</li>
						</ol>
						<strong>Данные успешно изменились!</strong>
						<br>Можно перепроверить в браузере, то что данные изменились
						<pre>http://127.0.0.1:8000/api/executors/3/</pre>
					</li>
<hr>
<h3 class="text-danger">Главное оличие использование стандартного токена django или JWT</h3>					
					<li>
						<ul>
							<li>При использованиее токена django - в VALUE используем заголовок<strong class="text-danger"> Token (токен_django)</strong>
							<pre>
Headers
KEY: Authorization
VALUE: Token 349dfb7dfe23889347ea551dbe68a6234b88f6d0</pre>
							</li>
							<li>При использованиее токена JWT (access) - в VALUE используем заголовок<strong class="text-danger"> Bearer (токен_JWT_access)</strong>
							<pre>
Headers
KEY: Authorization
VALUE: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNjc4NTUxNjI0LCJqdGkiOiJkOTJlMzhiNWVhN2I0ZWM1OWQ1NTA1ZjZlMTEyYjA4ZiIsInVzZXJfaWQiOjR9.uCx7XraMZbm8g8Q__bm9U4hEl7j4R6bJ-3RM--kMKRE</pre>
							</li>
						</ul>
					</li>
				</ol>
			</li>

&lt;




			<li>
				<hr><h1 class="title_text">6. DJANGO OAUTH2, АВТОРИЗАЦИЯ ЧЕРЕЗ СОЦ. СЕТИ (DRF, Social auth, VK)</h1><hr>
				<ol>
					<li>
						В vk.com - создам приложение.
						<pre>https://vk.com/editapp?act=create</pre>
						<ol>
							<li>vk.com</li>
							<li>Разработчикам</li>
							<li>Создать приложение</li>
							<li>Название: vk auth freelance</li>
							<li>Платформа: сайт</li>
							<li>Адрес сайта: http://127.0.0.1:8000/</li>
							<li>Базовый домен: http://127.0.0.1:8000/</li>
						</ol>
						Далее в настройках, сохрани данные - будут необходимы в settings
						<pre>
ID приложения	51578596
Oa1Y28B9MVGhh7Wik5z8</pre>
					</li>
					<li>
						Далее в настройках приложения vk - копируем id и защищённый ключ
					</li>
<hr>
<h3>Инструкция Social_oauth - для django 4 - другая, откатил проект до предыдущего урока, всё что ниже, не актуально на данный момент, сделай самомстоятельно, с помощью официальной документации pypi.org</h3>					
					<li>
						В вируатльне окружение устанавливаю - social-oauth2
						<pre>pip install drf_social_oauth2</pre>
					</li>
					<li>
						Настраиваю settings.py
						<br>Первым делом добавляю несолько приложений в INSTALLED_APPS
						<pre>
# соц сети
'oauth2_provider',
'social_django',
'drf_social_oauth2',</pre>
				</li>
					<li>
						В settings.py меняю настройки REST_FRAMEWORK
						<pre>
REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticated',
    ],
    "DEFAULT_PARSER_CLASSES": [
        "rest_framework.parsers.JSONParser",
    ],
    "DEFAULT_AUTHENTICATION_CLASSES": [
    	# JWT токены
        <span class="text-danger"># "rest_framework.authentication.SessionAuthentication",
        # "rest_framework_simplejwt.authentication.JWTAuthentication",</span>

        # аутентификация social_auth2 - vk
        <span class="text-primary">"oauth2_provider.contrib.rest_framework.OAuth2Authentication",
        "rest_framework_social_oauth2.authentication.SocialAuthentication",</span>
    ],</pre>
    					С JWT - аутентификации, пока что настроить не получилось, при работе со встроенным джанго токеном, проблем нет
					</li>
					<li>
						Продолжаю настройку settings.py
						<br>Ниже добавляю - инфу конктетно для VK
						<pre>
# Для аутентификации через VK. social_auth2
AUTHENTICATION_BACKENDS = [
    'social_core.backends.vk.VKOAuth2',
    'rest_framework_social_oauth2.backends.DjangoOAuth2',
    'django.contrib.auth.backends.ModelBackend',
]

# ID приложения VK, Ниже сервисный ключ доступа
SOCIAL_AUTH_VK_OAUTH2_KEY = '51578596'
SOCIAL_AUTH_VK_OAUTH2_SECRET = 'Oa1Y28B9MVGhh7Wik5z8'</pre>
					</li>
					<li>
						в urls.py (app) Добавляю 1 маршрут (просто инклюдим маршруты social_oauth2)
						<pre>
							
						</pre>
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>

					<li>
						Создам и сдкелаю миграции
						<br><strong class="text-danger">Когда что то добавляю в INSTALLEN_APPS - делай миграции</strong>, т.к у проиложений есть свои таблицы/модели, и иех необходимо добавить в базу данных.
						<pre>
python manage.py makemigrations							
python manage.py migrate</pre>
					</li>
					<li>

					</li>
					<li>

					</li>
					<li>

					</li>
					<li>

					</li>
					<li>

					</li>
					<li>

					</li>
					<li>

					</li>
					<li>

					</li>
					<li>

					</li>
					<li>

					</li>
					<li>

					</li>
					<li>

					</li>
					<li>

					</li>
					<li>

					</li>
					<li>

					</li>
				</ol>

			</li>

&lt;



			<li>
				<hr><h1 class="title_text">7. ДИЗАЙН МАКЕТА В FIGMA (Figma, Bootstrap, Прототипирование)</h1><hr>
				<ol>
					<li>

					</li>
					<li>

					</li>
					<li>

					</li>
				</ol>

			</li>

&lt;




			<li>
				<hr><h1 class="title_text">8. ДЕТАЛИЗАЦИЯ МАКЕТА В FIGMA (Figma, Bootstrap, Unsplash)</h1><hr>
				<ol>
					<li>

					</li>
					<li>

					</li>
					<li>

					</li>
				</ol>

			</li>

&lt;




			<li>
				<hr><h1 class="title_text">9. ДЕТАЛИЗАЦИЯ МАКЕТА В FIGMA (Figma, Bootstrap)</h1><hr>
				<ol>
					<li>

					</li>
					<li>

					</li>
					<li>

					</li>
				</ol>

			</li>

&lt;




			<li>
				<hr><h1 class="title_text">10. РЕГИСТРАЦИЯ И АВТОРИЗАЦИЯ НА ФРОНТЕНДЕ, BOOTSTRAP, AXIOS, VUE ROUTER</h1><hr>
				<ol>
					<li>

					</li>
					<li>

					</li>
					<li>

					</li>
				</ol>

			</li>

&lt;





			<li>
				<hr><h1 class="title_text">11. ВАЛИДАЦИЯ ФОРМ. VUELIDATE. IMASK. COMPUTED. МАСКИ ВВОДА. ДИРЕКТИВЫ</h1><hr>
				<ol>
					<li>

					</li>
					<li>

					</li>
					<li>

					</li>
				</ol>

			</li>

&lt;




			<li>
				<hr><h1 class="title_text">12. Готовим компоненты правильно (рефакторинг)</h1><hr>
				<ol>
					<li>

					</li>
					<li>

					</li>
					<li>

					</li>
				</ol>

			</li>

&lt;






		</ul> <!-- ОБЩИЙ -->
	</div> <!-- container-md all ОБЩИЙ -->







<!-- JS Bootstrap 5 -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-gtEjrD/SeCtmISkJkNUaaKMoLD0//ElJ19smozuHV6z3Iehds+3Ulb9Bn9Plx0x4" crossorigin="anonymous"></script>

</body>
</html>