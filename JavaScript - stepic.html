<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

	<!-- css bootstrap 5 -->
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x" crossorigin="anonymous">

	<title>JavaScript для начинающих</title>

	<style type="text/css">
		
		pre{
			color: white;
			background: #2c4352;
			padding-right: 35px;
			padding-left: 5px;
			padding-bottom: 7px;
			padding-top: 10px;
		}
		
		.all{
			background: #e5fdff;


		}

		
		body{
			background: #2c4352;

		}
		
		.spec {
			font-size: 16px;
			letter-spacing: .2em;
			font-weight: 500;
/*			text-transform: uppercase;*/
			color: #f70000;
			margin-top: 15px;
			margin-bottom: 2px;
		}

		.title_text {
			letter-spacing: .1em;
			font-weight: 500;
			color: #ce0000;
			font-size: 25px;

		}

		li{
			margin-bottom: 10px;

		}

	</style>


&lt; &lt; &lt;
</head>


<body>






<!-- 	<p><a href="https://www.youtube.com/@selfedu_rus">selfedu</a></p>
	<p><a href="https://www.youtube.com/watch?v=FyTL1bnUx5I&list=PLA0M1Bcd0w8xO_39zZll2u1lz_Q-Mwn1F">Django 3 для Python(плейлист)</a></p> -->
	<p><a href="https://stepik.org/course/2223/syllabus">https://stepik.org/course/2223/syllabus</a></p>


	<div class="container-md all"><!-- container-md all ОБЩИЙ -->
		<br>
		<h1 class="title_text border text-center">JavaScript для начинающих</h1><br>


		<!-- <img src="images\avtoblog\host.jpg" class="img-fluid"><br> -->
		<hr>
		<h1 class="title_text">
			1. Введение в JavaScript
		</h1>
		<hr>
		<ol>
			<li>
				<span class="spec">
					В двух словах о JavaScript.<hr>
				</span>
				<ul>
					<li>
						JavaScript - это язык программирования, выполняющийся на стороне пользователя с помощью браузера. Он позволяет управлять элементами веб-страницы - заставлять их менять свои свойства и расположение, двигаться, реагировать на события, такие как перемещение мыши или нажатия клавиатуры, а также создавать множество других интересных эффектов.
					</li>
					<li>
						JavaScript как название является зарегистрированной торговой маркой и принадлежит компании ORACLE.
					</li>
					<li>
						DOM (Document Object Model) - это объектная модель документа, благодаря которой можно работать с тегами HTML-документа как с деревом объектов, каждый из которых имеет свой уникальный адрес. Обращаясь по этому адресу с помощью JavaScript, можно получить доступ к тому или иному HTML-объекту и управлять его свойствами - изменять размер, цвет и т.п.
					</li>
					<li>
						BOM (Browser Object Model) - структуры, имеющей схожее строение с DOM и включающее в себя элементы браузера - окна браузера, статусная строка, история просмотра и другие. Ими также можно управлять с помощью JavaScript.
					</li>
				</ul>
			</li>

&lt;

			<li>
				<span class="spec">
					Внедрение кода, структура программы, комментарии.<hr>
				</span>
				<ul>
					<li>
						Внедрение кода JavaScript в документ HTML можно выполнить двумя способами:
						<br>- Первый - размещение кода непосредственно в HTML-файле
						<br>- Второй - размещение кода в отдельном файле.
					</li>
					<li>
						<strong>Способ 1: </strong>
						При размещении кода внутри HTML-файла код JavaScript обрамляется тэгом &lt;script>
						<pre>
&lt;html>
	&lt;head>
		&lt;title>Страница с примером кода JavaScript&lt;/title>
		<span class="text-danger">&lt;script>
			alert("Hello World!");
		&lt;/script></span>
	&lt;/head>
	&lt;body>
		Это текст основной страницы
	&lt;/body>
&lt;/html>							
						</pre>
						<strong>При открытии данной страницы появится окошко с надписью "Hello World!" и кнопкой "OK". После нажатия на кнопку "OK" продолжится выполнение страницы и на ней появится надпись "Это текст основной страницы"</strong>
					</li>
					<li>
						<strong>Способ 2: </strong>
						<br>- Создаём отдельный файл, например в папке с html файлом - myscript.js, и внутри пишем JS код
						<br>myscript.js
						<pre>alert("Hello World!");</pre>
						- В html в head добавляем ссылку на JS файл
						<br>html
						<pre>
&lt;html>
  &lt;head>
    &lt;title>Страница с примером кода JavaScript&lt;/title> 
    &lt;script src="myscript.js">&lt;/script>
  &lt;/head> 
  &lt;body>
    Это текст основной страницы
  &lt;/body> 
&lt;/html></pre>
						Здесь, аналогично появится всплывающее окно, кнопка ок, при нажатии покажет html страницу
					</li>
					<li>
						Теперь рассмотрим, из чего состоит код JavaScript:
						<p>Теперь рассмотрим, из чего состоит код JavaScript. Инструкция JavaScript - это фактически команда браузеру, указание, что необходимо выполнить. Инструкцию желательно заканчивать точкой с запятой ";"</p>
						Теперь рассмотрим, из чего состоит код JavaScript. Инструкция JavaScript - это фактически команда браузеру, указание, что необходимо выполнить. Инструкцию желательно заканчивать точкой с запятой ";"
						<p>
							Код JavaScript - это последовательность инструкций JavaScript. Инструкции выполняются браузером в том порядке, в котором они написаны. Блоки JavaScript - это способ сгруппировать инструкции вместе. Блок начинается открывающейся фигурной скобкой "{" и заканчивается закрывающейся "}"
						</p>
					</li>
					<li>
						<strong>Комменатрии в JS - '//'</strong>
						<pre>
&lt;script> 
  // Это текстовый комментарий 
  alert("Hello World");   // Этот код выполнится. 
  // alert("Hello World"); А этот нет 
  // Он закомментирован 
&lt;/script></pre>
					</li>
					<li>
						<strong>Многострочный комменатрии в JS - '/* коммент */'</strong>
						<pre>
&lt;script>
  /* Тут начинается комментарий
    alert("Hello World"); Тут код не выполнится.
    alert("Hello World"); И тут тоже.
    Здесь комментарий заканчивается */  

  alert("Hi World"); // А этот код выполнится.
&lt;/script></pre>

				</ul>
			</li>


&lt;


			<li>
				<span class="spec">
					Переменные, типы данных.<hr>
				</span>
				<ul>
					<li>
						Помещение значения в переменную называется "присвоением" значения, для этого используется операция "=". 
						<br>Переменные в JavaScript, так же как и в алгебре, используются для хранения значений или выражений.
						<br>Переменная может иметь имя, например "x" или более информативное имя, например "myPetName".
					</li>
					<li>
						<strong>
							Правила именования переменных в JS:
						</strong>
						<br>- Имена переменных чувствительны к регистру (y и Y это две разных переменных)
						<br>- Имена переменных должны начинаться с буквы, символа "$" или символа "_"
						<br>- Имя переменной может состоять из любых цифр и букв латинского алфавита, а также символов "$" и "_"
						<br>- В качестве имени переменной нельзя использовать зарезервированные и ключевые слова
					</li>
					<li>
						<strong>Ключевые слова JavaScript :</strong>
						<p>
							break, delete, function, return, typeof, case, do, if, switch, var, catch, else, in, this, void, continue, false, instanceof, throw, while, debugger, finally, new, true, with, default, for, null, try
						</p>
					</li>
					<li>
						<strong>Зарезервированные слова, не являющиеся частью языка, но могущие войти в него в будущем - стандарт ECMA-262</strong>
						<p>
							class, const, enum, export, extends, import, super
						</p>
					</li>
					<li>
						<strong>Также не рекомендуется, а в некоторых случаях и не разрешается использовать в качестве идентификаторов следующие слова:</strong>
						<p>
							implements, let, private, public, yield, interface, package, protected, static
						</p>
					</li>
					<li>
						<strong>
							Создание/ объявление переменной - var или let
						</strong>
						<pre>
var x; 
var studentName;

let x; 
let studentName;</pre>
						В конце строки должна стоять точка с запятой, и это касается не только объявления переменной, а и любой операции в JavaScript. Это не является строгим требованием языка, но отсутствие закрывающей точки с запятой иногда может приводить к непредсказуемым последствиям.
					</li>
					<li>
						Присвоить значение переменной или инициализировать ее можно на этапе объявления, Инициализация уже объявленной переменной делается без директивы var.
						<pre>
// Присвоение
var x = 1;      
let studentName = "Vasiliy";

// Инициализация
x = 1;      
studentName = "Vasiliy";</pre>
					</li>
					<li>
						<strong>Отличие let от var</strong>
						<p>
							1. Область видимости. 
							<br>- let, видна только внутри блока { ... }, в котором она объявлена.
							<br>- var видна внутри всей функции, в которой произошло объявление
						</p>
						<p>
							2. Видимость по времени.
							<br>- let, видна только после объявления
							<br>- var, может быть доступна в коде и до того места, в котором она объявлена, конечно, в рамках общих правил видимости переменных.
						</p>
						<p>
							<strong>3. var и let в цикле</strong>
							<br>При использовании переменной в качестве счетчика цикла объявленная через слово var переменная живет в течение всего выполнения цикла и доступна даже после его завершения. Если же использовать объявление через let, каждой итерации цикла будет соответствовать своя независимая переменная. Этот вариант использования мы рассмотрим в третьем модуле, при изучении замыканий.
						</p>
					</li>
					<li>
						<strong>
							Логальные и Глобальные переменные
						</strong>
						<br><strong>-Локальные переменные</strong> - это переменные, объявленные внутри функции JavaScript. Они  доступны только в пределах той функции, внутри которой они объявлены. При выходе из этой функции переменные уничтожаются.
						<br><strong>-Глобальные переменные</strong>  объявляются вне функций и к ним могут обращаться все функции и скрипты на странице. Уничтожаются такие переменные при закрытии страницы.
						<br><br>Если переменную объявить без использования ключевого слова "var", то она автоматически объявляется глобальной, даже если объявление произведено внутри функции.
						<br>Например выражения x = 5; или surName = "Ivanov"; объявят переменные x и surName как глобальные, если их еще не существует.
					</li>
					<li>
						<strong>
							Типы данных в JavaScript:
						</strong>
						<br>- Числа (number)
						<br>- Строки (string
						<br>- Логические (boolean)
						<br>- Неопределенные (undefined)
						<br>- Объект (object)
						<br>- Пустой (null)
					</li>
					<li>
						Для того, чтобы <strong>определить тип данных</strong>, записанных в переменной, мы можем воспользоваться оператором <strong>typeof</strong>.
						<pre>
var myName = "Ivan";
alert (typeof myName);

--> string</pre>
					</li>
					<li>
						<strong>
							Тип данных number
						</strong>
						- var x = 5;
					</li>
					<li>
						<strong>
							Тип данных string
						</strong>
						- var x = "5";
					</li>
					<li>
						<strong>
							Тип данных string
						</strong>
						- var x = "5";
					</li>
					<li>
						<strong>
							Тип данных boolean - true / false 
						</strong>
						- логическая 1 / логический 0
					</li>
					<li>
						<strong>
								Тип данных undefined
						</strong>
						- переменная имеет в тот момент, когда она объявлена, но еще не инициализирована, то есть ее создали, а значение еще не присвоили.
					</li>
					<li>
						<strong>
							Типы данных object и null
						</strong>
						рассмотрим позднее.
					</li>
					<li>
						пример функции, которая принимает на входе значение переменной a, внтри функции обявляется переменная х, которой присваивается значение переменной а, на выходе, возвращаем значение переменной x
						<pre>
function testA(a) {      // Определение функции с названием testA. Это служебная информация, менять ее нельзя.
                         // Мы видим, что у функции есть входной параметр - переменная "a".
    var x=a;            // Объявление переменной "x", которую мы будем возвращать в качестве результата.
                         // Тут нужно написать решение - код, который будет помещать результат в "x".
    return x;            // Команда вывода ("возврата") результата, ее тоже менять нежелательно.
}</pre>
					</li>
				</ul>
			</li>


&lt;


			<li>
				<span class="spec">
					Простейшие операции.<hr>
				</span>
				<ul>
					<li>
						<strong>Операции в JavaScript:</strong>
						<br>- Арифметические операторы
						<br>- Операторы присваивания
						<br>- Операторы сравнения
						<br>- Логические операторы
					</li>
					<li>
						<strong>Арифметические операторы</strong>
						<pre>
при исходных данных y = 5

<span class="text-danger">Сложение  "+"</span>
выражение x = y + 2  результат x = 7; y = 5;

<span class="text-danger">Вычитание "-"</span>
выражение x = y - 2  результат x = 3; y = 5;

<span class="text-danger">Умножение "*"</span>
выражение x = y * 2  результат x = 10; y = 5;

<span class="text-danger">Деление "/"</span>
выражение x = y / 2  результат x = 2.5; y = 5;

<span class="text-danger">Возведение в степень "**"</span>
выражение x = y ** 2  результат x = 25; y = 5;</pre>
					</li>
					<li>
						<strong>Сложные арифметические операторы:</strong>
						<br>y = 5
						<br><strong>Остаток от деления (он же - деление по модулю) "%"</strong>
						<br>x = y % 2 даст результат x = 1; y = 5;
						<br><br><strong>Инкремент "++"</strong>
						<br>Эта операция производит увеличение аргумента на единицу, т.е. выражение x++ будет эквивалентно выражению x = x + 1. <strong>Порядок имеет значение!:</strong>
						<br>- x = ++y даст результат x = 6, y = 6, - так как вначале увеличивается значение переменной y на единицу и затем переменной x присваивается значение переменной y
						<br>- x = y++ даст результат x = 5, y = 6, поскольку в данном случае операция инкрементирования (увеличения) происходит ПОСЛЕ того как переменной х присвоили значение из переменной у.
						<br><br><strong>Декремент "--"</strong>
						<br>А эта операция производит уменьшение значения переменной на единицу, т.е. х-- эквивалентно x = х - 1. Порядок применения декремента в javascript также имеет значение, например:
						<br>- x = --y даст результат x = 4, y = 4
						<br>- x = y-- даст результат x = 5, y = 4
					</li>
					<li>
						Ещё раз примеры '++' и '--'
						<pre>
x = 6, y = 3 //условие
x = ++y //выполнение
x = 4, y = 4 //результат
// 1)к y прибавили 1
// 2)x присвоили y

x = 6, y = 3 //условие
x = y++ //выполнение
x = 3, y = 4 //результат
// 1)x присвоили y
// 2)к y прибавили 1

x = 6, y = 3 //условие
x = --y //выполнение
x = 2, y = 2 //результат
// 1)от y вычли 1
// 2)x присвоили y

x = 6, y = 3 //условие
x = y-- //выполнение
x = 3, y = 2 //результат
// 1)x присвоили y
// 2)от y вычли 1</pre>
					</li>
					<li>
						<strong>
							Операторы присваивания:
						</strong>
						<br>
						<br><strong>=</strong>
						<br>x=y - x равно y

						<br>
						<br><strong>+= присваивание со сложением</strong>
						<br>x+=y --> x=x+y

						<br>
						<br><strong>-= присваивание с вычитанием</strong>
						<br>x-=y --> x=x-y

						<br>
						<br><strong>*= присваивание с умножением</strong>
						<br>x*=y --> x=x*y

						<br>
						<br><strong>/= присваивание и деление</strong>
						<br>x/=y --> x=x/y

						<br>
						<br><strong>%= присваивание  с операцией "остаток от деления"</strong>
						<br>x%=y --> x=x%y
						
					</li>
					<li>
						Создание и выполнение функции сложения двух переменных, и вывод её результата в сплывающим окне
						<pre>
function testSum(a, b) {     // создали функцию, которая принимает 2 значения a и b
    var result=a+b;     // внутри функции создали переменную relult, которая складывает a и b
    return result;     // функция возвращает результат переменной result
}

alert ('2 + 8 = ' + testSum(2,8));    // вызываем функцию, передвавая 2 параметра, выводим в всплыв окне</pre>
					</li>
					<li>
						<strong>операторы сравнения:</strong>
						<br>==  //равно  - <strong>5 == '5' true!</strong>
						<br>===  //строго равно - <strong>5 === '5' false!</strong>
						<br>!=  //не равно  5!=8 true
						<br>!===  //строго не равно, (возвращает true если операнды строго не равны или имеют разный тип
						<br>>  //больше чем
						<br><  //меньше чем
						<br>>=  //больше или равно
						<br><=  //меньеше или равно
					</li>
					<li>
						<strong>Логические опараторы (и/или/не)</strong>
						<br>Пример для x=6, y=3:
						<br><strong>-Оператор && (Логическое И)</strong>
						<br>x<10 && y>1 true - (x меньше 10) И (y больше 1) - верно
						<br>
						<br><strong>-Оператор || (Логическое ИЛИ)</strong>
						<br>х==5 || y==5 false - (х равно 5) или (у равно 5) - неверно
						<br>
						<br><strong>-Оператор ! (Логическое НЕ)</strong>
						<br>!(х==y) true - x НЕ равно y - верно
						<br>
					</li>
					<li>
						<strong>Приоритет выполнения операторов (порядок выполнения):</strong>
						<ol>
							<li>
								Самым высоким приоритетом обладают операторы группировки. В данном случае это скобки "(" и ")"
								<pre>
i = (a + b) * c 
/* 
В данном случае группировка имеет более высокий приоритет чем умножение, 
поэтому сначала выполнятся все операции внутри скобок 
*/</pre>
							</li>
							<li>
								За ними следуют операторы постфиксного (указанного ПОСЛЕ переменной) инкремента и декремента 
								<pre>
a-- //Постфиксный декремент
b++ //Постфиксный инкремент</pre>
							</li>
							<li>
								Следующими по приоритету идут префиксные инкремент и декремент а также логическое отрицание
								<pre>
--x //Префиксный декремент
++y //Префиксный инкремент
 !z //Логическое отрицание</pre>
							</li>
							<li>
								За ними идет возведение в степень
								<pre>x = y ** z //Возведение в степень</pre>
							</li>
							<li>
								Следующая группа: умножение, деление и остаток от деления
								<pre>
x = y * z //Умножение
x = y / z //Деление
x = y % z //Остаток от деления</pre>
							</li>
							<li>
								Еще меньшим приоритетом обладают операции сложения и вычитания
								<pre>
x = y + z //Сложение
x = y - z //Вычитание</pre>
							</li>
							<li>
								Следом идут операции сравнения
								<pre>
>   //Больше
>=  //Больше или равно
<   //Меньше
<=  //Меньше или равно</pre>
							</li>
							<li>
								Затем операции равенства
								<pre>
==   //Равно 
!=   //Не равно
===  //Строго равно
!==  //Строго не равно</pre>
							</li>
							<li>
								Логические операции
								<pre>
&   //Побитовое И
|   //Побитовое ИЛИ (побитовые операции мы не рассматривали в данном уроке)
&&  //Логическое И
||  //Логическое ИЛИ</pre>
							</li>
							<li>
								И наконец последними выполняются операции присваивания
								<pre>
=   //Присваивание
+=  //Присваивание со сложением
-=  //Присваивание с вычитанием
**= //Присваивание с возведением в степень
*=  //Присваивание с умножением
/=  //Присваивание с делением
%=  //Присваивание с остатком от деления</pre>
							</li>
						</ol>
					</li>
					<li>
						Создадим функцию, которая принимает 2 параметра, функция вычисляет удвоенное значение остатка от деления, произведения a*b и суммму a+b - ((a*b) % (a+b)) * 2
						<pre>
function testOperation(a, b) { // создали функцию, которая принимает 2 значения a и b
    var result      // создали переменную reslult
    result = ((a*b) % (a+b)) * 2;  // переменной reslult присваеваем результат выполнения математической операции
    return result;       // функция возвращает result
}</pre>
						Вызываю функция во всплывающем окне
						<pre>alert ('result = ' + testOperation(6,4)); // вызываем функцию, передвавая 2 параметра, выводим в всплыв окне</pre>
					</li>
				</ul>
			</li>


&lt;


			<li>
				<span class="spec">
					Ветвление.<hr>
				</span>
				<ul>
					<li>
						<strong>Ветвление/условные операторы (if..else, swith)</strong>
						<pre>
if (условие) {
  // код для выполнения если условие истинно
}</pre>
						Пример (условие не выполнится, т.к x не больше 11)
						<br><strong>if</strong>
						<pre>
var x = 10;
var y = 50;

if (x > 11) {
 x += y;
}</pre>
					</li>
					<li>
						<strong>Тернарный оператор </strong>
						<br>
						<strong>
							имя_переменной = (условие) ? значение1 : значение2;
						</strong>
						Это означает, что в результате выполнения выражения в переменную будет записано либо значение1 либо значение2, в зависимости от результата проверки истинности условия.
						<br>Пример:
						<pre>
var friend = 'Jack';
var hiJack = (friend == "Jack") ? "Hi, Jack!" : "Hi";
console.log(hiJack);</pre>
						Приведет к выводу "Hi, Jack!" если переменная friend будет иметь значение "Jack" или к выводу "Hi" при любом другом значении.
					</li>
					<li>
						Выполнение блока кода если ксловие верно, и выполнение кода если условие не верно<br>
						<strong>if else</strong>
						<pre>
if (условие) {
	// код для выполнения если условие истинно
} else {
	// код для выполнения если условие ложно
}</pre>
						Пример:
						<pre>
var x = 10;
var y = 50;

if (x > 11) {
  x += y;  //код не выполнится
} else {
  x -= y;  //Выполнится x = 10 - 50 = -40
}</pre>
					</li>
					<li>
						Создам функцию, которая принимает 2 переменных, сравнивает их, складывает если значение первой переменной больше значения второй переменной, иначе перемножеает Эти переменные
						<pre>
function testIf(a, b) {  //созд функцию, на входе 2 параметра
    var x;  //создали переменную
    if (a > b) {  //если a > b
        x = a + b;  // x = a + b
    } else {  // иначе
        x = a * b;  // x = a * b
    }
    return x;  // возвращаем результат
}

//вызываю функцию (2 раза) - вывожу результат в консоле разработчика
console.log(testIf(3,7)); //x = 3 * 7 = 21
console.log(testIf(7,3)); //x = 3 + 7 = 10</pre>
					</li>
					<li>
						<strong>if + else if + else</strong>
						<br>три вариванта выполнения программы (если условие один, если условие 2, иначе)
						<pre>
if (x > 11) {
  x += y;  //выполнится если X>11
} else if (x == 4) { 
  x -= y;  //выполнится если X==11
} else { 
  x = y;  //выполнится в любом другом случае
}</pre>
					</li>
					<li>
						Пример 2, проверка двух условий, if + esle if + else
						<pre>
function testIfElse(a, b) {
    var x;
    if (a < b) {
        x = a + b;
    } else if (a > b){
        x = a - b;
    } else {
        x = a * b;
    }
    return x;
}

console.log('a=7; b=9; x=a+b=' + testIfElse(7,9));
console.log('a=11; b=9; x=a-b=' + testIfElse(11,9));
console.log('a=9; b=9; x=a*b=' + testIfElse(9,9));</pre>
					</li>
					<li>
						<strong>
							switch:
						</strong>
						<br>Данная конструкция позволяет выбирать один из многих вариантов кода на выполнение в зависимости от условия (обычно это значение одиночной переменной). Синтаксис команды выглядит следующим образом:
						<pre>
switch(<span class="text-danger">n</span>) { 
  case <span class="text-danger">1</span>:
    // блок кода 1;
    break;
  case <span class="text-danger">2</span>:
    // блок кода 2;
    break;
   
  // .......
  // другие варианты  case
  // .......
  default: 
    // блок кода если не подошло ни одно условие;
}</pre>
						Выражение условия (то, что находится в скобках после switch) вычисляется один раз, затем результат выражения сравнивается с каждым значением case в данной конструкции (т.е. в данном случае содержимое переменной n сравнивается со значениями 1, 2 и т.д.).
						Если условие совпадает, то выполняется блок кода, связанный с соответствующим case. Если ни одно условие не подошло, то выполняется код, указанный в блоке default, если он есть. Для выхода из конструкции используется команда break. Если ее не указывать, автоматически выполнится блок кода в следующем case и т.д.
						<br>Пример
						<pre>
var a = <span class="text-info">3</span>;   //объявляем переменную по которой будем делать выборку
var x = "";  //объявляем переменную в которую будем записывать результат

switch (<span class="text-danger">a</span>) {
  case <span class="text-danger">1</span>:                               // если a равна единице то записываем 
    x = "Переменная a равна единице!";  // в переменную x фразу "Переменная a равна единице!"
    break;
  case <span class="text-danger">2</span>:
    x = "Переменная a равна двум!";
    break;
  case <span class="text-info">3</span>:
    x = "Переменная a равна трем!";
    break;
  default:
    x = "Переменная a не равна 1, 2 или 3!";
}

// В итоге результат выполнения switch оказывается в переменной x
console.log(x) // --> <span class="text-info">Переменная a равна трем!</span></pre>
					</li>
					<li>
						Проверка числа shitch / case, от 0 до 9 включительно, и вывод в виде текста, во всплывающем окне
						<pre>
function testCase(a) {
    var x;
    switch (a) {
        case 0:
            x = 'Ноль';
            break;
        case 1:
            x = 'Один';
            break;
        case 2:
            x = 'Два';
            break;
        case 3:
            x = 'Три';
            break;
        case 4:
            x = 'Четыре';
            break;
        case 5:
            x = 'Пять';
            break;
        case 6:
            x = 'Шесть';
            break;
        case 7:
            x = 'Семь';
            break;
        case 8:
            x = 'Восемь';
            break;
        case 9:
            x = 'Девять';
            break;
        default:
            x = 'Переменная a, вне диапазона от 0 до 9 включительно';
    }
    return x;
}

alert('Переменная a = ' + testCase(10))</pre>
					</li>
				</ul>
			</li>

&lt;


			<li>
				<span class="spec">
					Циклы.<hr>
				</span>
				<ul>
					<li>
						В JavaScript мы имеем два вида циклов:
						<br>for - выполнение кода указанное количество раз
						<br>while - выполнение кода пока истинно заданное условие.
					</li>
					<li>
						<strong>Цикл For</strong>
						<br>Цикл For используется в тех случаях, когда мы можем определить заранее - сколько раз должен выполниться заданный блок кода.
						<br><strong>for (переменная=начальное_значение; переменная <= конечное_значение; переменная = переменная + шаг) {<br>&nbsp;&nbsp;&nbsp;&nbsp;исполняемый код<br>}</strong>
						<pre>
// i = 1, 2, 3, 4, 5
for (let i = 1; i <= 5; i = i + 1) {
  console.log("i = " + i);
}

или просто, без let

for (i = 1; i <= 5; i = i + 1) {
  console.log("i = " + i);
}
</pre>
						Итерация от 10 до 100 включительно
						<pre>
for (x = 10; x <= 100; x = x + 10) {
    console.log ('x = ' + x);
}</pre>
					</li>
					<li>
						<strong>for ... in</strong>
						<br>Этой операцией производится перебор всех разрешенных свойств объекта. Более подробно мы рассмотрим использование этой конструкции позже, при изучении объектов, а пока лишь упомянем ее синтаксис
						<pre>
for (переменная in объект) {
  исполняемый код
}

for (i in car) {
  console.log(car[i] + ' ');
}</pre>
						Вычисление факторииала a = 5 = 1*2*3*4*5 (факториал числа a это произведение всех целых чисел от 1 до a)
						<pre>
function testFactorial(a) {
    var x = 1;  // начальное значение обязатольно
    for (i = 1; i <= a; i = i + 1) {  // цикл от 1 до 5
        x = x * i  // меняем x на каждой итерации, 1*1, 1*2, 2*3, 6*4, 24*5 = 1*2*3*4*5
        console.log (i + '. i = ' + i);  // значение i на кадой итерации
        console.log (i + '. x = ' + x);  // значение x (факториал) на кадой итерации

    }
}

testFactorial(5) // вызываем функцию !5 = 1*2*3*4*5 = 120</pre>
					</li>
					<li>
						<strong>цикл while</strong>
						<br>В нем происходит выполнение блока кода, пока заданное условие истинно.
						<pre>
while (выражение, возвращающее логическое значение) {  
//в цикле может использоваться, например, оператор сравнения вида x == 10 или просто переменная типа Boolean  

исполняемый код
}</pre>
						Пример:
						<pre>
var x = 1; 
while (x <= 5) {
  console.log(" x= " + x);
  x = x + 1;
}1</pre>
					</li>
					<li>
						<strong>do ... while</strong>
						<br>Оператор проверки условия расположен ПОСЛЕ основного тела исполняемого кода, что обеспечивает как минимум однократное выполнение блока кода.
						<pre>
do {
  исполняемый код
} while (переменная == проверочное значение);</pre>
						Пример:
						<pre>
var x = 5;                //установка начального значения
do {	//начало выполнения цикла
  console.log(x);	//вывод данных в консоль
  x = x - 1;	//уменьшение значения на 1
} while (x >= 1);	//проверка условия</pre>
					</li>
					<li>
						Пример while - вычислить сумму всех чётных чисел от 1 до числа включительно
						<pre>
function testWhile(a) {
    var x = 0; //переменная суммы
    var i = 1; //переменная итерации
    while (i <= a) { //цикл идёт пока i не сравняется с A (от 1 до a)
        if (i % 2 == 0) { //если число чётное
            x = x + i;  //прибавляем в переменную суммы чётное число
            console.log ('четное i = ' + i);  //вывод чётного числа
        }
        i = i + 1;  //увеличиваем переменную итерации на 1
    }
    return x;
}

console.log(testWhile(10)) //--> 30 = 2+4+6+8+10</pre>
					</li>
					<li>
						<strong>break</strong> позволяет нам прервать цикл и перейти к коду, следующему после цикла.
						<pre>
for (i = 1; i < 10; i = i + 1) { // цикл от 1 до 9 вкл
  if (i == 5) { // если i будет равно 5
    break;  // прервёт цикл
  }
  console.log('i= '+i); // i=1/2/3/4 break!
}</pre>

					</li>
					<li>
						<strong>continue </strong>прерывает(пропустит) текущую итерацию цикла и переходит к следующей.
						<pre>
for (i = 1; i < 10; i = i + 1) {  // цикл от 1 до 9 вкл
  if (i == 5) {  //если i = 5
    continue;  // пропустим итерацию
  }
  console.log('i= ' + i);  // i=1/2/3/4/6/7/8/9
}</pre>
					</li>
					<li>
						<strong>Метки.</strong>
						Метки в JavaScript действуют только для циклов и оператора Switch, так что сделать из них полноценный переход в любую точку программы не получится. Однако, этого вполне хватает для перемещения в любое место вложенности внутри циклов.
						<pre>
var i, j;

metka1:
for (i = 0; i < 5; i = i + 1) {  //i от 1 до 4 
   metka2:
   for (j = 0; j < 5; j = j + 1) { //j от 1 до 4
       if (i == j) {
           continue metka1; 
        } else {
          if (i == 3) {
              break metka2; 
          }
          console.log(i, j);
        }
    }
}
// результат 1 0/ 2 0 / 2 1 / 4 0 / 4 1 / 4 2 / 4 3</pre>
					</li>
				</ul>
			</li>

		</ol> <!-- 1. Введение в JavaScript -->




		<hr>
		<h1 class="title_text">
			2. Стандартные объекты
		</h1>
		<hr>
		<ol> <!-- 2. Стандартные объекты -->
			


			<li>
				<span class="spec">
					Функции<hr>
				</span>
				<ul>
					<li>
						<p>
							Функции в JavaScript - это блоки кода, которые имеют свое имя (кроме анонимных) и могут быть вызваны по этому имени.
							<br><br>Функции  в JavaScript бывают встроенными, например alert() и пользовательскими, которые программист создает сам.
							<br><br>В Функции в JavaScript могут передаваться некоторые параметры, например необходимые для вычисления возвращаемых значений.
							<br><br>Основное назначение функции заключается в том, чтобы избавить программу от дублирования кода. Записав определенную последовательность команд можно вызывать ее сколько угодно раз
						</p>						
					</li>
					<li>
						<strong>Создание/определений функции и вызов без параметров</strong>
						<br>-function имя_функции(параметры_НЕ_ОБЯЗАТЕЛЬНО)
						<br>-{ Тело функци };
						<pre>
function printText() {                   //Определение функции
  document.write("Hello World!");        //Тело функции - вывод текста в документ
};


printText(); //Вызов функции
--> Hello World!</pre>
					</li>
					<li>
						<strong>Создание/определений функции и вызов С папаметром</strong>
						<pre>
function printText(a) {           //Определение функции
  document.write(a);              //Тело функции - вывод содержимого переменной "а" в документ
};


printText("Hello World!"); --> 	Hello World!</pre>
					</li>
					<li>
						<strong>Создание функци в переменной, при создании переменной, в одну строчку</strong>
						<pre>
// создаём функцию
var printText = function(a) {document.write(a);};			

// вызываю функцию
printText('Привет') --> в html будет Привет</pre>
					</li>
					<li>
						<strong>Самовызывная функция</strong>
						<pre>
var printText = function(a) {document.write(a);}('Здравствуйте!');
-->  Здравствуйте

<span class="text-danger">Но лучше сделать так</span>
var printText = (function(a) {document.write(a);}('Здравствуйте!'));
-->  Здравствуйте</pre>
					</li>
					<li>
						<strong>return</strong>
						Возврат резкльтата работы функции
						<pre>
function mySquare(x) {
    return x*x;
};

alert (mySquare(5)); --> 25 (5*5=25)</pre>
						<br>return может быть несколько
						<pre>
function divideOneTo(x) {
    if (x != 0) {
        return 1/x;
    } else {
        return 'На ноль делить нельзя!';
    }
}

alert (divideOneTo(10)); // 0.1
alert (divideOneTo(0)); // На ноль делить нельзя!</pre>
					</li>
					<li>
						Однако, использование ключевого слова return не является обязательным. Если в теле функции его нет, то после выполнения всех команд интерпретатор закончит выполнение функции. Значение, которое возвращает эта функция будет "undefined".
					</li>
					<li>
						<strong>Рекурсивная функция - </strong>функция которая может вызывать саму себя.
						<br>Пример вычисление факториала
						<pre>
function factorial(x) {        //Объявление функции
  if (x <= 1) return 1;        //Проверка условия окончания расчета
  return x * factorial(x-1);   //Вызов этой же функции с уменьшенным на 1 аргументом
}

console.log(factorial(5)); // 120 (1*2*3*4*5=120)</pre>
					</li>
					<li>
						Отночительно сложное задание, рекурсивная функция, из 10 получить 1 2 3 4 5 6 7 8 9 10
						<pre>
function my_function(n) {
    if (n <= 1) {
        return 1;
    } else {
        return my_function(n-1) + ' ' + n;
    }
}

console.log(my_function(10));
-->1 2 3 4 5 6 7 8 9 10</pre>
					</li>
				</ul>
			</li>




			<li>
				<span class="spec">
					Объекты<hr>
				</span>
				<ul>
					<li>
						 JavaScript является объектно-ориентированным языком программирования
						 <br><br>Объект - это особый вид данных, обладающий свойствами, описывающими его состояние, и методами, позволяющими работать с объектом.
						 <br><br>Объект в JavaScript представляет собой ассоциативный массив, то есть фактически является набором пар "ключ: значение". Например, у строкового объекта String, коим является любая строковая переменная, есть свойство length - длина. В частности, у объекта textString, созданного командой var textString = "Hello World!"; будет свойство length, ключом в паре будет имя "length", а его значение будет число 12 - фактическая длина строки.
						 <br><br>length - ключ, значение lengt - значение
					</li>
					<li>
						<strong>Свойства объекта</strong> - это некоторые значения, связанные с этим объектом.
						<br><strong>имяОбъекта.имяСвойства</strong> - Синтаксис доступа к свойству объекта
						<pre>
var textString = "Hello world!";
console.log(<strong>textString.length</strong>); --> 12</pre>
					</li>
					<li>
						<strong>Методы</strong> - это действия, которые могут быть выполнены над объектом. Они могут присутствовать у объекта, а могут и не присутствовать.
						<br><br>
						<strong>имяОбъекта.имяМетода();</strong><br>(В скобках указываются параметры, которые необходимо передать в метод. Их еще называют "аргументами".)
					</li>
					<li>
						Вывод текста заглавными буквами - <strong>toUpperCase()</strong>
						<pre>
var textString = "Hello world!";
console.log(textString.toUpperCase()); 
--> HELLO WORLD!</pre>
					</li>
					<li>
						<strong>Создание объекта:</strong>
						<br>Первый способ - создание непосредственно экземпляра объекта
						<pre>
var person = new Object();
	или
var person = {};</pre>
						<br>Второй способ - <strong>Создание объекта через конструктор</strong>. Т.е. мы должны описать функцию, которая будет создавать объект и присваивать значения его свойствам.
						<br><br>
						<strong>Создаём функцию, которая будет создавать объект, и присваивать значения его свойствам</strong>
						<br><span class="text-danger">this - обращение к текущему экземпляру (self - в Python)</span>
						<pre>
function Person(name, age, year) {
  this.name = name;
  this.age = age;
  this.year = year;
}</pre>
						<strong>Создаём несколько экземпляров объекта (записей)</strong>
						<pre>
var men1 = <span class="text-danger">new</span> Person('Александр', '30', '1992');
var men2 = <span class="text-danger">new</span> Person('Брэд', '50', '1972');</pre>
						<strong>Обращаемся к каждому полю записи men1</strong>
						<pre>
alert ('Имя: ' + men1.name);  --> Имя: Александр
alert ('Возраст: ' + men1.age);  --> Возраст: 30
alert ('Год рождения: ' + men1.year); --> Год рождения: 1992</pre>
					</li>
					<li>
						<strong>Создание объекта без функции</strong>
						<pre>
var Car = {};  // создали пустой объект
Car.name = 'BMW'  // добавили поле name со значением BMW
console.log(Car) // {name: 'BMW'}
console.log(Car.name) // BMW</pre>
					</li>
					<li>
						<strong>Создание объекта со множеством пар ключ: значение</strong>
						<pre>
// Создаю объект
var Animal = {
    view: 'Птица',
    name: 'Кеша',
    age: 2
}

// обращаюсь к объекту
console.log(Animal) --> {view: 'Птица', name: 'Кеша', age: 2}

// обращаюсь к полю объекта
console.log(Animal.name);
	ИЛИ
console.log(Animal['name']);
--> Кеша</pre>
					</li>
					<li>
						<strong>Удаление свойства объекта(поле)</strong>
						<br>Тот же объект (Animal)
						<pre>
// удаляю свойство(поле) - view
delete Animal.view;

// обращаюсь к объекту
console.log(Animal); --> {name: 'Кеша', age: 2}

// обращаюсь к удалённому свойству объекта
console.log(Animal.view); --> undefined ('неопределённое значение')</pre>
					</li>
					<li>
						<strong>Добавление метода в объект</strong> - это фактически присвоение функции некоторому свойству объекта.
						<pre>
var person = {}; // создали пустой объект
person.sayAge = function(age) { // объявляем метд sayAge для объекта person
    console.log('Человеку ' + age + ' лет');
};

person.sayAge(40); // вызываем метод sayAge, объекта person
--> Человеку 40 лет</pre>
					</li>
					<li>
						<strong>Добавление метода к объекту</strong> (добавить поле с функцией в объект)
						<pre>
var person = {  // созание объекта
    name: 'Александр',
    age: 25,
    lenght: 173
};

console.log(person); // {name: 'Александр', age: 25, lenght: 173}

person.sayName = function() {
    console.log("Моё имя - " + this.name);
}; // создали метод получение строки с именем для объекта

console.log(person); // {name: 'Александр', age: 25, lenght: 173, sayName: ƒ}
person.sayName(); // вызываем метод получения строки с именем</pre>
					</li>
					<li>
						<strong>Перебор всех свойств и методов объекта (полей)</strong>
						<br><br>
						<strong>for (key in object){}</strong>
						<br>где key - совйство, object - объект
						<br>object[key] - обращение к содержимому поля, обхекта
						<pre>
var car = {  // создаём объект
    name : 'Lexus',
    category : 'Japan',
    power : '512ph',
    year : 2018
}

console.log(car); --> {name: 'Lexus', category: 'Japan', power: '512ph', year: 2018}

// перебираем все поля объекта и выводим в тексте
//<span class="text-danger">i - ключ : car[i] - значение</span>
for (i in car) {
    console.log(i + ' is ' + car[i]);
};

-->
name is Lexus
category is Japan
power is 512ph
year is 2018</pre>
					</li>
					<li>
						Добавлю метод получения всех полей в тексте, для вышеуказанного объекта
						<pre>
car.sayAll = function() {  // создаём в поле обхекта функцию
    for (var i in this) {  // перебираем все поля объекта
        if (!(this[i] instanceof Function))  // если поле не функция
        console.log(i + ' объекта ' + this[i]);  // выводим в консоль
    }
};

console.log(car); // {name: 'Lexus', category: 'Japan', power: '512ph', year: 2018, sayAll: ƒ}
car.sayAll(); // вызываем функцию нашего объекта

-->
name объекта Lexus
category объекта Japan
power объекта 512ph
year объекта 2018</pre>
					</li>
				</ul>
			</li>





			<li>
				<span class="spec">
					Строки<hr>
				</span>
				<ul>
					<li>
						Создание строки, и <span class="text-danger">строкового объекта</span>
						<pre>
myString = 'Привет' // typeof string, создание строки
var myString = new String('Привет');	// typeof object - <span class="text-danger">создание строкового объекта</span>
var myString = String('Привет');	// typeof string - создание строки</pre>
						<strong>Строковому объекту, можно напрямую назначать дополнительные свойства и методы</strong>
					</li>
					<li>
					 У строки есть одно стандартное <span class="text-danger">свойство</span> - длина.
					 <br><strong>Получение длины строки</strong>
					 <pre>
var text = 'Привет, меня зовут Александр';
console.log(text.length); //28</pre>
					</li>
					<li>
						Получение длины двух строк, но вводе могут быть и числа!
						<pre>
function testStr(a, b) {
    a = String(a);  // на случай если введут число
    b = String(b);  // на случай если введут число
    return a.length + b.length;  // возвращаем сумму длины строк
}

alert(testStr(123, 456));  // на вводе числа!
// результат будет 6</pre>
					</li>
					<li>
						<strong><span class="text-danger">Методы</span> строки</strong>
						<br>Методов у строк много (свойство одно)
						<br><strong>Метод получения символа по индексу</strong>
						<pre>
var text = 'Cat';

console.log(text.charAt(0)); --> C
console.log(text.charAt(1)); --> a
console.log(text.charAt(2)); --> t</pre>
						Или
						<pre>
var text = 'Cat';

console.log(text[0]); --> C
console.log(text[1]); --> a
console.log(text[2]); --> t</pre>
						<strong>Получение строки задом наперёд</strong>
						<pre>
var text = 'Cat';
text = text[2] + text[1] + text[0];
console.log(text); --> taC</pre>
					</li>
					<li>
						Получение 19 символа строки (индекс 18!)
						<pre>
function testStr(str, n) {
    return str[n-1];
};

console.log(testStr('Ithardlycousinmealways', 19));
--> w</pre>
					</li>
					<li>
						<strong>Слияние строк - string1.concat(string2, ..., stringN)</strong>
						<pre>
var a = 'Первая';
var b = 'Вторая';
var c = 'Третья';

// к строке а, добавляем строку b и строку c
result = a.concat(b, c);
console.log(result)
--> ПерваяВтораяТретья</pre>
					</li>
					<li>
						<strong>split - разделение строк</strong>
						<br>split('разделитель') - разделяет строки на массив подстрок по указанному разделителю
						<br><strong>При разбитии строки - получиться массив(список) Array</strong>
						<pre>
var myString = 'кот,собака,попугай';
var myArray = myString.split(',');
console.log(myArray);  // (3) ['кот', 'собака', 'попугай']</pre>
						<br>Если разделитель не будет найден, то получится массив из одного элемента
						<pre>
var myString = 'кот,собака,попугай';
var myArray = myString.split('.');
console.log(myArray);  // массив ['кот,собака,попугай']</pre>
						<br><strong>Разбитие строки на элементы в массив, с указанием параметра - максимальное количество элементов в массиве</strong>
						<pre>
var myString = 'кот:собака:попугай';
var myArray = myString.split(':', 2);
console.log(myArray);  // массив (2) ['кот', 'собака']</pre>
					</li>
					<li>
						<strong>Преобразование регистра</strong>
						<br><strong>- toLowerCase()</strong> - преобрахование всех букв в строке в нижний регистр
						<br><strong>- toUpperCase(</strong> - преобрахование всех букв в строке в верхний регистр
						<br><strong>- toLocaleLowerCase()</strong> - преобрахование всех букв в строке в нижний регистр
						<br><strong>- toLocaleUpperCase()</strong> - преобрахование всех букв в строке в верхний регистр
						<pre>
var catName = 'Симба';

console.log(catName.toLowerCase()); --> симба
console.log(catName.toUpperCase()); --> СИМБА
console.log(catName.toLocaleLowerCase()); --> симба
console.log(catName.toLocaleUpperCase()); --> СИМБА</pre>
					</li>
					<li>
						Задание, преобразование первой строки в верхний регистр, второй - в нижний, + слияние этих строк.
						<pre>
function testStr(a, b) {
    return a.toUpperCase().concat(b.toLowerCase());
}

console.log(testStr('Hello', 'World!'));
// --> HELLOworld!</pre>
					</li>
					<li>
						<strong>Возвращение части строки (как слайсинг в Python)</strong>
						<br><strong>substring(indexA[, indexB])- </strong> возвращает часть строки начиная с позиции indexA, но не включая indexB
						<br><strong>substring - не принимает отричательные аргуметы, точнее приравнивает их к нулю</strong>
						<pre>
var myString = 'Это просто строка!';
console.log(myString.substring(4,17));
// покажет строку от 4 вимвола до 16.
// просто строка

console.log(myString.substring(4));
// от четвёрного символа до конца
// просто строка!

console.log(myString.substring(4, 0));
// до четрёвтного включительно
// просто строка!

console.log(myString.substring(0, 4));
// до четрёвтного включительно
// просто строка!

console.log(myString.substring(0));
// полная строка
// Это просто строка!

console.log(myString.substring(-2));
// -2 = 0, т.е полная строка!
// Это просто строка!</pre>
					</li>
					<li>
						<strong>
							slice( indexA[, indexB] ) - 
						</strong>
						возвращает часть строки начиная с позиции indexA, но не включая indexB, т.е то же самое
						<br><strong>Но slice - работает с отрицательными аргументами!</strong>
						<pre>
var myString = 'Это просто строка!';

console.log(myString.slice(4,-1));
// от четвёртого символа до последнего не включительно
// просто строка

console.log(myString.slice(-1));
// последний символ с конца
// !

console.log(myString.slice(-10));
// от десятого с конца до конца
// то строка!

console.log(myString.slice(-10, -1));
// от десятого с конца до конца не включая последний символ
// то строка</pre>
					</li>
					<li>
						<strong>substr(indexA[, length]) - </strong>возвращает часть строки начиная с позиции indexA, в количестве length
						<pre>
var myString = 'Это просто строка!';
console.log(myString.substr(4, 5));
// от 4 символа по индексу - 5 символов
// прост</pre>
					</li>
					<li>
						<strong>
							replace(regexp, newSubString|function) - 
						</strong>возвращает новую строку после замен, указанных в regexp, или функцию, которая ее возвращает.
						<br>Рассмотрим позже - регулярные выражения
					</li>
					<li>
						<strong>
							Поиск подстроки в строке:
							<br> - indexOf(searchValue[, fromIndex])
							<br> - lastIndexOf(searchValue[, fromIndex])
							<br> - search(regExp)
							<br> - match(regExp)
						</strong>
					</li>
					<li>
						<strong>indexOf(searchValue[, fromIndex]) - </strong>ищет подстроку searchValue начиная с позиции fromIndex (аргументы, указанные в квадратных скобках не являются обязательными).
						<pre>
var myString = 'Это просто проверочная строка!';

console.log(myString.indexOf('про'));
//ищет индекс начала 'про', начиная с начала строки
// 4 (это ПРОсто проверочная строка!)

console.log(myString.indexOf('про', 0));
//ищет индекс начала 'про', начиная с начала строки
// 4 (это ПРОсто проверочная строка!)

console.log(myString.indexOf('про', 5));
//ищет индекс начала 'про', начиная с пятого индекса
// 11 (это просто ПРОверочная строка!)

console.log(myString.indexOf('про', 12));
//ищет индекс начала 'про', начиная с двенадцатого индекса
// -1 (-1 когда не ношли подстроку по условиям)</pre>
					</li>
					<li>
						<strong>lastIndexOf(searchValue[, fromIndex]) - </strong>ищет последнюю подстроку  searchValue начиная с позиции fromIndex (внимание! поиск фактически будет в "обратную" сторону - т.е. первое вхождение от индекса fromIndex или конца строки в сторону начала строки)
						<pre>
var myString = 'Это просто проверочная строка!';

console.log(myString.lastIndexOf('про'));
// начало последнего про поиск с конца
// 11

console.log(myString.lastIndexOf('про', 10));
// начало последнего про поиск с конца, начиная с 10 символа
// 4</pre>
					</li>
					<li>
						<strong>
							search(regExp) - 
						</strong>возвращает индекс первого сопоставления с регулярным выражением внутри строки. В противном случае метод вернёт -1.
						<br>Рассмотрим позже
					</li>
					<li>
						<strong>
							match(regExp) - 
						</strong> выдает массив всех совпадений с аргументом
						<br>Рассмотрим позже
					</li>
					<li>
						<strong>Преобразоание типов</strong>
						<br><strong>-fromCharCode(num1, num2,...,numN) </strong>
						<br><strong>-toString() </strong>
						<br><strong>-valueOf() </strong>
					</li>
					<li>
						<strong>fromCharCode(num1, num2,...,numN)</strong> - преобразование значение(цифры) - Юникода в Символ
						<pre>
myString = String.fromCharCode(65, 66, 67);
console.log(myString);
// ABC</pre>
					</li>
					<li>
						<strong>toString()</strong> - преобразование обычной строки в строковый объект
						<br>
						<strong>valueOf()</strong> - возвращает элементарную строку вместо объекта String, эквивалентно toString()
						<pre>
myString = new String('Привет');
console.log(typeof(myString));  // object
console.log(typeof(myString.toString())); // string

console.log(typeof(myString));  // object
console.log(typeof(myString.valueOf())); // string</pre>
					</li>
					<li>
						Задание: найти индекс вхождения второй строки в первую (если втророй строки в первой нет, тогда -1)
						<pre>
function testStr(a,b) {
    return a.indexOf(b);
}

alert (testStr('This is a test string', 'test'));
// 10</pre>
					</li>
				</ul>
			</li>


			<li>
				<span class="spec">
					Массивы<hr>
				</span>
				<ul>
					<li>
						Массив представляет из себя набор значений, доступ к которым осуществляется по их порядковому номеру. 
						<br>Значение в массиве называют "элементом массива" и обращаются к ним по их порядковому номеру, называемому "индексом".
						<br><br>В JS массивы нетипизированные (т.е в одном массиве могут находиться элементы разных типов) - строки, числа, символы, объекты, массивы, массивы с массивами.
						<br><br>Начало отсчёта индексов - с нуля. (для индексов 32битные значения)
						<br><br>Массивы в JS - динамические - т.е могут увеличиваться или уменьшаться.
						<br><br><strong>Массив - это объект</strong>
					</li>
					<li>
						<strong>Создание массива (3 способа):</strong>
						<br>- Первый способ - <strong>var x = new Array;</strong>
						<pre>
var myArray = new Array();  // объявление массива

myArray[0] = 'Иванов';  // добавление элемента
myArray[1] = 'Петров';  // добавление элемента
myArray[2] = 'Сидоров';  // добавление элемента
myArray[3] = 'Кузнецов';  // добавление элемента

console.log (myArray);
// (4) ['Иванов', 'Петров', 'Сидоров', 'Кузнецов']</pre>
						Вызов(создание) конструктора с определённым количеством элементов. НЕ РЕКОМЕНДУЕТСЯ!
						<pre>
var myArray = new Array(10);
// вызываем конструктор из 10 элементов

console.log (myArray);
// (10) [empty × 10]</pre>
						<br>
						- Второй способ, для создания массива. <strong>(сокращённый)</strong>
						<pre>
var myArray = new Array('Иванов', 'Петров', 'Сидоров', 'Кузнецов');

console.log(myArray);
// (4) ['Иванов', 'Петров', 'Сидоров', 'Кузнецов']</pre>
						<br>
						- Третий способ для создания массива. <strong>(литеральный)</strong>
						<pre>
var myArray = ['Иванов', 'Петров', 'Сидоров', 'Кузнецов'];

console.log(myArray);
// (4) ['Иванов', 'Петров', 'Сидоров', 'Кузнецов']</pre>
					</li>
					<li>
						<strong>Запись в массив</strong>
						<pre>
var myArray = ['Иванов', 'Петров', 'Сидоров', 'Кузнецов'];

console.log(myArray);
// (4) ['Иванов', 'Петров', 'Сидоров', 'Кузнецов']

myArray[0] = 'ААА';  // Запись или перезапись если массив не пустой

console.log(myArray);
// (4) ['ААА', 'Петров', 'Сидоров', 'Кузнецов']

myArray[4] = 'БББ';

console.log(myArray); // Запись в массив
// (5) ['ААА', 'Петров', 'Сидоров', 'Кузнецов', 'БББ']</pre>
					</li>
					<li>
						<strong>Чтение массива, чтение элемента массива</strong>
						<pre>
var myArray = ['Иванов', 'Петров', 'Сидоров', 'Кузнецов'];

console.log(myArray);  // чтение всего массива
console.log(typeof(myArray)) // object

first_el = myArray[0]; // чтетние первого элемента: (запись элемента в переменную);
console.log(first_el); // Иванов
console.log(typeof(first_el)); // string

console.log(myArray[0]); // Иванов
console.log(typeof(myArray[0])); // string</pre>
					</li>
					<li>
						<strong>Добавление элементов, в массив - метод push()</strong>
						<pre>
var myArray = ['Иванов', 'Петров', 'Сидоров', 'Кузнецов'];

myArray.push('AAA');  // добавление в конец массива
console.log(myArray)
// (5) ['Иванов', 'Петров', 'Сидоров', 'Кузнецов', 'AAA']

myArray.push('BBB', 777);  // добавление нескольких элементов в конец массива
console.log(myArray);
// (7) ['Иванов', 'Петров', 'Сидоров', 'Кузнецов', 'AAA', 'BBB', 777]</pre>
					</li>
					<li>
						Можно в ручную длину массива, добаив пустые элементы
						<pre>
// (7) ['Иванов', 'Петров', 'Сидоров', 'Кузнецов', 'AAA', 'BBB', 777]

myArray.length = 10;
console.log(myArray);
// (10) ['Иванов', 'Петров', 'Сидоров', 'Кузнецов', 'AAA', 'BBB', 777, empty × 3]</pre>
					</li>
					<li>
						<strong>Добавление элементов в начало массива - ar.unshift('el1', 'el2')</strong>
						<pre>
var myArray = ['Иванов', 'Петров', 'Сидоров', 'Кузнецов'];

myArray.unshift('Сергеев', 'Дмитриев');  // Добавление в начало массива

console.log(myArray);
// (6) ['Сергеев', 'Дмитриев', 'Иванов', 'Петров', 'Сидоров', 'Кузнецов']</pre>
					</li>
					<li>
						<strong>Объединение масиивов</strong>
						<pre>
var a = [0, 1, 5, 3];  // массив 1
var b = [3]; // массив 2
var c = a.concat(b);  // массив 3 = массив 1 + массив 2

console.log(c);
// (5) [0, 1, 5, 3, 3]</pre>
					</li>
					<li>
						Задание, на входе 2 массива с числами, необходимо сложить сумму всех значений элементов массивов
						<pre>
function testArray(a, b) {
    var total = 0;  // создали переменную результата
    var c = a.concat(b);  // складываем 2 массива
    for (element in c) {  // перебираем все элементы массива
        total = total + c[element];  // на каждой итерации прибавляем значение элемента в переменную        
    }
    return total  // возвращаем результат
}

console.log(testArray([0, 1, 5, 3], [3]));
// 12</pre>
					</li>
					<li>
						<strong>
							Удаление элемента массива
							<br>delete --> undefinded(empty)
						</strong>
						<pre>
var myArray = ['A', 'B', 'C', 'D'];

delete myArray[2]; // изменили 3-й элемент на undefined!

console.log(myArray);
// (4) ['A', 'B', empty, 'D']</pre>
					</li>
					<li>
						<strong>Удаление элемента из массива с помощью изменения длины массива - length</strong>
						<pre>
var myArray = ['A', 'B', 'C', 'D'];

myArray.length = 3;  // устанавливаем длину массива на 3 (было 4)

console.log(myArray);
// (3) ['A', 'B', 'C']</pre>
					</li>
					<li>
						<strong>
							Удаление последнего элемента массива - pop()
						</strong>
						<pre>
var myArray = ['A', 'B', 'C', 'D'];

var el = myArray.pop();  // удаляем элемент в конце массива и записываем его в переменную

console.log(el);  // D
console.log(myArray); // (3) ['A', 'B', 'C']

myArray.pop();  // удаляем элемент в конце массива
console.log(myArray); // (2) ['A', 'B']</pre>
					</li>
					<li>
						<strong>Удаление элемента в начале массива - shift()</strong>
						<pre>
var myArray = ['A', 'B', 'C', 'D'];

myArray.shift();  // удаляем элемент в начале массива

console.log(myArray);
// (3) ['B', 'C', 'D']</pre>
					</li>
					<li>
						<strong>
							Array.join() - 
						</strong>
						превращает все элементы массива в строки, объединяет их и возвращает получившуюся строку.
						<br><strong>По умолчанию разделитель - ','</strong>
						<pre>
var myArray = ['A', 'B', 'C', 'D'];

myString = myArray.join();

console.log(myArray);
// (4) ['A', 'B', 'C', 'D']
console.log(myString);
// A,B,C,D/pre>
					</li>
					<li>
						<strong>Из массива в строку, через определённый разделитель - Array.join('разделитель')</strong>
						<pre>
var myArray = ['A', 'B', 'C', 'D'];
myString = myArray.join('__'); 
console.log(myString);
// A__B__C__D</pre>
					</li>
					<li>
						<strong>Array.reverse() - реверс массива</strong> - меняет порядок следования элементов в массиве на обратный и возвращает уже переупорядоченный массив.
						<pre>
var myArray = ['A', 'B', 'C', 'D'];
myArray.reverse();  // реверс массива

console.log(myArray);
// (4) ['D', 'C', 'B', 'A']</pre>
					</li>
					<li>
						<strong>Сортировка массива - Array.sort()</strong>
						<br>- Если сортировать без аргумента, отсортирует по алфавиту (unicode)
						<pre>
var myArray = ['1', 100, 1, 'abc', 'абв'];
myArray.sort();

console.log(myArray);
// (5) ['1', 1, 100, 'abc', 'абв']</pre>
					</li>
					<li>
						<strong>Сортировка в обратном порядке только через свою функцию сравнения?!! JS?!</strong>
					</li>
					<li>
						<strong> localeCompare()</strong> - сравнивает объект типа String или строковые литералы
					</li>
					<li>
						<strong>Конакатенация массивов - Array.concat()</strong>
						<br>- можно конактенировать массив со строкой, числом
						<br>- можно конатенировать массив с массивом
						<br>- <strong>Array.concat()</strong> - не изменяет исходный массив, возвращает новый массив с добавлением эоементов, т.е нужно создавать новую переменную(новый массив) - если данные необходимо сохроанить а не просто вывести!
						<pre>
var oneArray = new Array('A', 'B', 'C');
console.log(oneArray);  // (3) ['A', 'B', 'C']

var twoArray = oneArray.concat(1);  // конкатенация с числом
console.log(oneArray); // не изменился (3) ['A', 'B', 'C']
console.log(twoArray); // (4) ['A', 'B', 'C', 1]

twoArray.concat('fff', 'ggg'); //пытаемся добавить в массив
console.log(twoArray); // Не изсенился! (4) ['A', 'B', 'C', 1]


// ко второму массиву прибавин мовый массив, обязательно записав его в третий массив
var threArray = twoArray.concat(['10', 9, 8, 'abc', '777']);
console.log(threArray);
// (9) ['A', 'B', 'C', 1, '10', 9, 8, 'abc', '777']</pre>
					</li>
					<li>
						<strong>Array.slice()</strong> - возвращение части массива (от и до)
						<pre>
var myArray = [1, 2, 3, 4 , 5];
console.log(myArray.slice(1,3));  // от второго элемента до третего
                                  // индексы от 1 до 2 включительно
//(3) [2, 3]</pre>
					</li>
					<li>
						<strong>Array.splice() - удаление элементов и вставка новых</strong>
						<br> - первй аргумент - откуда начинатется действие
						<br> - второй аргумент(необязательный) - количество удаляемых элементов. (Еслм аргумент не указан, удалит всё после элемента укаханного в первом аргументе)
						<br> - 3 аргумент и последующие (любое количество) - элементы массива, которые будут добавлены начиная с позиции, указанной в первом аргументе.
						<pre>
var myArray = ['Первый', 'Второй', 'Третий', 'Четвёрный', 'Пятый'];
myArray.splice(2, 2);  // начиная с третиего элемента удалить 2 элемента
console.log(myArray);
// (3) ['Первый', 'Второй', 'Пятый']

var myArray = ['Первый', 'Второй', 'Третий', 'Четвёрный', 'Пятый'];
myArray.splice(1); // начиная спервого удалить всё что дальше
console.log(myArray);
//(1) ['Первый']

var myArray = ['Первый', 'Второй', 'Третий', 'Четвёрный', 'Пятый'];
myArray.splice(2, 0, 'БЛАБЛА'); // после второго элемента(после инд 1), вставить 'БЛAБЛА'
console.log(myArray);
// (6) ['Первый', 'Второй', 'БЛАБЛА', 'Третий', 'Четвёрный', 'Пятый']

var myArray = ['Первый', 'Второй', 'Третий', 'Четвёрный', 'Пятый'];
myArray.splice(2, 2, 3, 4); // после индекса 2, включая его, удалить 2 элемента и вместо них вставить 2 элемента(числа) = 3, 4
console.log(myArray);
// (5) ['Первый', 'Второй', 3, 4, 'Пятый']</pre>
					</li>
					<li>
						<strong>Задание шаг 10, 2.4</strong>
						<br>- создание функции
						<br>- преобразовние строки в массив (поэлементно)
						<br>- реверс массива
						<br>- конкатенация массива с массивом
						<br>- конкатенация массива со строкой
						<br>- разбитие массива в строку (слитно)
						<br>
						<br><strong>Без функции для наглядности</strong>
						<pre>
a = '4326' // строка 1
b = '297515' // строка 2

aArray = a.split(''); // разбиваем строку на элементы (1 символ = 1 элемент массива)
                      // если не указать ('') - то разделить только если есть пробел
console.log(aArray); // ['4', '3', '2', '6']
aArray.reverse();  // разворачиваем элементы в первом массиве
console.log(aArray); // ['6', '2', '3', '4']

bArray = b.split(''); // разбиваем строку b - на отдельные элементы в массиве
console.log(bArray); // ['2', '9', '7', '5', '1', '5']
bArray.reverse(); // разворачиваем элементы в массиве 2
console.log(bArray); // ['5', '1', '5', '7', '9', '2']

//сонкатенируем развёрнутые массивы b массив + с массив. + в цонец добавляю строку 'Иванов'
myArray = bArray.concat(aArray, 'Иванов');
console.log(myArray); // ['5', '1', '5', '7', '9', '2', '6', '2', '3', '4', 'Иванов']


// преобразование из массива в строку
//('') - чтобы строка была слитной без запятых
myString = myArray.join('');
console.log(myString);
// 5157926234Иванов</pre>
						<br><strong>В функции, как по заданию</strong>
						<pre>
function testArray(a, b) {
    aArray = a.split(''); // разбитие первой строки в массив по эелементам
    aArray.reverse(); // разворот первого массива
    bArray = b.split('');
    bArray.reverse();
    myArray = bArray.concat(aArray, 'Иванов'); // получение общего массива по условию
    myString = myArray.join(''); // из массива в строку (слитно)
    return myString // возвращение строки по условию
}

console.log(testArray('4326', '297515'));
// 5157926234Иванов</pre>
						<br>То же самое в одну строку
						<pre>
function testArray(a, b) {
    return (a + b).split("").reverse().join("") + "Иванов";
}</pre>
					</li>
				</ul>
			</li>



			<li>
				<span class="spec">
					Дата и время<hr>
				</span>
				<ul>
					<li>
						Для работы с датой и временем в JS - объект Date
					</li>
					<li>
						<strong>Создание обхекта при помощи конструктора Date()</strong>
						<br>
						Вариант 1  - создаёт объект по текущей даде и времени
						<pre>
var myDate = new Date();
console.log(myDate);
// Thu Jan 12 2023 10:43:28 GMT+0300 (Волгоград, стандартное время)</pre>
						<br>Вариант 2 - создаёт объект по запросу (самми вводим дату и время)
						<pre>
var myDate = new Date("December 14, 1975 12:10:00");
console.log(myDate);
// Sun Dec 14 1975 12:10:00 GMT+0400 (Волгоград, стандартное время)</pre>
						<br>Вариант 3 - создаёт обхект по запросу (сами вводим дату)
						<pre>
var myDate = new Date(1989, 6, 14);
console.log(myDate);
// Fri Jul 14 1989 00:00:00 GMT+0400 (Волгоград, летнее время)</pre>
						<br>
						Вариант 4 - создаёт объект по запросу (сами вводим дату и время)
						<pre>
var myDate = new Date(1992, 5, 12, 11, 20, 0);
console.log(myDate);
// ОБРАТИ ВНИМАНИЕ 0 - ЭТО ЯНВАРЬ, 5 - ЭТО ИЮНЬ
// Fri Jun 12 1992 11:20:00 GMT+0400 (Волгоград, летнее время)</pre>
						<br>
						<strong>Вывод на страницу всех вариантов - document.write(myDate + '&lt;br/>fd'):</strong>
						<pre>
document.write(myDate + <span class="text-danger">'&lt;br/></span>');
<span class="text-danger">новая строка</span></pre>
					</li>
					<li>
						<strong>Шпаргалка по созданию обхекта Date</strong>
						<pre>
var x = new Date() //В объект попадут текущие дата и время
var x = new Date(миллисекунды) //Количество миллисекунд отсчитывая с 1 января 1970г
var x = new Date(строкаДаты)
var x = new Date(год, месяц, день[, часы, минуты, секунды, миллисекунды])


где - параметры, указанные в квадратных скобках являются необязательными.

год - формат YYYY
месяц - от 0 до 11
день - от 1 до 31
часы - от 0 до 23
минуты - от 0 до 59
секунды - от 0 до 59
миллисекунды - от 0 до 999</pre>
					</li>
					<li>
						Создаём обхект Date, присваиваем свое значение, прибавляем 10 дней (месяц, год прибавятся автоматически если необходимо)
						<br><strong>myDate.setFullYear</strong> - присваивание своей даты (своей)
						<br><strong>myDate.setDate</strong> - установка значения своего значения даты
						<br><strong>myDate.getDate()</strong> - получение текущего значение даты
						<br>myDate - это переменная, объект Date()
						<pre>
var myDate = new Date(); // создаём объект Date() - текущее время и дата
myDate.setFullYear(2017, 4, 22); // Присваеваем объекту значение - 22 мая 2017
myDate.setDate(myDate.getDate() + 10); // Получаем значение и прибавляем 10 дней
console.log(myDate);
// Fri Jun 02 2017 11:14:14 GMT+0300 (Волгоград, стандартное время)</pre>
					</li>
					<li>
						<strong>Сравнение двух дат</strong>
						<pre>
var currentDate = new Date(); // создали объект1 (текущая дата)
var nextNewYear = new Date(); // создали объект2 (текущая дата)
nextNewYear.setFullYear(2018, 0, 1); // измениели объект 2 на нг 2018

if (+currentDate == +nextNewYear) { // сравниваем 2 даты
    alert('Сегодня новый 2018 год!'); // выведет если сегодня 1 янв 2018
} else {
    alert('Сегодня не новый 2018 год(('); // выведет в любом другом случае
}</pre>
					</li>
					<li>
						<strong>Основные методы (получения значения) объекта Date():</strong><hr>
						<strong>getDay()</strong> -  возвращает день недели от 0 до 6, 0 - воскресенье, 1 - понедельник и т.д.
						<br><strong>getTimezoneOffset()</strong> - возвращает смещение часового пояса  относительно UTC, в минутах с противоположным знаком.
						<br><strong>getYear()</strong> - возвращает значение года минус 1900, к использованию не очень рекомендуется.
						<br><strong>getFullYear()</strong> - возвращает значение года.
						<br><strong>getMonth()</strong> - возвращает месяц, от 0 до 11 
						<br><strong>getDate()</strong> - возвращает число месяца от 1 до 31
						<br><strong>getHours()</strong> -  возвращает час, от 0 до 23
						<br><strong>getMinutes()</strong> - возвращает количество минут, от 0 до 59
						<br><strong>getSeconds()</strong> - возвращает количество секунд, от 0 до 59
						<br><strong>getMilliseconds()</strong> - возвращает количество миллисекунд, от 0 до 999
						<br><strong>getTime()</strong> - возвращает количество миллисекунд, прошедших с полуночи 1 января 1970г GMT.
						<hr>
					</li>
					<li>
						<strong>Запись данных в объект Date():</strong><hr>
						<strong>setYear()</strong> -  устанавливает значение года минус 1900, к использованию не очень рекомендуется.
						<br><strong>setFullYear()</strong> -  устанавливает значение года.
						<br><strong>setMonth()</strong> -  устанавливает месяц, от 0 до 11
						<br><strong>setDate()</strong> - устанавливает день месяца, от 1 до 31
						<br><strong>setHours()</strong> - устанавливает час, от 0 до 23
						<br><strong>setMinutes()</strong> - устанавливает количество минут, от 0 до 59
						<br><strong>setSeconds()</strong> - устанавливает количество секунд, от 0 до 59
						<br><strong>setMilliseconds()</strong> -  устанавливает количество миллисекунд, от 0 до 999
						<br><strong>setTime()</strong> - устанавливает количество миллисекунд, прошедших с полуночи 1 января 1970г GMT.
						<hr>
					</li>
					<li>
						<strong>Преобразование данных объекта Date()</strong>
						<br>
						<strong>Date.parse()</strong> - Преобразование дата в милисекунды.
						<br>Если строку не получилось преобразовать - например это строка не дата, вернёт NaN.
						<pre>
var myDate = new Date();
document.write(myDate.setTime(Date.parse("22 May 2017 11:11")));
// 1495440660000

document.write('&lt;/br>'); // Новая строка

document.write(myDate);
// Mon May 22 2017 11:11:00 GMT+0300 (Волгоград, стандартное время)</pre>
						<br><strong>toLocaleString()</strong> - возвращает дату в формате, в соответствии с региональными натройками операционной системы.
						<pre>
var myDate = new Date();  // текущая дата и время
document.write(myDate.toLocaleString());  // вывод в документе
console.log(myDate.toLocaleString());  // вывод в консоле
// 12.01.2023, 11:55:30</pre>
						<br><strong>toLocaleTimeString()</strong> - преобразовывает данные о времени в строку, используя настройки форматирования операционной системы, в которой выполняется скрипт.
						<br><strong>toLocaleDateString()</strong> - выполняет преобразование, аналогичное предыдущему, но с датой.
						<br><br>Примеры по последним трём методам преобразования - (по локальным настройкам ОС)
						<pre>
var myDate = new Date();  // создали объект - текущая дата и время
// дата + время
console.log(myDate.toLocaleString());
// 12.01.2023, 11:59:44

// время
console.log(myDate.toLocaleTimeString());
// 11:59:44

// дата
console.log(myDate.toLocaleDateString());
// 12.01.2023</pre>
					</li>
					<li>
						Задание: 
						<br>создать функцию, которая получит 2 строки вида "03 November 2017 04:17"
						<br>Строки нужно превратить в дату;
						<br>Даты нужно сравнить;
						<br>Для даты которая больше необходимо вернуть день ндели в виде строки на руссом языке - 'Понедельник'
						<br><br>Задание без функции - подробно для понимания
						<pre>
// строки
var a = "19 October 1909 10:27";
var b = "28 March 1909 00:59";

// преобразование строк в дату и время
var aDate = new Date(a);
var bDate = new Date(b);
console.log(aDate);
console.log(bDate);

// создание переменной для большей даты
var bigDate = aDate;


// сравнение даты и времени
if (+aDate > +bDate) {  // если первая дата больше второй
    var bigDate = aDate;  // в переменную большая дата присваиваем значение первой даты
} else if (+aDate < +bDate) { // если первая дата меньше второй
    var bigDate = bDate; 
} else { // иначе - если даты равны
    var bigDate = aDate; // чтобы не было ошибок
};


// получение числа дня недели от 0 до 6 (большей даты)
var numDay = bigDate.getDay();


// Вывод строки по руссики - в зависимости от числа
switch(numDay) {
    case 0:  // если число 0
        var ruStringDay = 'Воскресенье'; // строка = Восересенье
        break;
    case 1:  
        var ruStringDay = 'Понедельник';
        break;
    case 2:  
        var ruStringDay = 'Вторник';
        break;
    case 3:  
        var ruStringDay = 'Среда';
        break;
    case 4:  
        var ruStringDay = 'Четверг';
        break;
    case 5:  
        var ruStringDay = 'Пятница';
        break;
    case 6:  
        var ruStringDay = 'Суббота';
        break;
}

// Вывод строки длня недели большей даты на русском
alert(ruStringDay);
//Вторник</pre>
						<br>Задание (в функции);
						<pre>
// создаём функцию, которая принимает 2 строки
function testDataTime(a, b) {
    // преобразование строк в дату и время
    var aDate = new Date(a);
    var bDate = new Date(b);

    // создание переменной для большей даты
    var bigDate = new Date();

    // сравнение двух дат и запись большей в переменную
    if (+aDate > +bDate) {
        bigDate = aDate;
    } else if (+aDate < +bDate) {
        bigDate = bDate;
    } else {
        bigDate = aDate;
    }

    // получение числа дня недели от 0 до 6 (большей даты)
    var numDay = bigDate.getDay();

    // Вывод строки по руссики - в зависимости от числа
    switch(numDay) {
        case 0:  // если число 0
            var ruStringDay = 'Воскресенье'; // строка = Восересенье
            break;
        case 1:  
            var ruStringDay = 'Понедельник';
            break;
        case 2:  
            var ruStringDay = 'Вторник';
            break;
        case 3:  
            var ruStringDay = 'Среда';
            break;
        case 4:  
            var ruStringDay = 'Четверг';
            break;
        case 5:  
            var ruStringDay = 'Пятница';
            break;
        case 6:  
            var ruStringDay = 'Суббота';
            break;
    }

    // возвращаем результат по условию
    return ruStringDay;
}


// выводим результат во всплывающее окно
// строки
var a = "19 October 1909 10:27";
var b = "28 March 1909 00:59";

alert(testDataTime(a,b));
// Вторник</pre>
						<br>Простое, но более короткое решение
						<pre>
function testDateTime(a, b) {
    a = new Date(a);
    b = new Date(b);
    var days = ['Воскресенье', 'Понедельник', 'Вторник', 'Среда', 'Четверг', 'Пятница', 'Суббота'];
    if (a > b) {
    	return days[a.getDay()];
    } else {
    	return days[b.getDay()];
    }
}</pre>
					</li>
				</ul>
			</li>

&lt;

			<li>
				<span class="spec">
					Математические функции<hr>
				</span>
				<ul>
					<li>
						- Математические операции в JS - представленны стандартным объектом Math.
						<br>- У Math - есть методы (квадратный корень, синус, возведение в степень)
						<br>- Свойства Math - константы (Пи, E, логарифм 10)
						<br>- <strong>Math - не является конструктором</strong> - т.е к нему можно обращаться напрямую, не создавая экземпляра объекта.
						<pre>
console.log(Math.PI);
// 3.141592653589793 (число Пи)

console.log(Math.sqrt(25));
// 5 (Квадратный корень 25)</pre>
					</li>
					<li>
						<strong>Константы (свойства) объекта Math</strong>
						<hr>
						<strong>Math.E</strong> - число е, основание натурального логарифма, константа Эйлера (Непера), приблизительно 2.718...
						<br><strong>Math.PI</strong> - число Пи, приблизительно равно, как известно, 3.1415926...
						<br><strong>Math.SQRT2</strong> - квадратный корень из 2, приблизительное значение 1.414
						<br><strong>Math.SQRT1_2</strong> - квадратный корень из 1/2, приблизительное значение 0.707
						<br><strong>Math.LN2</strong> - натуральный логарифм 2, приблизительное значение 0.693
						<br><strong>Math.LN10 </strong> - натуральный логарифм 10, приблизительное значение 2.302
						<br><strong>Math.LOG2E</strong> - логарифм Е по основанию 2, приблизительное значение 1.442
						<br><strong>Math.LOG10E</strong> - логарифм Е по основанию 10, приблизительное значение 0.434
						<hr>
					</li>
					<li>
						Пример функции, получения длины окрызности окружности (в зависимости от радиуса)
						<pre>
function circumference(radius) {
    return radius * Math.PI * 2;
}

console.log(circumference(20.32));
// 127.6743254418892</pre>
					</li>
					<li>
						<strong>Методы объекта Math</strong>
						<hr>
						<strong>Math.sin (x)</strong> - возвращает значение синуса аргумента (в радианах), от -1 до 1 естественно.
						<br><strong>Math.cos (x)</strong> - возвращает значение косинуса аргумента (в радианах), от -1 до 1.  
						<br><strong>Math.tan (x)</strong> - возвращает численное значение для тангенса угла в радианах.
						<br><strong>Math.asin (x)</strong> - возвращает значение (в радианах) арксинуса для аргумента, который задается от -1 до 1
						<br><strong>Math.acos (x)</strong> - возвращает значение (в радианах) арккосинуса для аргумента, который задается от -1 до 1
						<br><strong>Math.atan (x)</strong> -  возвращает значение арктангенса (из промежутка от -pi/2 до pi/2) для аргумента 
						<br><strong>Math.atan2 (y, x)</strong> - функция называется арктангенс двух переменных. Она возвращает числовое значение между -π и π, и представляет собой угол между положительным лучом оси Х и точкой x,y.
						<hr>
					</li>
					<li>
						<strong>Тригонометрические функции в JavaScript принимают аргументы только в радианах!</strong>
					</li>
					<li>
						Задание: получаем угол в градусах - необходимо перевести в радианы, и получить синус угла
						<pre>
function testMath(a) {
    var rad = a * Math.PI / 180;
    return Math.sin(rad)
}

console.log(testMath(348));
// -0.20791169081775987</pre>
					</li>
					<li>
						Задание: на вход получаем 2 стороны треугольника + угол между ними, нужно вычислить площадь треугольника
						<pre>
function testMath(a, b, c) {
    var cRad = c * Math.PI / 180;
    var S = 1/2 * a * b * Math.sin(cRad);
    return S
}

console.log(testMath(2, 10, 16));
// 2.7563735581699915</pre>
					</li>
					<li>
						<strong>Функции преобразования и сравнения - Math</strong>
						<hr>
						<strong>Math.min ([Значение1[,значение2[, ...]]])</strong> -  возвращает минимальное значение из аргументов.
						<br><strong>Math.max ([Значение1[,значение2[, ...]]])</strong> - возвращает максимальное значение из аргументов.
						<br><strong>Math.floor (x)</strong> - округление до ближайшего целого в меньшую сторону
						<br><strong>Math.ceil (x)</strong> - округление до ближайшего целого в большую сторону
						<br><strong>Math.abs(x)</strong> - возвращает абсолютное значение числа, его еще называют "модуль"
						<br><strong>Math.round(x)</strong> - округляет число по правилам математики
						<br>
						<br>Обратите внимание! Запись аргументов в квадратных скобках означает, что аргументы - необязательные. Это означает, что запись Math.min([Значение1[,значение2[, ...]]]). Может использоваться как Math.min() или Math.min(Значение1), или Math.min(Значение1, значение2) и т.п.
						<hr>
					</li>
					<li>
						Задание: На входе 4 числа, на выходе результат деления большего на меньшее, округлив результат до ближайшего целого числа в меньшую сторону
						<pre>
function testMath (a, b, c, d) {
    var minNum = Math.min(a, b, c, d);
    var maxNum = Math.max(a, b, c, d);
    var result = Math.floor(maxNum/minNum);
    return result
}

console.log(testMath(1, 4, 8, 8));
// 8 = 8/1 - + округление если нужно</pre>
						В одну строку тоже самое
						<pre>
function testMath(a, b, c, d) {
    return Math.floor(Math.max(...arguments)/Math.min(...arguments));
}</pre>
					</li>
					<li>
						<strong>Функции фычисления Math</strong>
						<hr>
						<strong>Math.sqrt(x)</strong> - возвращает квадратный корень из аргумента
						<br><strong>Math.pow(base, exponent</strong> - возводит число "base" в степень "exponent"
						<br><strong>Math.log(x)</strong> - вычисляет натуральный (по основанию е) логарифм числа
						<br><strong>Math.exp(x)</strong> - вычисляет экспоненту - значение числа е в степени аргумента "х"
						<br><strong>Math.random()</strong> - возвращает случайное число от 0 (включительно) до 1
						<hr>
					</li>
					<li>
						Задание: Принимаем 2 числа, на выходе возведение первого числа в степень второго числа
						<pre>
function testMath(a, b) {
    return a ** b;
}

console.log(testMath(3, 2));
// 9 = 3 ** 2</pre>
					</li>
				</ul>
			</li>

												

		</ol> <!-- 2. Стандартные объекты -->


&lt;


		<hr>
		<h1 class="title_text">
			3. Продвинутые операции
		</h1>
		<hr>

		<ol> <!-- 3. Продвинутые операции -->

			<li>
				<span class="spec">
					Обработка ошибок<hr>
				</span>
				<ul>
					<li>
						<strong>Исключение</strong> - это некоторое событие, сигнализирующее о возникновении нештатной ситуации или ошибки.
						<br>
						<strong>Возбудить, (создать, бросить) исключение</strong> - просигнализировать о такой ошибке или исключительной ситуации.
						<br>
						<strong>Перехватить исключение</strong> - значит предпринять действия по обработке исключения и восстановления нормальной работоспособности кода.
						<br>
						<br>
						Возбуждение исключения производится оператором <strong>"throw"</strong>, перехват - командой <strong>"catch"</strong> (точнее связкой операторов <strong>"try-catch-finally"</strong>).
					</li>
					<li>
						<strong>throw</strong>
						<pre>
throw выражение;

выражение или результат его вычисления. Например число = код ошибки, текст = текст ошибки</pre>
						Пример
						<pre>
function testFactorial(inputData) {
    if (inputData == 0) {return 1}
    if (inputData < 0 ) // проверяем положительное ли число
        throw 'Число не должно быть меньше нуля'; // если отричательное - 'бросаем исключение'

    return (inputData - 1)?(inputData * testFactorial(inputData - 1)):inputData;
}


console.log(testFactorial(7));
// 5040
console.log(testFactorial(0));
// 1 (факториал 0 = 1)
console.log(testFactorial(-456));
// Uncaught Число не должно быть меньше нуля (Это исключение)
console.log(testFactorial(7));
<span class="text-danger">// ничего не произойдёт, так как после создания исключения обычное выполнение программы прерывается - и нужна конструкция try/cath/ginaly</span></pre>
					</li>
					<li>
						Как только исключение создано, интерпретатор JavaScript прерывает нормальное выполнение кода и начинает поиск обработчика исключений - конструкции <strong>try/catch/finally</strong>.
						<pre>
try {
  // код, который нужно "попробовать"
  // в этом коде может быть брошено исключение
} catch(exception_variable) {
  // в этом месте пишется код, который выполняется только в случае обнаружения 
  // исключения в предыдущем блоке "trу" 
  // в случае возникновения исключения, в переменную exception_variable будет передан 
  // код возникшей ошибки, например аргумент оператора throw
} finally {
  // Код в этом блоке будет выполнен всегда, независимо от результата завершения блока try:
  // и при завершении без ошибки, и при завершении с ошибкой, и при завершении по любому оператору перехода
  // (break, continue, return)
}</pre>
						Блоки catch и finally не являются строго обязательными, однако хотя бы один из них должен присутствовать в конструкции.
					</li>
					<li>
						<strong>throw</strong> - создание исключения.
						<br>
						<strong>try/catch/finally</strong> - обработка исключения.
					</li>
					<li>
						Полный пример с факториалом, создание и обработка исключения
						<pre>
// создание функции
function testFactorial(inputData) {
    if (inputData == 0) {return 1}
    if (inputData < 0 ) // проверяем положительное ли число
        throw 'Число не должно быть меньше нуля'; // если отричательное - 'бросаем исключение'

    return (inputData - 1)?(inputData * testFactorial(inputData - 1)):inputData;
}

// инициируем переменную для входного параметра, зададим ее вручную в этом примере
var myNumber = -5;

// начало конструкции обработки ошибок
try {
    document.write(testFactorial(myNumber)); // попытка вызова функции
} catch(ex) {
    document.write(ex); // если в функции произойдёт исключение,
    // то будет выведен текст - который мы указывали в throw внутри функции
}
// если всё ок на строницу выведет значение факториала
// если число меньше 0 выведет  - 'Число не должно быть меньше нуля'</pre>
					</li>
					<li>
						 Конструкции try/catch/finally могут быть многократно вложенными. В такой ситуации нам зачастую необходимо проверить - а что за исключение возникло, и если это не то исключение, которое мы ждали и готовы обработать, "не наше", то нужно его отправить дальше. Вариант "не перехватывать" мы реализовать не можем, однако можно перехватить, проверить и если это не то, что нужно - сгенерировать заново, как бы послать дальше.
						 <br>Предыдущий пример с дополнительной проверкой самого исключения
						 <pre>
// Объявление функции
function testFactorial(inputData) {
  if (inputData < 0)                             // Проверяем - положительное ли число
    throw "Число не должно быть меньше нуля";        // Если отрицательное - "бросаем" исключение
  return (inputData - 1) ? (inputData * testFactorial(inputData - 1)) : inputData;
}

// инициируем переменную для входного параметра, зададим ее вручную в этом примере
var myNumber = -5;  

// начало конструкции обработки ошибок
try {
  document.write(testFactorial(myNumber));      //  попытка вызова функции
} catch(ex) {
  if (ex != "Число не должно быть меньше нуля")     // Проверяем - если исключение не наше
    throw (ex);                                 // то "бросаем" его дальше, как бы пропускаем.
  document.write(ex);                           // вывод строки ошибки если исключение "наше"</pre>
  					В этом примере мы перед тем как вывести ошибку на экран, проверяем - та ли это ошибка, которая была сгенерирована оператором throw в нашей функции. Если нет, то генерируем ее заново - как бы отправляем гулять дальше, в поисках своего catch.
					</li>
					<li>
						<strong>Error - объект</strong>, который используется при возбуждении исключений.
						Командой throw может быть выброшен любой объект, однако стандартно при возникновении ошибок выбрасывается объект класса Error или его подклассы.
					</li>
					<li>
						<strong>Создание нового экземпляра обекта Error</strong>
						<pre>new Error(message);</pre>
						Создали экземпляр объекта Error, текс 'message' записывается в свойство объекта message.
					</li>
					<li>
						Пример вызова конструктора Error
						<pre>
try {
    throw new Error('Что-то пошло не так!');
} catch (e) {
    console.log(e.name + ':' + e.message);
}</pre>
						В данном примере мы создали объект типа Error с именем Error и текстом сообщения об ошибке "Что-то пошло не так !".
					</li>
					<li>
						Меняем конструкцию, из примера с факториалом и исклчения, добавим объект Error
						<pre>
// объявление функции
function testFactorial(inputData) {
    if (inputData < 0) // если число меньше 0
        throw new Error('Число не должно быть меньше нуля'); // создаём объект Error
    return (inputData) ? (inputData * testFactorial(inputData - 1)) : 1; 
}

var myNumber = -5;

try {
    document.write(testFactorial(myNumber)); //попытка вызова функции (если число больше 0)
} catch(ex) {
    document.write(ex.message); // вывод сообщение об ошибке
}</pre>
						В данном случае мы перехватили исключение и вывели в документ его свойство message, в которое ранее поместили текст - "Число не должно быть меньше нуля".
					</li>
					<li>
						Задание:  передаются два параметра: целочисленная переменная ("а") и некоторая функция ("func"). Вам необходимо запустить функцию "func", с переменной "а" в качестве аргумента. Но вот проблема - в функции, похоже, оказалась ошибка. Вам нужно возвратить имя (свойство "name") возникающей ошибки.
						<pre>
function testErrorFunc(a, func) {
    try {
        func(a);  // пробуем запустить функцию func
    } catch(x) {
        return x.name;  // выводим имя ошибки , если функция не запустилась
    }
}

console.log(testErrorFunc(9));  // функция не запустится так как есть только 1 аргумент
// TypeError или EvalError</pre>
					</li>
				</ul>
			</li>



&lt;



			<li>
				<span class="spec">
					Введение в регулярные выражения<hr>
				</span>
				<ul>
					<li>
						<strong>Регулярное выражение (RegExp - regular expressions</strong> - это объект, который может описывать шаблон символов.
						<br>Например, если вы ищете в строке подстроку, вы можете описать шаблон того, что вы ищете.
						<br>Содержание шаблона регулярного выражения состоит из последовательности символов.
						<pre>
/hello/
/hello$/ - выражение будет соответствовать строкам, которые ЗАКАНЧИВАЮТСЯ на слово "hello". Это обеспечивает метасимвол "$", обозначающий конец строки.</pre>
					</li>
					<li>
						<strong>Создание объекта RegExp</strong>
						<br>- Первый вариант - с помощью конструктора RegExp()
						<pre>
var myPattern = new RegExp('q$');</pre>
						- Второй вариант - с помощью литерала
						<pre>
var myPattern = /q$/;</pre>
					</li>
					<li>
						<strong>Из чего можно создать регулярные выражения</strong>
						<hr>
						<strong>Цифры и буквы (символы)</strong> - алфавитные и цифровые символы, обозначают сами себя
						<br><strong>\0</strong> - Символ NUL (Соответствует \u0000 в Unicode)
						<br><strong>\t</strong> - Табуляция (\u0009)
						<br><strong>\n</strong> - Перевод строки (\u000A)
						<br><strong>\v</strong> - Вертикальная табуляция (\u000B)
						<br><strong>\f</strong> - Перевод страницы (\u000C)
						<br><strong>\r</strong> - Возврат каретки (\u000D)
						<br><strong>\xnn</strong> -  Символ из набора Latin, задаваемый шестнадцатиричным номером nn
						<br><strong>\unnnn</strong> - Символ Unicode,  задаваемый шестнадцатиричным номером nnnn
						<br><strong>\cX</strong> - Управляющий символ "Х", например \сJ эквивалентна \n
						<br><strong>^ $ . * + ? = ! : | \ / ( ) [ ] { }</strong>
						<hr>
						 Для определения смысла этих символов буквально, т.е. "самих себя", необходимо перед ними ставить символ обратного слэша.
						 <br>Если нужно написать выражение, по которому будет находится символ обратного слэша \\, должны в выражение поставить этот символ, предваряемый таким же символом обратного слэша. ???
						 <pre>/\\/</pre>
					</li>
					<li>
						<strong>Проверка есть ли рег выражение в строке</strong>
						<br><a href="https://regexr.com/">https://regexr.com/</a>
					</li>
					<li>
						Отдельные символы могут быть объеденины в <strong>классы</strong>. Для этого необължимо заключить в []
						<pre>/[0123456789]/</pre>
						<br><strong>^</strong> - определить регулярное выражение, которое будет соответствовать любому символу, <strong>КРОМЕ</strong> тех, которые указаны в скобках - класс с отрицанием.
						<pre>/[^0123456789]/</pre>
						<strong>-</strong> - диапазон в классах регулярных выражений
						<pre>/[0-9]/</pre>
					</li>
					<li>
						Некоторые классы из наборов символов настолько часто используются, что для них определили специальные обозначения:
						<br><strong>Специальные обозначения символов</strong>
						<hr>
						<strong>[...]</strong> - любой из символов, указанных в скобках
						<br><strong>[^...]</strong> - любой кроме символов, указанных в скобках
						<br><strong>.</strong> - любой символ кроме перевода строки или другого разделителя строки
						<br><strong>\w</strong> - эквивалентно [a-zA-Z0-9_] (Любой цифробуквенный символ включая подчеркивание)
						<br><strong>\W</strong> - эквивалентно [^a-zA-Z0-9_] (Любой символ кроме цифробуквенных символов и подчеркивания)
						<br><strong>\s</strong> - любой пробельный символ из Unicode
						<br><strong>\S</strong> - любой НЕпробельный символ из Unicode
						<br><strong>\d</strong> - эквивалентно [0-9] (любые цифры ASCII)
						<br><strong>\D</strong> - эквивалентно [^0-9] (все символы кроме цифр ASCII)
						<br><strong>[\b]</strong> - обозначение символа "забой" 
						<hr>
						Последовательности таких управляющих символов также можно объединить в класс, например регулярное выражение
						<pre>/[\w\s]/</pre> соответствует любому пробельному символу или символу ASCII - букве или цифре.
					</li>
					<li>
						<strong>Квантификация</strong> - многократные повторения.
						<br>Для кватнификации в регулярных выражений, есть набор символов, которые заключаются в <strong>Фигурные скобки - {}</strong>
						<pre>/\d{4}/ - соответстует числу из 4-х цифр</pre>
					</li>
					<li>
						<strong>Управляющие комбинации для повторений</strong>
						<hr>
						<strong>{n}</strong> - обозначает ровно n экземпляров шаблона
						<br><strong>{n,}</strong> - обозначает n или больше экземпляров шаблона  
						<br><strong>{n,m}</strong> - обозначает не менее n и не более m экземпляров шаблона
						<br><strong>?</strong> - бозначает ноль или один экземпляр шаблона (эквивалентно выражению {0,1} )
						<br><strong>+</strong> - обозначает 1 или более экземпляров шаблона (эквивалентно выражению {1,} )
						<br><strong>*</strong> - обозначает ноль или более экземпляров шаблона (эквивалентно выражению {0,} )
						<hr>
						Например - примененное к строке "ххх" будет соответствовать максимальному количеству совпадений, т.е. всем трем буквам "х", встреченным в строке. Это называется "жадным" повторением. ("жадной" квантификацией).
						<pre>/x{1,}/</pre>
						Если же мы хотим ограничить поиск первым же вхождением, то может использовать так называемую "нежадную", или "ленивую" квантификацию. Для этого после управляющей комбинации повторений ставится символ "?". Таким образом выражение
						<pre>/х{1,}?/</pre> будет соответствовать только первому соответствию, т.е. только первой букве "х" в строк
					</li>
					<li>
						<strong>Альтернатива - |</strong>, т.е. можно указать больше одного варианта шаблона, соответствие которому будет проверяться.
						<pre>/ma|pa|da/</pre>
						будет соответствовать либо строке "ma" либо строке "pa" либо строке "da".
						<br>
						<br>
						Комбирирование альтернативы с классами и с повторениями
						<pre>/\d{2}|[a-z]{2}|[A-Z]{2}/</pre>
						Необходимо обратить внимание, что альтернативы обрабатываются слева направо до первого соответствия. После нахождения первого соответствия остальные альтернативы будут игнорироваться. На практике это означает что, например, шаблон /1|12|123/ примененный к строке "123", будет соответствовать первому символу, хотя в альтернативах есть гораздо более полное соответствие.
					</li>
					<li>
						<strong>Группировка - ()</strong>
						 При этом элементы, используемые совместно со специальными символами, например |, +, *, ? и другие, будут рассматриваться как одно целое.
						 <pre>/regular(expression)?/ - будет соответствовать слову "regular" за которым следует необязательное слово "expression".</pre>
					</li>
					<li>
						<strong>Якорные выражения</strong>  - указания границ соответствия
						<hr>
						<strong>^</strong> - соответствует началу строки при многострочном поиске или началу строкового выражения
						<br><strong>$</strong> - соответствует концу строки при многострочном поиске или концу строкового выражения
						<br><strong>\b</strong> -  соответствует границе слова, т.е. позиции между текстовым (aA-zZ) и не-текстовым символом, либо между текстовым символом и началом или концом строки.
						<br><strong>\B</strong> - Соответствует позиции, не являющейся границей слов.
						<br><strong>(?=p)</strong> - Позитивная опережающая проверка на последующие символы - убеждается в том, что последующие символы соответствуют шаблону "р" но не включает их в результат поиска.
						<br><strong>(?!p)</strong> - Негативная опережающая проверка на последующие символы - требует чтобы последующие символы НЕ соответствовали шаблону "р".
						<hr>
					</li>
					<li>
						<strong>Флаги</strong> - Флаги задают глобальные правила для всего шаблона и указываются не внутри символов слэша, в которые заключен шаблон, а ПОСЛЕ них.
						<strong>3 Варианта флагов</strong>
						<hr>
						<strong>i</strong> -  указывает на то, что поиск по шаблону должен быть не чувствительным к регистру
						<br><strong>g</strong> - указывает что поиск должен быть глобальным, т.е. должны быть найдены ВСЕ соответствия в строке
						<br><strong>m</strong> - указывает на то, что поиск должен производиться в многострочном режиме.
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
				</ul>
			</li>


&lt;


			<li>
				<span class="spec">
					Использование регулярных выражений<hr>
				</span>
				<ul>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
				</ul>
			</li>


&lt;


			<li>
				<span class="spec">
					Замыкания<hr>
				</span>
				<ul>
					<li>
						
					</li>
					<li>
						
					</li>
					<li>
						
					</li>
				</ul>
			</li>



&lt;			

		</ol> <!-- 3. Продвинутые операции -->







					

	</div><!-- container-md all -->

&lt; &lt; &lt;






<!-- JS Bootstrap 5 -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/js/bootstrap.bundle.min.js" integrity="sha384-gtEjrD/SeCtmISkJkNUaaKMoLD0//ElJ19smozuHV6z3Iehds+3Ulb9Bn9Plx0x4" crossorigin="anonymous"></script>


</body>
</html>


